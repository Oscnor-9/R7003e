var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"LabB_PIDOverRobot","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"LabB_PIDOverRobot.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  sei();\r\n\r\n#endif;\r\n\r\n  LabB_PIDOverRobot_step();\r\n\r\n  /* Get model outputs here */\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  cli();\r\n\r\n#endif;\r\n\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.005;\r\n  float systemClock = 0;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  init();\r\n  MW_Arduino_Init();\r\n  rtmSetErrorStatus(LabB_PIDOverRobot_M, 0);\r\n  LabB_PIDOverRobot_initialize();\r\n  cli();\r\n  configureArduinoAVRTimer();\r\n  runModel = rtmGetErrorStatus(LabB_PIDOverRobot_M) == (NULL);\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  sei();\r\n\r\n#endif;\r\n\r\n  sei();\r\n  while (runModel) {\r\n    stopRequested = !(rtmGetErrorStatus(LabB_PIDOverRobot_M) == (NULL));\r\n    runModel = !(stopRequested);\r\n    MW_Arduino_Loop();\r\n  }\r\n\r\n  /* Terminate model */\r\n  LabB_PIDOverRobot_terminate();\r\n  cli();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LabB_PIDOverRobot.c","type":"source","group":"model","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LabB_PIDOverRobot.c\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"LabB_PIDOverRobot.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n#include \"LabB_PIDOverRobot_types.h\"\r\n#include \"LabB_PIDOverRobot_private.h\"\r\n#include <string.h>\r\n\r\n/* Block states (default storage) */\r\nD_Work_LabB_PIDOverRobot LabB_PIDOverRobot_DWork;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_LabB_PIDOverRobot LabB_PIDOverRobot_M_;\r\nRT_MODEL_LabB_PIDOverRobot *const LabB_PIDOverRobot_M = &LabB_PIDOverRobot_M_;\r\nreal_T rt_roundd_snf(real_T u)\r\n{\r\n  real_T y;\r\n  if (fabs(u) < 4.503599627370496E+15) {\r\n    if (u >= 0.5) {\r\n      y = floor(u + 0.5);\r\n    } else if (u > -0.5) {\r\n      y = u * 0.0;\r\n    } else {\r\n      y = ceil(u - 0.5);\r\n    }\r\n  } else {\r\n    y = u;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid LabB_PIDOverRobot_step(void)\r\n{\r\n  codertarget_arduinobase_inter_n *obj;\r\n  int32_T rtb_Encoder_0;\r\n  real32_T rtb_FilterCoefficient;\r\n  real32_T rtb_IntegralGain;\r\n  real32_T rtb_SaturationVsupplytoVsupply;\r\n  real32_T rtb_Sum_c;\r\n  real32_T tmp;\r\n  int16_T out[3];\r\n  uint16_T rtb_DataTypeConversion6;\r\n  uint8_T dataIn[15];\r\n\r\n  /* Gain: '<S40>/Filter Coefficient' incorporates:\r\n   *  DiscreteIntegrator: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n   *  DiscreteIntegrator: '<S32>/Filter'\r\n   *  Gain: '<S31>/Derivative Gain'\r\n   *  Sum: '<S32>/SumD'\r\n   */\r\n  rtb_FilterCoefficient = (LabB_PIDOverRobot_P.PIDController_D *\r\n    LabB_PIDOverRobot_DWork.DiscreteTimeIntegratorconvertfr -\r\n    LabB_PIDOverRobot_DWork.Filter_DSTATE) * LabB_PIDOverRobot_P.PIDController_N;\r\n\r\n  /* Sum: '<S46>/Sum' incorporates:\r\n   *  DiscreteIntegrator: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n   *  DiscreteIntegrator: '<S37>/Integrator'\r\n   *  Gain: '<S42>/Proportional Gain'\r\n   */\r\n  rtb_Sum_c = (LabB_PIDOverRobot_P.PIDController_P *\r\n               LabB_PIDOverRobot_DWork.DiscreteTimeIntegratorconvertfr +\r\n               LabB_PIDOverRobot_DWork.Integrator_DSTATE) +\r\n    rtb_FilterCoefficient;\r\n\r\n  /* Saturate: '<S44>/Saturation' */\r\n  if (rtb_Sum_c > LabB_PIDOverRobot_P.PIDController_UpperSaturationLi) {\r\n    rtb_SaturationVsupplytoVsupply =\r\n      LabB_PIDOverRobot_P.PIDController_UpperSaturationLi;\r\n  } else if (rtb_Sum_c < LabB_PIDOverRobot_P.PIDController_LowerSaturationLi) {\r\n    rtb_SaturationVsupplytoVsupply =\r\n      LabB_PIDOverRobot_P.PIDController_LowerSaturationLi;\r\n  } else {\r\n    rtb_SaturationVsupplytoVsupply = rtb_Sum_c;\r\n  }\r\n\r\n  /* End of Saturate: '<S44>/Saturation' */\r\n\r\n  /* DataTypeConversion: '<S5>/Data Type Conversion' incorporates:\r\n   *  Fcn: '<S5>/Fcn'\r\n   */\r\n  tmp = (real32_T)floor((rtb_SaturationVsupplytoVsupply + 10.0F) * 3276.8F);\r\n  if (rtIsNaNF(tmp) || rtIsInfF(tmp)) {\r\n    tmp = 0.0F;\r\n  } else {\r\n    tmp = (real32_T)fmod(tmp, 65536.0);\r\n  }\r\n\r\n  rtb_DataTypeConversion6 = tmp < 0.0F ? (uint16_T)-(int16_T)(uint16_T)-tmp :\r\n    (uint16_T)tmp;\r\n\r\n  /* End of DataTypeConversion: '<S5>/Data Type Conversion' */\r\n\r\n  /* MATLABSystem: '<S5>/Serial Transmit' incorporates:\r\n   *  DataTypeConversion: '<S54>/Extract Desired Bits'\r\n   *  DataTypeConversion: '<S55>/Extract Desired Bits'\r\n   */\r\n  dataIn[1] = (uint8_T)(rtb_DataTypeConversion6 >> 8);\r\n  dataIn[2] = (uint8_T)rtb_DataTypeConversion6;\r\n\r\n  /* MATLABSystem: '<S3>/Encoder' */\r\n  /*         %% Define output properties */\r\n  /* 'Encoder_arduino:136' num = 0; */\r\n  /* 'Encoder_arduino:140' num = 1; */\r\n  /* 'Encoder_arduino:121' y = int32(0); */\r\n  /* 'Encoder_arduino:122' if coder.target('Rtw') */\r\n  /*  Call: int enc_output(int enc) */\r\n  /* 'Encoder_arduino:124' y = coder.ceval('enc_output', obj.Encoder); */\r\n  rtb_Encoder_0 = enc_output(1.0);\r\n\r\n  /* DataTypeConversion: '<S5>/Data Type Conversion1' incorporates:\r\n   *  DataTypeConversion: '<S3>/Data Type  Conversion2'\r\n   *  Fcn: '<S5>/Fcn1'\r\n   *  Gain: '<S2>/convert to  radians'\r\n   *  Gain: '<S2>/convert to meters'\r\n   *  MATLABSystem: '<S3>/Encoder'\r\n   */\r\n  tmp = (real32_T)floor((LabB_PIDOverRobot_P.converttoradians_Gain * (real32_T)\r\n    rtb_Encoder_0 * LabB_PIDOverRobot_P.fWheelRadius + 10.0F) * 3276.8F);\r\n  if (rtIsNaNF(tmp) || rtIsInfF(tmp)) {\r\n    tmp = 0.0F;\r\n  } else {\r\n    tmp = (real32_T)fmod(tmp, 65536.0);\r\n  }\r\n\r\n  rtb_DataTypeConversion6 = tmp < 0.0F ? (uint16_T)-(int16_T)(uint16_T)-tmp :\r\n    (uint16_T)tmp;\r\n\r\n  /* End of DataTypeConversion: '<S5>/Data Type Conversion1' */\r\n\r\n  /* MATLABSystem: '<S5>/Serial Transmit' incorporates:\r\n   *  DataTypeConversion: '<S60>/Extract Desired Bits'\r\n   *  DataTypeConversion: '<S61>/Extract Desired Bits'\r\n   */\r\n  dataIn[3] = (uint8_T)(rtb_DataTypeConversion6 >> 8);\r\n  dataIn[4] = (uint8_T)rtb_DataTypeConversion6;\r\n\r\n  /* DataTypeConversion: '<S5>/Data Type Conversion2' incorporates:\r\n   *  DiscreteIntegrator: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n   *  Fcn: '<S5>/Fcn2'\r\n   */\r\n  tmp = (real32_T)floor((LabB_PIDOverRobot_DWork.DiscreteTimeIntegratorconvertfr\r\n    + 10.0F) * 3276.8F);\r\n  if (rtIsNaNF(tmp) || rtIsInfF(tmp)) {\r\n    tmp = 0.0F;\r\n  } else {\r\n    tmp = (real32_T)fmod(tmp, 65536.0);\r\n  }\r\n\r\n  rtb_DataTypeConversion6 = tmp < 0.0F ? (uint16_T)-(int16_T)(uint16_T)-tmp :\r\n    (uint16_T)tmp;\r\n\r\n  /* End of DataTypeConversion: '<S5>/Data Type Conversion2' */\r\n\r\n  /* MATLABSystem: '<S5>/Serial Transmit' incorporates:\r\n   *  Constant: '<S5>/Constant'\r\n   *  DataTypeConversion: '<S58>/Extract Desired Bits'\r\n   *  DataTypeConversion: '<S59>/Extract Desired Bits'\r\n   *  DataTypeConversion: '<S62>/Extract Desired Bits'\r\n   *  DataTypeConversion: '<S63>/Extract Desired Bits'\r\n   *  SignalConversion generated from: '<S5>/Serial Transmit'\r\n   */\r\n  if (LabB_PIDOverRobot_DWork.obj.Protocol !=\r\n      LabB_PIDOverRobot_P.SerialTransmit_Protocol) {\r\n    LabB_PIDOverRobot_DWork.obj.Protocol =\r\n      LabB_PIDOverRobot_P.SerialTransmit_Protocol;\r\n  }\r\n\r\n  dataIn[0] = LabB_PIDOverRobot_P.Constant_Value_p;\r\n  dataIn[5] = (uint8_T)(rtb_DataTypeConversion6 >> 8);\r\n  dataIn[6] = (uint8_T)rtb_DataTypeConversion6;\r\n  dataIn[7] = 128U;\r\n  dataIn[8] = 0U;\r\n  dataIn[9] = 128U;\r\n  dataIn[10] = 0U;\r\n  dataIn[11] = 128U;\r\n  dataIn[12] = 0U;\r\n  dataIn[13] = 128U;\r\n  dataIn[14] = 0U;\r\n  MW_Serial_write(LabB_PIDOverRobot_DWork.obj.port, &dataIn[0], 15.0,\r\n                  LabB_PIDOverRobot_DWork.obj.dataSizeInBytes,\r\n                  LabB_PIDOverRobot_DWork.obj.sendModeEnum,\r\n                  LabB_PIDOverRobot_DWork.obj.dataType,\r\n                  LabB_PIDOverRobot_DWork.obj.sendFormatEnum, 2.0, '\\x00');\r\n\r\n  /* Gain: '<S30>/Kb' incorporates:\r\n   *  Sum: '<S30>/SumI2'\r\n   */\r\n  rtb_Sum_c = (rtb_SaturationVsupplytoVsupply - rtb_Sum_c) *\r\n    LabB_PIDOverRobot_P.PIDController_Kb;\r\n\r\n  /* Gain: '<S34>/Integral Gain' incorporates:\r\n   *  DiscreteIntegrator: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n   */\r\n  rtb_IntegralGain = LabB_PIDOverRobot_P.PIDController_I *\r\n    LabB_PIDOverRobot_DWork.DiscreteTimeIntegratorconvertfr;\r\n\r\n  /* Product: '<S1>/Product1' incorporates:\r\n   *  DiscreteIntegrator: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n   *  Fcn: '<S1>/turn off the motor if the measured angle is greater than X degrees'\r\n   */\r\n  rtb_SaturationVsupplytoVsupply *= (real32_T)((real32_T)fabs\r\n    (LabB_PIDOverRobot_DWork.DiscreteTimeIntegratorconvertfr) < 0.75F);\r\n\r\n  /* MATLABSystem: '<S3>/Gyroscope' */\r\n  /*  initialize output to a single (float) with the value zero */\r\n  /* 'soMPU6050Gyro:59' out = int16(zeros(3,1)); */\r\n  /* 'soMPU6050Gyro:60' if coder.target('Rtw') */\r\n  /*  done only for code gen */\r\n  /* 'soMPU6050Gyro:61' coder.cinclude('MPU6050wrapper.h'); */\r\n  /*  get the current value of the sensor */\r\n  /* 'soMPU6050Gyro:63' coder.ceval('MPU6050Gyro_Read', coder.wref(out)); */\r\n  MPU6050Gyro_Read(&out[0]);\r\n\r\n  /* MATLABSystem: '<S68>/Digital Output1' incorporates:\r\n   *  Constant: '<S69>/Constant'\r\n   *  RelationalOperator: '<S69>/Compare'\r\n   */\r\n  /*  pull the data appart */\r\n  /* 'soMPU6050Gyro:68' xvel = out(1); */\r\n  /* 'soMPU6050Gyro:69' yvel = out(2); */\r\n  /* 'soMPU6050Gyro:70' zvel = out(3); */\r\n  writeDigitalPin(8, (uint8_T)(rtb_SaturationVsupplytoVsupply <\r\n    LabB_PIDOverRobot_P.Constant_Value));\r\n\r\n  /* MATLABSystem: '<S68>/PWM' */\r\n  obj = &LabB_PIDOverRobot_DWork.obj_a;\r\n  obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(6UL);\r\n\r\n  /* Saturate: '<S68>/Saturation -Vsupply to Vsupply' */\r\n  if (rtb_SaturationVsupplytoVsupply >\r\n      LabB_PIDOverRobot_P.M1V4LeftMotorDriverPWM6D8FST_Vs) {\r\n    rtb_SaturationVsupplytoVsupply =\r\n      LabB_PIDOverRobot_P.M1V4LeftMotorDriverPWM6D8FST_Vs;\r\n  } else if (rtb_SaturationVsupplytoVsupply <\r\n             LabB_PIDOverRobot_P.SaturationVsupplytoVsupply_Lowe) {\r\n    rtb_SaturationVsupplytoVsupply =\r\n      LabB_PIDOverRobot_P.SaturationVsupplytoVsupply_Lowe;\r\n  }\r\n\r\n  /* Gain: '<S68>/conversion to dutycycle (convert to uint8, overflow will provide reverse polairty magnitued)' incorporates:\r\n   *  Saturate: '<S68>/Saturation -Vsupply to Vsupply'\r\n   */\r\n  tmp = (real32_T)floor(LabB_PIDOverRobot_P.conversiontodutycycleconverttou *\r\n                        rtb_SaturationVsupplytoVsupply);\r\n  if (rtIsNaNF(tmp) || rtIsInfF(tmp)) {\r\n    tmp = 0.0F;\r\n  } else {\r\n    tmp = (real32_T)fmod(tmp, 256.0);\r\n  }\r\n\r\n  /* MATLABSystem: '<S68>/PWM' incorporates:\r\n   *  Gain: '<S68>/conversion to dutycycle (convert to uint8, overflow will provide reverse polairty magnitued)'\r\n   */\r\n  MW_PWM_SetDutyCycle(LabB_PIDOverRobot_DWork.obj_a.PWMDriverObj.MW_PWM_HANDLE,\r\n                      (real_T)(tmp < 0.0F ? (int16_T)(uint8_T)-(int8_T)(uint8_T)\r\n    -tmp : (int16_T)(uint8_T)tmp));\r\n\r\n  /* Update for DiscreteIntegrator: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)' incorporates:\r\n   *  Constant: '<S2>/gyro bias'\r\n   *  DataTypeConversion: '<S3>/Data Type  Conversion1'\r\n   *  Gain: '<S2>/convert to radians//sec'\r\n   *  MATLABSystem: '<S3>/Gyroscope'\r\n   *  Sum: '<S2>/Sum'\r\n   */\r\n  LabB_PIDOverRobot_DWork.DiscreteTimeIntegratorconvertfr += ((real32_T)out[0] -\r\n    LabB_PIDOverRobot_P.fGyroBias) *\r\n    LabB_PIDOverRobot_P.converttoradianssec_Gain *\r\n    LabB_PIDOverRobot_P.DiscreteTimeIntegratorconvertfr;\r\n\r\n  /* Update for DiscreteIntegrator: '<S37>/Integrator' incorporates:\r\n   *  Sum: '<S30>/SumI4'\r\n   */\r\n  LabB_PIDOverRobot_DWork.Integrator_DSTATE += (rtb_Sum_c + rtb_IntegralGain) *\r\n    LabB_PIDOverRobot_P.Integrator_gainval;\r\n\r\n  /* Update for DiscreteIntegrator: '<S32>/Filter' */\r\n  LabB_PIDOverRobot_DWork.Filter_DSTATE += LabB_PIDOverRobot_P.Filter_gainval *\r\n    rtb_FilterCoefficient;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid LabB_PIDOverRobot_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* non-finite (run-time) assignments */\r\n  LabB_PIDOverRobot_P.fGyroBias = rtNaNF;\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(LabB_PIDOverRobot_M, (NULL));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&LabB_PIDOverRobot_DWork, 0,\r\n                sizeof(D_Work_LabB_PIDOverRobot));\r\n\r\n  {\r\n    codertarget_arduinobase_inter_n *obj;\r\n    real_T tmp;\r\n    uint8_T tmp_0;\r\n\r\n    /* Start for MATLABSystem: '<S3>/Encoder' */\r\n    /*  Constructor */\r\n    /* 'Encoder_arduino:36' coder.allowpcode('plain'); */\r\n    /* 'Encoder_arduino:1' matlab.System */\r\n    /* 'Encoder_arduino:2' coder.ExternalDependency */\r\n    /* 'Encoder_arduino:3' matlab.system.mixin.Propagates */\r\n    /* 'Encoder_arduino:4' matlab.system.mixin.CustomIcon */\r\n    /*  Support name-value pair arguments when constructing the object. */\r\n    /* 'Encoder_arduino:39' setProperties(obj,nargin,varargin{:}); */\r\n    LabB_PIDOverRobot_DWork.obj_l.matlabCodegenIsDeleted = false;\r\n\r\n    /* 'Encoder_arduino:69' validateattributes(value,... */\r\n    /* 'Encoder_arduino:70'                 {'numeric'},... */\r\n    /* 'Encoder_arduino:71'                 {'real','nonnegative','integer','scalar','>=',0,'<=',obj.MaxNumEncoder},... */\r\n    /* 'Encoder_arduino:72'                 '', ... */\r\n    /* 'Encoder_arduino:73'                 'Encoder'); */\r\n    /* 'Encoder_arduino:74' obj.Encoder = value; */\r\n    /* 'Encoder_arduino:43' coder.extrinsic('sprintf') */\r\n    /*  Do not generate code for sprintf */\r\n    /* 'Encoder_arduino:44' validateattributes(value,... */\r\n    /* 'Encoder_arduino:45'                 {'numeric'},... */\r\n    /* 'Encoder_arduino:46'                 {'real','nonnegative','integer','scalar'},... */\r\n    /* 'Encoder_arduino:47'                 '', ... */\r\n    /* 'Encoder_arduino:48'                 'PinA'); */\r\n    /* 'Encoder_arduino:49' assert(any(value == obj.AvailablePin), ... */\r\n    /* 'Encoder_arduino:50'                 'Invalid value for Pin. Pin must be one of the following: %s', ... */\r\n    /* 'Encoder_arduino:51'                 sprintf('%d ', obj.AvailablePin)); */\r\n    /* 'Encoder_arduino:52' obj.PinA = value; */\r\n    /* 'Encoder_arduino:56' coder.extrinsic('sprintf') */\r\n    /*  Do not generate code for sprintf */\r\n    /* 'Encoder_arduino:57' validateattributes(value,... */\r\n    /* 'Encoder_arduino:58'                 {'numeric'},... */\r\n    /* 'Encoder_arduino:59'                 {'real','nonnegative','integer','scalar'},... */\r\n    /* 'Encoder_arduino:60'                 '', ... */\r\n    /* 'Encoder_arduino:61'                 'PinB'); */\r\n    /* 'Encoder_arduino:62' assert(any(value == obj.AvailablePin), ... */\r\n    /* 'Encoder_arduino:63'                 'Invalid value for Pin. Pin must be one of the following: %s', ... */\r\n    /* 'Encoder_arduino:64'                 sprintf('%d ', obj.AvailablePin)); */\r\n    /* 'Encoder_arduino:65' obj.PinB = value; */\r\n    LabB_PIDOverRobot_DWork.obj_l.isInitialized = 1L;\r\n\r\n    /*         %% Define output properties */\r\n    /* 'Encoder_arduino:136' num = 0; */\r\n    /*         %% Define output properties */\r\n    /* 'Encoder_arduino:136' num = 0; */\r\n    /* 'Encoder_arduino:108' if coder.target('Rtw') */\r\n    /*    Call: void enc_init(int enc, int pinA, int pinB) */\r\n    /* 'Encoder_arduino:110' coder.cinclude('encoder_arduino.h'); */\r\n    /* 'Encoder_arduino:111' coder.ceval('enc_init', obj.Encoder, obj.PinA, obj.PinB); */\r\n    enc_init(1.0, 19.0, 18.0);\r\n\r\n    /*                  if(obj.PWMTimer> 0) */\r\n    /*                      coder.cinclude('PWMFSelect.h'); */\r\n    /*                      coder.ceval('PWM_Select', obj.PWMFSelect, obj.PWMTimer); */\r\n    /*                      disp('skipp!!!') */\r\n    /*                  end */\r\n    LabB_PIDOverRobot_DWork.obj_l.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<S5>/Serial Transmit' */\r\n    LabB_PIDOverRobot_DWork.obj.matlabCodegenIsDeleted = false;\r\n    LabB_PIDOverRobot_DWork.obj.Protocol =\r\n      LabB_PIDOverRobot_P.SerialTransmit_Protocol;\r\n    LabB_PIDOverRobot_DWork.obj.isInitialized = 1L;\r\n    LabB_PIDOverRobot_DWork.obj.port = 0.0;\r\n    LabB_PIDOverRobot_DWork.obj.dataSizeInBytes = 1.0;\r\n    LabB_PIDOverRobot_DWork.obj.dataType = 0.0;\r\n    LabB_PIDOverRobot_DWork.obj.sendModeEnum = 0.0;\r\n    LabB_PIDOverRobot_DWork.obj.sendFormatEnum = 0.0;\r\n    tmp = rt_roundd_snf(LabB_PIDOverRobot_DWork.obj.port);\r\n    if (tmp < 256.0) {\r\n      if (tmp >= 0.0) {\r\n        tmp_0 = (uint8_T)tmp;\r\n      } else {\r\n        tmp_0 = 0U;\r\n      }\r\n    } else {\r\n      tmp_0 = MAX_uint8_T;\r\n    }\r\n\r\n    MW_SCI_Open(tmp_0);\r\n    LabB_PIDOverRobot_DWork.obj.isSetupComplete = true;\r\n\r\n    /* End of Start for MATLABSystem: '<S5>/Serial Transmit' */\r\n\r\n    /* Start for MATLABSystem: '<S3>/Gyroscope' */\r\n    /*  Constructor */\r\n    /* 'soMPU6050Gyro:27' coder.allowpcode('plain'); */\r\n    /* 'soMPU6050Gyro:1' matlab.System */\r\n    /* 'soMPU6050Gyro:1' coder.ExternalDependency */\r\n    /*  Support name-value pair arguments when constructing the object. */\r\n    /* 'soMPU6050Gyro:30' setProperties(obj,nargin,varargin{:}); */\r\n    LabB_PIDOverRobot_DWork.obj_ls.matlabCodegenIsDeleted = false;\r\n\r\n    /* 'soMPU6050Gyro:34' coder.extrinsic('sprintf'); */\r\n    /*  Do not generate code for sprintf */\r\n    /* 'soMPU6050Gyro:35' validateattributes(value,... */\r\n    /* 'soMPU6050Gyro:36'                 {'numeric'},... */\r\n    /* 'soMPU6050Gyro:37'                 {'real','nonnegative','integer','scalar'},... */\r\n    /* 'soMPU6050Gyro:38'                 '', ... */\r\n    /* 'soMPU6050Gyro:39'                 'DLPFmode'); */\r\n    /* 'soMPU6050Gyro:40' obj.DLPFmode = value; */\r\n    LabB_PIDOverRobot_DWork.obj_ls.isInitialized = 1L;\r\n\r\n    /* 'soMPU6050Gyro:46' if coder.target('Rtw') */\r\n    /*  done only for code gen */\r\n    /* 'soMPU6050Gyro:47' coder.cinclude('MPU6050wrapper.h'); */\r\n    /*  initialize the sensor */\r\n    /*                  coder.ceval('MPU6050Accel_Init'); */\r\n    /* 'soMPU6050Gyro:51' coder.ceval('MPU6050Gyro_Init', obj.DLPFmode); */\r\n    MPU6050Gyro_Init(0.0);\r\n    LabB_PIDOverRobot_DWork.obj_ls.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<S68>/Digital Output1' */\r\n    LabB_PIDOverRobot_DWork.obj_i.matlabCodegenIsDeleted = false;\r\n    LabB_PIDOverRobot_DWork.obj_i.isInitialized = 1L;\r\n    digitalIOSetup(8, 1);\r\n    LabB_PIDOverRobot_DWork.obj_i.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<S68>/PWM' */\r\n    LabB_PIDOverRobot_DWork.obj_a.matlabCodegenIsDeleted = false;\r\n    obj = &LabB_PIDOverRobot_DWork.obj_a;\r\n    LabB_PIDOverRobot_DWork.obj_a.isInitialized = 1L;\r\n    obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_Open(6UL, 0.0, 0.0);\r\n    LabB_PIDOverRobot_DWork.obj_a.isSetupComplete = true;\r\n\r\n    /* InitializeConditions for DiscreteIntegrator: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)' */\r\n    LabB_PIDOverRobot_DWork.DiscreteTimeIntegratorconvertfr =\r\n      LabB_PIDOverRobot_P.DiscreteTimeIntegratorconvert_o;\r\n\r\n    /* InitializeConditions for DiscreteIntegrator: '<S37>/Integrator' */\r\n    LabB_PIDOverRobot_DWork.Integrator_DSTATE =\r\n      LabB_PIDOverRobot_P.PIDController_InitialConditio_n;\r\n\r\n    /* InitializeConditions for DiscreteIntegrator: '<S32>/Filter' */\r\n    LabB_PIDOverRobot_DWork.Filter_DSTATE =\r\n      LabB_PIDOverRobot_P.PIDController_InitialConditionF;\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid LabB_PIDOverRobot_terminate(void)\r\n{\r\n  codertarget_arduinobase_inter_n *obj;\r\n\r\n  /* Terminate for MATLABSystem: '<S3>/Encoder' */\r\n  if (!LabB_PIDOverRobot_DWork.obj_l.matlabCodegenIsDeleted) {\r\n    LabB_PIDOverRobot_DWork.obj_l.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S3>/Encoder' */\r\n\r\n  /* Terminate for MATLABSystem: '<S5>/Serial Transmit' */\r\n  if (!LabB_PIDOverRobot_DWork.obj.matlabCodegenIsDeleted) {\r\n    LabB_PIDOverRobot_DWork.obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S5>/Serial Transmit' */\r\n\r\n  /* Terminate for MATLABSystem: '<S3>/Gyroscope' */\r\n  if (!LabB_PIDOverRobot_DWork.obj_ls.matlabCodegenIsDeleted) {\r\n    LabB_PIDOverRobot_DWork.obj_ls.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S3>/Gyroscope' */\r\n\r\n  /* Terminate for MATLABSystem: '<S68>/Digital Output1' */\r\n  if (!LabB_PIDOverRobot_DWork.obj_i.matlabCodegenIsDeleted) {\r\n    LabB_PIDOverRobot_DWork.obj_i.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S68>/Digital Output1' */\r\n\r\n  /* Terminate for MATLABSystem: '<S68>/PWM' */\r\n  obj = &LabB_PIDOverRobot_DWork.obj_a;\r\n  if (!LabB_PIDOverRobot_DWork.obj_a.matlabCodegenIsDeleted) {\r\n    LabB_PIDOverRobot_DWork.obj_a.matlabCodegenIsDeleted = true;\r\n    if ((LabB_PIDOverRobot_DWork.obj_a.isInitialized == 1L) &&\r\n        LabB_PIDOverRobot_DWork.obj_a.isSetupComplete) {\r\n      obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(6UL);\r\n      MW_PWM_SetDutyCycle\r\n        (LabB_PIDOverRobot_DWork.obj_a.PWMDriverObj.MW_PWM_HANDLE, 0.0);\r\n      obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(6UL);\r\n      MW_PWM_Close(LabB_PIDOverRobot_DWork.obj_a.PWMDriverObj.MW_PWM_HANDLE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<S68>/PWM' */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LabB_PIDOverRobot.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LabB_PIDOverRobot.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_LabB_PIDOverRobot_h_\r\n#define RTW_HEADER_LabB_PIDOverRobot_h_\r\n#ifndef LabB_PIDOverRobot_COMMON_INCLUDES_\r\n#define LabB_PIDOverRobot_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"MW_SerialRead.h\"\r\n#include \"MW_SerialWrite.h\"\r\n#include \"encoder_arduino.h\"\r\n#include \"MPU6050wrapper.h\"\r\n#include \"MW_arduino_digitalio.h\"\r\n#include \"MW_PWM.h\"\r\n#endif                                 /* LabB_PIDOverRobot_COMMON_INCLUDES_ */\r\n\r\n#include \"LabB_PIDOverRobot_types.h\"\r\n#include <stddef.h>\r\n#include <string.h>\r\n#include \"rt_nonfinite.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  codertarget_arduinobase_interna obj; /* '<S5>/Serial Transmit' */\r\n  Encoder_arduino_LabB_PIDOverRob obj_l;/* '<S3>/Encoder' */\r\n  soMPU6050Gyro_LabB_PIDOverRobot obj_ls;/* '<S3>/Gyroscope' */\r\n  codertarget_arduinobase_blocks_ obj_i;/* '<S68>/Digital Output1' */\r\n  codertarget_arduinobase_inter_n obj_a;/* '<S68>/PWM' */\r\n  real32_T DiscreteTimeIntegratorconvertfr;\r\n    /* '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)' */\r\n  real32_T Integrator_DSTATE;          /* '<S37>/Integrator' */\r\n  real32_T Filter_DSTATE;              /* '<S32>/Filter' */\r\n} D_Work_LabB_PIDOverRobot;\r\n\r\n/* Parameters (default storage) */\r\nstruct Parameters_LabB_PIDOverRobot_ {\r\n  real32_T fGyroBias;                  /* Variable: fGyroBias\r\n                                        * Referenced by: '<S2>/gyro bias'\r\n                                        */\r\n  real32_T fWheelRadius;               /* Variable: fWheelRadius\r\n                                        * Referenced by: '<S2>/convert to meters'\r\n                                        */\r\n  real32_T PIDController_D;            /* Mask Parameter: PIDController_D\r\n                                        * Referenced by: '<S31>/Derivative Gain'\r\n                                        */\r\n  real32_T PIDController_I;            /* Mask Parameter: PIDController_I\r\n                                        * Referenced by: '<S34>/Integral Gain'\r\n                                        */\r\n  real32_T PIDController_InitialConditionF;\r\n                              /* Mask Parameter: PIDController_InitialConditionF\r\n                               * Referenced by: '<S32>/Filter'\r\n                               */\r\n  real32_T PIDController_InitialConditio_n;\r\n                              /* Mask Parameter: PIDController_InitialConditio_n\r\n                               * Referenced by: '<S37>/Integrator'\r\n                               */\r\n  real32_T PIDController_Kb;           /* Mask Parameter: PIDController_Kb\r\n                                        * Referenced by: '<S30>/Kb'\r\n                                        */\r\n  real32_T PIDController_LowerSaturationLi;\r\n                              /* Mask Parameter: PIDController_LowerSaturationLi\r\n                               * Referenced by: '<S44>/Saturation'\r\n                               */\r\n  real32_T PIDController_N;            /* Mask Parameter: PIDController_N\r\n                                        * Referenced by: '<S40>/Filter Coefficient'\r\n                                        */\r\n  real32_T PIDController_P;            /* Mask Parameter: PIDController_P\r\n                                        * Referenced by: '<S42>/Proportional Gain'\r\n                                        */\r\n  real32_T PIDController_UpperSaturationLi;\r\n                              /* Mask Parameter: PIDController_UpperSaturationLi\r\n                               * Referenced by: '<S44>/Saturation'\r\n                               */\r\n  real32_T M1V4LeftMotorDriverPWM6D8FST_Vs;\r\n                              /* Mask Parameter: M1V4LeftMotorDriverPWM6D8FST_Vs\r\n                               * Referenced by: '<S68>/Saturation -Vsupply to Vsupply'\r\n                               */\r\n  real_T SerialTransmit_Protocol;      /* Expression: 0\r\n                                        * Referenced by: '<S5>/Serial Transmit'\r\n                                        */\r\n  real32_T Constant_Value;             /* Computed Parameter: Constant_Value\r\n                                        * Referenced by: '<S69>/Constant'\r\n                                        */\r\n  real32_T DiscreteTimeIntegratorconvertfr;\r\n                          /* Computed Parameter: DiscreteTimeIntegratorconvertfr\r\n                           * Referenced by: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n                           */\r\n  real32_T DiscreteTimeIntegratorconvert_o;\r\n                          /* Computed Parameter: DiscreteTimeIntegratorconvert_o\r\n                           * Referenced by: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n                           */\r\n  real32_T Integrator_gainval;         /* Computed Parameter: Integrator_gainval\r\n                                        * Referenced by: '<S37>/Integrator'\r\n                                        */\r\n  real32_T Filter_gainval;             /* Computed Parameter: Filter_gainval\r\n                                        * Referenced by: '<S32>/Filter'\r\n                                        */\r\n  real32_T converttoradians_Gain;   /* Computed Parameter: converttoradians_Gain\r\n                                     * Referenced by: '<S2>/convert to  radians'\r\n                                     */\r\n  real32_T converttoradianssec_Gain;\r\n                                 /* Computed Parameter: converttoradianssec_Gain\r\n                                  * Referenced by: '<S2>/convert to radians//sec'\r\n                                  */\r\n  real32_T SaturationVsupplytoVsupply_Lowe;\r\n                          /* Computed Parameter: SaturationVsupplytoVsupply_Lowe\r\n                           * Referenced by: '<S68>/Saturation -Vsupply to Vsupply'\r\n                           */\r\n  real32_T conversiontodutycycleconverttou;\r\n                          /* Computed Parameter: conversiontodutycycleconverttou\r\n                           * Referenced by: '<S68>/conversion to dutycycle (convert to uint8, overflow will provide reverse polairty magnitued)'\r\n                           */\r\n  uint8_T Constant_Value_p;            /* Computed Parameter: Constant_Value_p\r\n                                        * Referenced by: '<S5>/Constant'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_LabB_PIDOverRobot {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern Parameters_LabB_PIDOverRobot LabB_PIDOverRobot_P;\r\n\r\n/* Block states (default storage) */\r\nextern D_Work_LabB_PIDOverRobot LabB_PIDOverRobot_DWork;\r\n\r\n/* Model entry point functions */\r\nextern void LabB_PIDOverRobot_initialize(void);\r\nextern void LabB_PIDOverRobot_step(void);\r\nextern void LabB_PIDOverRobot_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_LabB_PIDOverRobot *const LabB_PIDOverRobot_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S54>/DTProp1' : Unused code path elimination\r\n * Block '<S54>/DTProp2' : Unused code path elimination\r\n * Block '<S55>/DTProp1' : Unused code path elimination\r\n * Block '<S55>/DTProp2' : Unused code path elimination\r\n * Block '<S56>/DTProp1' : Unused code path elimination\r\n * Block '<S56>/DTProp2' : Unused code path elimination\r\n * Block '<S57>/DTProp1' : Unused code path elimination\r\n * Block '<S57>/DTProp2' : Unused code path elimination\r\n * Block '<S58>/DTProp1' : Unused code path elimination\r\n * Block '<S58>/DTProp2' : Unused code path elimination\r\n * Block '<S59>/DTProp1' : Unused code path elimination\r\n * Block '<S59>/DTProp2' : Unused code path elimination\r\n * Block '<S60>/DTProp1' : Unused code path elimination\r\n * Block '<S60>/DTProp2' : Unused code path elimination\r\n * Block '<S61>/DTProp1' : Unused code path elimination\r\n * Block '<S61>/DTProp2' : Unused code path elimination\r\n * Block '<S62>/DTProp1' : Unused code path elimination\r\n * Block '<S62>/DTProp2' : Unused code path elimination\r\n * Block '<S63>/DTProp1' : Unused code path elimination\r\n * Block '<S63>/DTProp2' : Unused code path elimination\r\n * Block '<S64>/DTProp1' : Unused code path elimination\r\n * Block '<S64>/DTProp2' : Unused code path elimination\r\n * Block '<S65>/DTProp1' : Unused code path elimination\r\n * Block '<S65>/DTProp2' : Unused code path elimination\r\n * Block '<S66>/DTProp1' : Unused code path elimination\r\n * Block '<S66>/DTProp2' : Unused code path elimination\r\n * Block '<S67>/DTProp1' : Unused code path elimination\r\n * Block '<S67>/DTProp2' : Unused code path elimination\r\n * Block '<S54>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S55>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S56>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S57>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S58>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S59>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S60>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S61>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S62>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S63>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S64>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S65>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S66>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n * Block '<S67>/Modify Scaling Only' : Eliminate redundant data type conversion\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'LabB_PIDOverRobot'\r\n * '<S1>'   : 'LabB_PIDOverRobot/controller'\r\n * '<S2>'   : 'LabB_PIDOverRobot/measurement filter'\r\n * '<S3>'   : 'LabB_PIDOverRobot/plant'\r\n * '<S4>'   : 'LabB_PIDOverRobot/controller/PID Controller'\r\n * '<S5>'   : 'LabB_PIDOverRobot/controller/send through the serial port'\r\n * '<S6>'   : 'LabB_PIDOverRobot/controller/PID Controller/Anti-windup'\r\n * '<S7>'   : 'LabB_PIDOverRobot/controller/PID Controller/D Gain'\r\n * '<S8>'   : 'LabB_PIDOverRobot/controller/PID Controller/Filter'\r\n * '<S9>'   : 'LabB_PIDOverRobot/controller/PID Controller/Filter ICs'\r\n * '<S10>'  : 'LabB_PIDOverRobot/controller/PID Controller/I Gain'\r\n * '<S11>'  : 'LabB_PIDOverRobot/controller/PID Controller/Ideal P Gain'\r\n * '<S12>'  : 'LabB_PIDOverRobot/controller/PID Controller/Ideal P Gain Fdbk'\r\n * '<S13>'  : 'LabB_PIDOverRobot/controller/PID Controller/Integrator'\r\n * '<S14>'  : 'LabB_PIDOverRobot/controller/PID Controller/Integrator ICs'\r\n * '<S15>'  : 'LabB_PIDOverRobot/controller/PID Controller/N Copy'\r\n * '<S16>'  : 'LabB_PIDOverRobot/controller/PID Controller/N Gain'\r\n * '<S17>'  : 'LabB_PIDOverRobot/controller/PID Controller/P Copy'\r\n * '<S18>'  : 'LabB_PIDOverRobot/controller/PID Controller/Parallel P Gain'\r\n * '<S19>'  : 'LabB_PIDOverRobot/controller/PID Controller/Reset Signal'\r\n * '<S20>'  : 'LabB_PIDOverRobot/controller/PID Controller/Saturation'\r\n * '<S21>'  : 'LabB_PIDOverRobot/controller/PID Controller/Saturation Fdbk'\r\n * '<S22>'  : 'LabB_PIDOverRobot/controller/PID Controller/Sum'\r\n * '<S23>'  : 'LabB_PIDOverRobot/controller/PID Controller/Sum Fdbk'\r\n * '<S24>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tracking Mode'\r\n * '<S25>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tracking Mode Sum'\r\n * '<S26>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tsamp - Integral'\r\n * '<S27>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tsamp - Ngain'\r\n * '<S28>'  : 'LabB_PIDOverRobot/controller/PID Controller/postSat Signal'\r\n * '<S29>'  : 'LabB_PIDOverRobot/controller/PID Controller/preSat Signal'\r\n * '<S30>'  : 'LabB_PIDOverRobot/controller/PID Controller/Anti-windup/Back Calculation'\r\n * '<S31>'  : 'LabB_PIDOverRobot/controller/PID Controller/D Gain/Internal Parameters'\r\n * '<S32>'  : 'LabB_PIDOverRobot/controller/PID Controller/Filter/Disc. Forward Euler Filter'\r\n * '<S33>'  : 'LabB_PIDOverRobot/controller/PID Controller/Filter ICs/Internal IC - Filter'\r\n * '<S34>'  : 'LabB_PIDOverRobot/controller/PID Controller/I Gain/Internal Parameters'\r\n * '<S35>'  : 'LabB_PIDOverRobot/controller/PID Controller/Ideal P Gain/Passthrough'\r\n * '<S36>'  : 'LabB_PIDOverRobot/controller/PID Controller/Ideal P Gain Fdbk/Disabled'\r\n * '<S37>'  : 'LabB_PIDOverRobot/controller/PID Controller/Integrator/Discrete'\r\n * '<S38>'  : 'LabB_PIDOverRobot/controller/PID Controller/Integrator ICs/Internal IC'\r\n * '<S39>'  : 'LabB_PIDOverRobot/controller/PID Controller/N Copy/Disabled'\r\n * '<S40>'  : 'LabB_PIDOverRobot/controller/PID Controller/N Gain/Internal Parameters'\r\n * '<S41>'  : 'LabB_PIDOverRobot/controller/PID Controller/P Copy/Disabled'\r\n * '<S42>'  : 'LabB_PIDOverRobot/controller/PID Controller/Parallel P Gain/Internal Parameters'\r\n * '<S43>'  : 'LabB_PIDOverRobot/controller/PID Controller/Reset Signal/Disabled'\r\n * '<S44>'  : 'LabB_PIDOverRobot/controller/PID Controller/Saturation/Enabled'\r\n * '<S45>'  : 'LabB_PIDOverRobot/controller/PID Controller/Saturation Fdbk/Disabled'\r\n * '<S46>'  : 'LabB_PIDOverRobot/controller/PID Controller/Sum/Sum_PID'\r\n * '<S47>'  : 'LabB_PIDOverRobot/controller/PID Controller/Sum Fdbk/Disabled'\r\n * '<S48>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tracking Mode/Disabled'\r\n * '<S49>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tracking Mode Sum/Passthrough'\r\n * '<S50>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tsamp - Integral/TsSignalSpecification'\r\n * '<S51>'  : 'LabB_PIDOverRobot/controller/PID Controller/Tsamp - Ngain/Passthrough'\r\n * '<S52>'  : 'LabB_PIDOverRobot/controller/PID Controller/postSat Signal/Forward_Path'\r\n * '<S53>'  : 'LabB_PIDOverRobot/controller/PID Controller/preSat Signal/Forward_Path'\r\n * '<S54>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits'\r\n * '<S55>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits1'\r\n * '<S56>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits10'\r\n * '<S57>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits11'\r\n * '<S58>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits12'\r\n * '<S59>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits13'\r\n * '<S60>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits2'\r\n * '<S61>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits3'\r\n * '<S62>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits4'\r\n * '<S63>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits5'\r\n * '<S64>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits6'\r\n * '<S65>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits7'\r\n * '<S66>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits8'\r\n * '<S67>'  : 'LabB_PIDOverRobot/controller/send through the serial port/Extract Bits9'\r\n * '<S68>'  : 'LabB_PIDOverRobot/plant/M1V4 Left Motor Driver PWM6, D8 FST'\r\n * '<S69>'  : 'LabB_PIDOverRobot/plant/M1V4 Left Motor Driver PWM6, D8 FST/Compare To Zero'\r\n */\r\n#endif                                 /* RTW_HEADER_LabB_PIDOverRobot_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LabB_PIDOverRobot_private.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LabB_PIDOverRobot_private.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_LabB_PIDOverRobot_private_h_\r\n#define RTW_HEADER_LabB_PIDOverRobot_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"LabB_PIDOverRobot_types.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFU) ) || ( INT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFUL) ) || ( LONG_MAX != (0x7FFFFFFFL) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\nextern real_T rt_roundd_snf(real_T u);\r\n\r\n#endif                             /* RTW_HEADER_LabB_PIDOverRobot_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LabB_PIDOverRobot_types.h","type":"header","group":"model","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LabB_PIDOverRobot_types.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_LabB_PIDOverRobot_types_h_\r\n#define RTW_HEADER_LabB_PIDOverRobot_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"MW_SVD.h\"\r\n\r\n/* Custom Type definition for MATLABSystem: '<S68>/PWM' */\r\n#include \"MW_SVD.h\"\r\n#ifndef struct_tag_qbUFhX6Bp3RsgYGeqgZpEH\r\n#define struct_tag_qbUFhX6Bp3RsgYGeqgZpEH\r\n\r\nstruct tag_qbUFhX6Bp3RsgYGeqgZpEH\r\n{\r\n  int16_T __dummy;\r\n};\r\n\r\n#endif                                 /* struct_tag_qbUFhX6Bp3RsgYGeqgZpEH */\r\n\r\n#ifndef typedef_c_arduinodriver_ArduinoSerial_L\r\n#define typedef_c_arduinodriver_ArduinoSerial_L\r\n\r\ntypedef struct tag_qbUFhX6Bp3RsgYGeqgZpEH c_arduinodriver_ArduinoSerial_L;\r\n\r\n#endif                             /* typedef_c_arduinodriver_ArduinoSerial_L */\r\n\r\n#ifndef struct_tag_ghK8YWVQwtwpThnQHmUfd\r\n#define struct_tag_ghK8YWVQwtwpThnQHmUfd\r\n\r\nstruct tag_ghK8YWVQwtwpThnQHmUfd\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  real_T Protocol;\r\n  real_T port;\r\n  real_T dataSizeInBytes;\r\n  real_T dataType;\r\n  real_T sendModeEnum;\r\n  real_T sendFormatEnum;\r\n  c_arduinodriver_ArduinoSerial_L SerialDriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_ghK8YWVQwtwpThnQHmUfd */\r\n\r\n#ifndef typedef_codertarget_arduinobase_interna\r\n#define typedef_codertarget_arduinobase_interna\r\n\r\ntypedef struct tag_ghK8YWVQwtwpThnQHmUfd codertarget_arduinobase_interna;\r\n\r\n#endif                             /* typedef_codertarget_arduinobase_interna */\r\n\r\n#ifndef struct_tag_LZATNKaowXRlwzpKcQ6wRE\r\n#define struct_tag_LZATNKaowXRlwzpKcQ6wRE\r\n\r\nstruct tag_LZATNKaowXRlwzpKcQ6wRE\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n};\r\n\r\n#endif                                 /* struct_tag_LZATNKaowXRlwzpKcQ6wRE */\r\n\r\n#ifndef typedef_Encoder_arduino_LabB_PIDOverRob\r\n#define typedef_Encoder_arduino_LabB_PIDOverRob\r\n\r\ntypedef struct tag_LZATNKaowXRlwzpKcQ6wRE Encoder_arduino_LabB_PIDOverRob;\r\n\r\n#endif                             /* typedef_Encoder_arduino_LabB_PIDOverRob */\r\n\r\n#ifndef struct_tag_pYcsb98J6JO1Ji7woCUjNC\r\n#define struct_tag_pYcsb98J6JO1Ji7woCUjNC\r\n\r\nstruct tag_pYcsb98J6JO1Ji7woCUjNC\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n};\r\n\r\n#endif                                 /* struct_tag_pYcsb98J6JO1Ji7woCUjNC */\r\n\r\n#ifndef typedef_soMPU6050Gyro_LabB_PIDOverRobot\r\n#define typedef_soMPU6050Gyro_LabB_PIDOverRobot\r\n\r\ntypedef struct tag_pYcsb98J6JO1Ji7woCUjNC soMPU6050Gyro_LabB_PIDOverRobot;\r\n\r\n#endif                             /* typedef_soMPU6050Gyro_LabB_PIDOverRobot */\r\n\r\n#ifndef struct_tag_04b6x6tDldj9IrIH2gmbjG\r\n#define struct_tag_04b6x6tDldj9IrIH2gmbjG\r\n\r\nstruct tag_04b6x6tDldj9IrIH2gmbjG\r\n{\r\n  int16_T __dummy;\r\n};\r\n\r\n#endif                                 /* struct_tag_04b6x6tDldj9IrIH2gmbjG */\r\n\r\n#ifndef typedef_b_arduinodriver_ArduinoDigitalI\r\n#define typedef_b_arduinodriver_ArduinoDigitalI\r\n\r\ntypedef struct tag_04b6x6tDldj9IrIH2gmbjG b_arduinodriver_ArduinoDigitalI;\r\n\r\n#endif                             /* typedef_b_arduinodriver_ArduinoDigitalI */\r\n\r\n#ifndef struct_tag_AYWgtFscQm3mLUJYb3A20C\r\n#define struct_tag_AYWgtFscQm3mLUJYb3A20C\r\n\r\nstruct tag_AYWgtFscQm3mLUJYb3A20C\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  b_arduinodriver_ArduinoDigitalI DigitalIODriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_AYWgtFscQm3mLUJYb3A20C */\r\n\r\n#ifndef typedef_codertarget_arduinobase_blocks_\r\n#define typedef_codertarget_arduinobase_blocks_\r\n\r\ntypedef struct tag_AYWgtFscQm3mLUJYb3A20C codertarget_arduinobase_blocks_;\r\n\r\n#endif                             /* typedef_codertarget_arduinobase_blocks_ */\r\n\r\n#ifndef struct_tag_g1WX34VPn8QzVKQriB4HN\r\n#define struct_tag_g1WX34VPn8QzVKQriB4HN\r\n\r\nstruct tag_g1WX34VPn8QzVKQriB4HN\r\n{\r\n  MW_Handle_Type MW_PWM_HANDLE;\r\n};\r\n\r\n#endif                                 /* struct_tag_g1WX34VPn8QzVKQriB4HN */\r\n\r\n#ifndef typedef_g_matlabshared_ioclient_periphe\r\n#define typedef_g_matlabshared_ioclient_periphe\r\n\r\ntypedef struct tag_g1WX34VPn8QzVKQriB4HN g_matlabshared_ioclient_periphe;\r\n\r\n#endif                             /* typedef_g_matlabshared_ioclient_periphe */\r\n\r\n#ifndef struct_tag_4eDVzK5FiryyCjvjjvrZGB\r\n#define struct_tag_4eDVzK5FiryyCjvjjvrZGB\r\n\r\nstruct tag_4eDVzK5FiryyCjvjjvrZGB\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  g_matlabshared_ioclient_periphe PWMDriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_4eDVzK5FiryyCjvjjvrZGB */\r\n\r\n#ifndef typedef_codertarget_arduinobase_inter_n\r\n#define typedef_codertarget_arduinobase_inter_n\r\n\r\ntypedef struct tag_4eDVzK5FiryyCjvjjvrZGB codertarget_arduinobase_inter_n;\r\n\r\n#endif                             /* typedef_codertarget_arduinobase_inter_n */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct Parameters_LabB_PIDOverRobot_ Parameters_LabB_PIDOverRobot;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_LabB_PIDOverRobot RT_MODEL_LabB_PIDOverRobot;\r\n\r\n#endif                               /* RTW_HEADER_LabB_PIDOverRobot_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LabB_PIDOverRobot_data.c","type":"source","group":"data","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LabB_PIDOverRobot_data.c\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"LabB_PIDOverRobot.h\"\r\n\r\n/* Block parameters (default storage) */\r\nParameters_LabB_PIDOverRobot LabB_PIDOverRobot_P = {\r\n  /* Variable: fGyroBias\r\n   * Referenced by: '<S2>/gyro bias'\r\n   */\r\n  0.0F,\r\n\r\n  /* Variable: fWheelRadius\r\n   * Referenced by: '<S2>/convert to meters'\r\n   */\r\n  0.0216F,\r\n\r\n  /* Mask Parameter: PIDController_D\r\n   * Referenced by: '<S31>/Derivative Gain'\r\n   */\r\n  0.1302F,\r\n\r\n  /* Mask Parameter: PIDController_I\r\n   * Referenced by: '<S34>/Integral Gain'\r\n   */\r\n  390.43631F,\r\n\r\n  /* Mask Parameter: PIDController_InitialConditionF\r\n   * Referenced by: '<S32>/Filter'\r\n   */\r\n  0.0F,\r\n\r\n  /* Mask Parameter: PIDController_InitialConditio_n\r\n   * Referenced by: '<S37>/Integrator'\r\n   */\r\n  0.0F,\r\n\r\n  /* Mask Parameter: PIDController_Kb\r\n   * Referenced by: '<S30>/Kb'\r\n   */\r\n  1.0F,\r\n\r\n  /* Mask Parameter: PIDController_LowerSaturationLi\r\n   * Referenced by: '<S44>/Saturation'\r\n   */\r\n  -6.0F,\r\n\r\n  /* Mask Parameter: PIDController_N\r\n   * Referenced by: '<S40>/Filter Coefficient'\r\n   */\r\n  100.0F,\r\n\r\n  /* Mask Parameter: PIDController_P\r\n   * Referenced by: '<S42>/Proportional Gain'\r\n   */\r\n  69.6802F,\r\n\r\n  /* Mask Parameter: PIDController_UpperSaturationLi\r\n   * Referenced by: '<S44>/Saturation'\r\n   */\r\n  6.0F,\r\n\r\n  /* Mask Parameter: M1V4LeftMotorDriverPWM6D8FST_Vs\r\n   * Referenced by: '<S68>/Saturation -Vsupply to Vsupply'\r\n   */\r\n  9.0F,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S5>/Serial Transmit'\r\n   */\r\n  0.0,\r\n\r\n  /* Computed Parameter: Constant_Value\r\n   * Referenced by: '<S69>/Constant'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: DiscreteTimeIntegratorconvertfr\r\n   * Referenced by: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n   */\r\n  0.005F,\r\n\r\n  /* Computed Parameter: DiscreteTimeIntegratorconvert_o\r\n   * Referenced by: '<S2>/Discrete-Time  Integrator (convert from theta_b_dot to theta_b)'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Integrator_gainval\r\n   * Referenced by: '<S37>/Integrator'\r\n   */\r\n  0.005F,\r\n\r\n  /* Computed Parameter: Filter_gainval\r\n   * Referenced by: '<S32>/Filter'\r\n   */\r\n  0.005F,\r\n\r\n  /* Computed Parameter: converttoradians_Gain\r\n   * Referenced by: '<S2>/convert to  radians'\r\n   */\r\n  -0.00872664619F,\r\n\r\n  /* Computed Parameter: converttoradianssec_Gain\r\n   * Referenced by: '<S2>/convert to radians//sec'\r\n   */\r\n  -0.000133231239F,\r\n\r\n  /* Computed Parameter: SaturationVsupplytoVsupply_Lowe\r\n   * Referenced by: '<S68>/Saturation -Vsupply to Vsupply'\r\n   */\r\n  -9.0F,\r\n\r\n  /* Computed Parameter: conversiontodutycycleconverttou\r\n   * Referenced by: '<S68>/conversion to dutycycle (convert to uint8, overflow will provide reverse polairty magnitued)'\r\n   */\r\n  28.333334F,\r\n\r\n  /* Computed Parameter: Constant_Value_p\r\n   * Referenced by: '<S5>/Constant'\r\n   */\r\n  1U\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Atmel->AVR\r\n *   Number of bits:     char:   8    short:   16    int:  16\r\n *                       long:  32\r\n *                       native word size:   8\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'LabB_PIDOverRobot'.\r\n *\r\n * Model version                  : 1.560\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Thu Dec 28 12:34:54 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Atmel->AVR\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"LabB_PIDOverRobot.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ArduinoPinHandleMap.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"#include \"rtwtypes.h\"\n\n#define ANALOG_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n#define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \ntypedef uint8_T PeripheralHandleMapType;\nPeripheralHandleMapType analogPinHandleMap[(ANALOG_MODULES_MAX/8)+1] = {0};\nPeripheralHandleMapType PWMPinHandleMap[(PWM_MODULES_MAX/8)+1] = {0};\n\n#ifdef __cplusplus\n}\n#endif\n"},{"name":"I2Cdev.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\AppData\\Roaming\\MathWorks\\MATLAB Add-Ons\\Collections\\Rensselaer Arduino Support Package Library (RASPLib)\\RASPlib\\src","tag":"","groupDisplay":"Other files","code":"// I2Cdev library collection - Main I2C device class\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 6/9/2012 by Jeff Rowberg <jeff@rowberg.net>\n//\n// Changelog:\n//     2012-06-09 - fix major issue with reading > 32 bytes at a time with Arduino Wire\n//                - add compiler warnings when using outdated or IDE or limited I2Cdev implementation\n//     2011-11-01 - fix write*Bits mask calculation (thanks sasquatch @ Arduino forums)\n//     2011-10-03 - added automatic Arduino version detection for ease of use\n//     2011-10-02 - added Gene Knight's NBWire TwoWire class implementation with small modifications\n//     2011-08-31 - added support for Arduino 1.0 Wire library (methods are different from 0.x)\n//     2011-08-03 - added optional timeout parameter to read* methods to easily change from default\n//     2011-08-02 - added support for 16-bit registers\n//                - fixed incorrect Doxygen comments on some methods\n//                - added timeout value for read operations (thanks mem @ Arduino forums)\n//     2011-07-30 - changed read/write function structures to return success or byte counts\n//                - made all methods static for multi-device memory savings\n//     2011-07-28 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"I2Cdev.h\"\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #if ARDUINO < 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO == 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO > 100\n            /*\n            #warning Using current Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.0.1+ with I2CDEV_BUILTIN_FASTWIRE implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Timeout detection (some Wire requests block forever)\n            */\n        #endif\n    #endif\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n\n    #error The I2CDEV_BUILTIN_FASTWIRE implementation is known to be broken right now. Patience, Iago!\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #warning Using I2CDEV_BUILTIN_NBWIRE implementation may adversely affect interrupt detection.\n        #warning This I2Cdev implementation does not support:\n        #warning - Repeated starts conditions\n    #endif\n\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/topic,68210.30.html\n    TwoWire Wire;\n\n#endif\n\n\n/** Default constructor.\n */\nI2Cdev::I2Cdev() {\n}\n\n/** Read a single bit from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitNum Bit position to read (0-7)\n * @param data Container for single bit value\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t *data, uint16_t timeout) {\n    uint8_t b;\n    uint8_t count = readByte(devAddr, regAddr, &b, timeout);\n    *data = b & (1 << bitNum);\n    return count;\n}\n\n/** Read a single bit from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitNum Bit position to read (0-15)\n * @param data Container for single bit value\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t *data, uint16_t timeout) {\n    uint16_t b;\n    uint8_t count = readWord(devAddr, regAddr, &b, timeout);\n    *data = b & (1 << bitNum);\n    return count;\n}\n\n/** Read multiple bits from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitStart First bit position to read (0-7)\n * @param length Number of bits to read (not more than 8)\n * @param data Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05)\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data, uint16_t timeout) {\n    // 01101001 read byte\n    // 76543210 bit numbers\n    //    xxx   args: bitStart=4, length=3\n    //    010   masked\n    //   -> 010 shifted\n    uint8_t count, b;\n    if ((count = readByte(devAddr, regAddr, &b, timeout)) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        b &= mask;\n        b >>= (bitStart - length + 1);\n        *data = b;\n    }\n    return count;\n}\n\n/** Read multiple bits from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param bitStart First bit position to read (0-15)\n * @param length Number of bits to read (not more than 16)\n * @param data Container for right-aligned value (i.e. '101' read from any bitStart position will equal 0x05)\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (1 = success, 0 = failure, -1 = timeout)\n */\nint8_t I2Cdev::readBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t *data, uint16_t timeout) {\n    // 1101011001101001 read byte\n    // fedcba9876543210 bit numbers\n    //    xxx           args: bitStart=12, length=3\n    //    010           masked\n    //           -> 010 shifted\n    uint8_t count;\n    uint16_t w;\n    if ((count = readWord(devAddr, regAddr, &w, timeout)) != 0) {\n        uint16_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        w &= mask;\n        w >>= (bitStart - length + 1);\n        *data = w;\n    }\n    return count;\n}\n\n/** Read single byte from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param data Container for byte value read from device\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {\n    return readBytes(devAddr, regAddr, 1, data, timeout);\n}\n\n/** Read single word from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to read from\n * @param data Container for word value read from device\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Status of read operation (true = success)\n */\nint8_t I2Cdev::readWord(uint8_t devAddr, uint8_t regAddr, uint16_t *data, uint16_t timeout) {\n    return readWords(devAddr, regAddr, 1, data, timeout);\n}\n\n/** Read multiple bytes from an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register regAddr to read from\n * @param length Number of bytes to read\n * @param data Buffer to store read data in\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Number of bytes read (-1 indicates failure)\n */\nint8_t I2Cdev::readBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") reading \");\n        Serial.print(length, DEC);\n        Serial.print(\" bytes from 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n\n    int8_t count = 0;\n    uint32_t t1 = millis();\n\n    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE)\n\n        #if (ARDUINO < 100)\n            // Arduino v00xx (before v1.0), Wire library\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.send(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));\n\n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.receive();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(\" \");\n                    #endif\n                }\n\n                Wire.endTransmission();\n            }\n        #elif (ARDUINO == 100)\n            // Arduino v1.0.0, Wire library\n            // Adds standardized write() and read() stream methods instead of send() and receive()\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));\n        \n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.read();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(\" \");\n                    #endif\n                }\n        \n                Wire.endTransmission();\n            }\n        #elif (ARDUINO > 100)\n            // Arduino v1.0.1+, Wire library\n            // Adds official support for repeated start condition, yay!\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length; k += min(length, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)min(length - k, BUFFER_LENGTH));\n        \n                for (; Wire.available() && (timeout == 0 || millis() - t1 < timeout); count++) {\n                    data[count] = Wire.read();\n                    #ifdef I2CDEV_SERIAL_DEBUG\n                        Serial.print(data[count], HEX);\n                        if (count + 1 < length) Serial.print(\" \");\n                    #endif\n                }\n        \n                Wire.endTransmission();\n            }\n        #endif\n\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n        // Fastwire library (STILL UNDER DEVELOPMENT, NON-FUNCTIONAL!)\n\n        // no loop required for fastwire\n        uint8_t status = Fastwire::readBuf(devAddr, regAddr, data, length);\n        if (status == 0) {\n            count = length; // success\n        } else {\n            count = -1; // error\n        }\n\n    #endif\n\n    // check for timeout\n    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout\n\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\". Done (\");\n        Serial.print(count, DEC);\n        Serial.println(\" read).\");\n    #endif\n\n    return count;\n}\n\n/** Read multiple words from a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register regAddr to read from\n * @param length Number of words to read\n * @param data Buffer to store read data in\n * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)\n * @return Number of words read (0 indicates failure)\n */\nint8_t I2Cdev::readWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t *data, uint16_t timeout) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") reading \");\n        Serial.print(length, DEC);\n        Serial.print(\" words from 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n\n    int8_t count = 0;\n    uint32_t t1 = millis();\n\n    #if (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE)\n\n        #if (ARDUINO < 100)\n            // Arduino v00xx (before v1.0), Wire library\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.send(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n    \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.receive() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.receive();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(\" \");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n\n                Wire.endTransmission();\n            }\n        #elif (ARDUINO == 100)\n            // Arduino v1.0.0, Wire library\n            // Adds standardized write() and read() stream methods instead of send() and receive()\n    \n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n    \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.read() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.read();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(\" \");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n        \n                Wire.endTransmission();\n            }\n        #elif (ARDUINO > 100)\n            // Arduino v1.0.1+, Wire library\n            // Adds official support for repeated start condition, yay!\n\n            // I2C/TWI subsystem uses internal buffer that breaks with large data requests\n            // so if user requests more than BUFFER_LENGTH bytes, we have to do it in\n            // smaller chunks instead of all at once\n            for (uint8_t k = 0; k < length * 2; k += min(length * 2, BUFFER_LENGTH)) {\n                Wire.beginTransmission(devAddr);\n                Wire.write(regAddr);\n                Wire.endTransmission();\n                Wire.beginTransmission(devAddr);\n                Wire.requestFrom(devAddr, (uint8_t)(length * 2)); // length=words, this wants bytes\n        \n                bool msb = true; // starts with MSB, then LSB\n                for (; Wire.available() && count < length && (timeout == 0 || millis() - t1 < timeout);) {\n                    if (msb) {\n                        // first byte is bits 15-8 (MSb=15)\n                        data[count] = Wire.read() << 8;\n                    } else {\n                        // second byte is bits 7-0 (LSb=0)\n                        data[count] |= Wire.read();\n                        #ifdef I2CDEV_SERIAL_DEBUG\n                            Serial.print(data[count], HEX);\n                            if (count + 1 < length) Serial.print(\" \");\n                        #endif\n                        count++;\n                    }\n                    msb = !msb;\n                }\n        \n                Wire.endTransmission();\n            }\n        #endif\n\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n        // Fastwire library (STILL UNDER DEVELOPMENT, NON-FUNCTIONAL!)\n\n        // no loop required for fastwire\n        uint16_t intermediate[(uint8_t)length];\n        uint8_t status = Fastwire::readBuf(devAddr, regAddr, (uint8_t *)intermediate, (uint8_t)(length * 2));\n        if (status == 0) {\n            count = length; // success\n            for (uint8_t i = 0; i < length; i++) {\n                data[i] = (intermediate[2*i] << 8) | intermediate[2*i + 1];\n            }\n        } else {\n            count = -1; // error\n        }\n\n    #endif\n\n    if (timeout > 0 && millis() - t1 >= timeout && count < length) count = -1; // timeout\n\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\". Done (\");\n        Serial.print(count, DEC);\n        Serial.println(\" read).\");\n    #endif\n    \n    return count;\n}\n\n/** write a single bit in an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitNum Bit position to write (0-7)\n * @param value New bit value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {\n    uint8_t b;\n    readByte(devAddr, regAddr, &b);\n    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));\n    return writeByte(devAddr, regAddr, b);\n}\n\n/** write a single bit in a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitNum Bit position to write (0-15)\n * @param value New bit value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBitW(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint16_t data) {\n    uint16_t w;\n    readWord(devAddr, regAddr, &w);\n    w = (data != 0) ? (w | (1 << bitNum)) : (w & ~(1 << bitNum));\n    return writeWord(devAddr, regAddr, w);\n}\n\n/** Write multiple bits in an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitStart First bit position to write (0-7)\n * @param length Number of bits to write (not more than 8)\n * @param data Right-aligned value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {\n    //      010 value to write\n    // 76543210 bit numbers\n    //    xxx   args: bitStart=4, length=3\n    // 00011100 mask byte\n    // 10101111 original value (sample)\n    // 10100011 original & ~mask\n    // 10101011 masked | value\n    uint8_t b;\n    if (readByte(devAddr, regAddr, &b) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        data <<= (bitStart - length + 1); // shift data into correct position\n        data &= mask; // zero all non-important bits in data\n        b &= ~(mask); // zero all important bits in existing byte\n        b |= data; // combine data with existing byte\n        return writeByte(devAddr, regAddr, b);\n    } else {\n        return false;\n    }\n}\n\n/** Write multiple bits in a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register regAddr to write to\n * @param bitStart First bit position to write (0-15)\n * @param length Number of bits to write (not more than 16)\n * @param data Right-aligned value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBitsW(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t data) {\n    //              010 value to write\n    // fedcba9876543210 bit numbers\n    //    xxx           args: bitStart=12, length=3\n    // 0001110000000000 mask byte\n    // 1010111110010110 original value (sample)\n    // 1010001110010110 original & ~mask\n    // 1010101110010110 masked | value\n    uint16_t w;\n    if (readWord(devAddr, regAddr, &w) != 0) {\n        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);\n        data <<= (bitStart - length + 1); // shift data into correct position\n        data &= mask; // zero all non-important bits in data\n        w &= ~(mask); // zero all important bits in existing word\n        w |= data; // combine data with existing word\n        return writeWord(devAddr, regAddr, w);\n    } else {\n        return false;\n    }\n}\n\n/** Write single byte to an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register address to write to\n * @param data New byte value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {\n    return writeBytes(devAddr, regAddr, 1, &data);\n}\n\n/** Write single word to a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr Register address to write to\n * @param data New word value to write\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeWord(uint8_t devAddr, uint8_t regAddr, uint16_t data) {\n    return writeWords(devAddr, regAddr, 1, &data);\n}\n\n/** Write multiple bytes to an 8-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register address to write to\n * @param length Number of bytes to write\n * @param data Buffer to copy new data from\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t* data) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") writing \");\n        Serial.print(length, DEC);\n        Serial.print(\" bytes to 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n    uint8_t status = 0;\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.beginTransmission(devAddr);\n        Wire.send((uint8_t) regAddr); // send address\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        Wire.beginTransmission(devAddr);\n        Wire.write((uint8_t) regAddr); // send address\n    #endif\n    for (uint8_t i = 0; i < length; i++) {\n        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n            Wire.send((uint8_t) data[i]);\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n            Wire.write((uint8_t) data[i]);\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n            status = Fastwire::write(devAddr, regAddr, data[i]);\n            Serial.println(status);\n        #endif\n        #ifdef I2CDEV_SERIAL_DEBUG\n            Serial.print(data[i], HEX);\n            if (i + 1 < length) Serial.print(\" \");\n        #endif\n    }\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.endTransmission();\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        status = Wire.endTransmission();\n    #endif\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.println(\". Done.\");\n    #endif\n    return status == 0;\n}\n\n/** Write multiple words to a 16-bit device register.\n * @param devAddr I2C slave device address\n * @param regAddr First register address to write to\n * @param length Number of words to write\n * @param data Buffer to copy new data from\n * @return Status of operation (true = success)\n */\nbool I2Cdev::writeWords(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint16_t* data) {\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.print(\"I2C (0x\");\n        Serial.print(devAddr, HEX);\n        Serial.print(\") writing \");\n        Serial.print(length, DEC);\n        Serial.print(\" words to 0x\");\n        Serial.print(regAddr, HEX);\n        Serial.print(\"...\");\n    #endif\n    uint8_t status = 0;\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.beginTransmission(devAddr);\n        Wire.send(regAddr); // send address\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        Wire.beginTransmission(devAddr);\n        Wire.write(regAddr); // send address\n    #endif\n    for (uint8_t i = 0; i < length * 2; i++) {\n        #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n            Wire.send((uint8_t)(data[i++] >> 8)); // send MSB\n            Wire.send((uint8_t)data[i]);          // send LSB\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n            Wire.write((uint8_t)(data[i++] >> 8)); // send MSB\n            Wire.write((uint8_t)data[i]);          // send LSB\n        #elif (I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE)\n            status = Fastwire::write(devAddr, regAddr, (uint8_t)(data[i++] >> 8));\n            status = Fastwire::write(devAddr, regAddr + 1, (uint8_t)data[i]);\n        #endif\n        #ifdef I2CDEV_SERIAL_DEBUG\n            Serial.print(data[i], HEX);\n            if (i + 1 < length) Serial.print(\" \");\n        #endif\n    }\n    #if ((I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO < 100) || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE)\n        Wire.endTransmission();\n    #elif (I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE && ARDUINO >= 100)\n        status = Wire.endTransmission();\n    #endif\n    #ifdef I2CDEV_SERIAL_DEBUG\n        Serial.println(\". Done.\");\n    #endif\n    return status == 0;\n}\n\n/** Default timeout value for read operations.\n * Set this to 0 to disable timeout detection.\n */\nuint16_t I2Cdev::readTimeout = I2CDEV_DEFAULT_READ_TIMEOUT;\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n    /*\n    FastWire 0.2\n    This is a library to help faster programs to read I2C devices.\n    Copyright(C) 2011 Francesco Ferrara\n    occhiobello at gmail dot com\n    */\n\n    boolean Fastwire::waitInt() {\n        int l = 250;\n        while (!(TWCR & (1 << TWINT)) && l-- > 0);\n        return l > 0;\n    }\n\n    void Fastwire::setup(int khz, boolean pullup) {\n        TWCR = 0;\n        #if defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) || defined(__AVR_ATmega328P__)\n            // activate internal pull-ups for twi (PORTC bits 4 & 5)\n            // as per note from atmega8 manual pg167\n            if (pullup) PORTC |= ((1 << 4) | (1 << 5));\n            else        PORTC &= ~((1 << 4) | (1 << 5));\n        #elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644__)\n            // activate internal pull-ups for twi (PORTC bits 0 & 1)\n            if (pullup) PORTC |= ((1 << 0) | (1 << 1));\n            else        PORTC &= ~((1 << 0) | (1 << 1));\n        #else\n            // activate internal pull-ups for twi (PORTD bits 0 & 1)\n            // as per note from atmega128 manual pg204\n            if (pullup) PORTD |= ((1 << 0) | (1 << 1));\n            else        PORTD &= ~((1 << 0) | (1 << 1));\n        #endif\n\n        TWSR = 0; // no prescaler => prescaler = 1\n        TWBR = ((16000L / khz) - 16) / 2; // change the I2C clock rate\n        TWCR = 1 << TWEN; // enable twi module, no interrupt\n    }\n\n    byte Fastwire::write(byte device, byte address, byte value) {\n        byte twst, retry;\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 1;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 2;\n\n            TWDR = device & 0xFE; // send device address without read bit (1)\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 3;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MT_SLA_NACK && retry-- > 0);\n        if (twst != TW_MT_SLA_ACK) return 4;\n\n        TWDR = address; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 5;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 6;\n\n        TWDR = value; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 7;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 8;\n\n        return 0;\n    }\n\n    byte Fastwire::readBuf(byte device, byte address, byte *data, byte num) {\n        byte twst, retry;\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 16;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 17;\n\n            TWDR = device & 0xfe; // send device address to write\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 18;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MT_SLA_NACK && retry-- > 0);\n        if (twst != TW_MT_SLA_ACK) return 19;\n\n        TWDR = address; // send data to the previously addressed device\n        TWCR = (1 << TWINT) | (1 << TWEN);\n        if (!waitInt()) return 20;\n        twst = TWSR & 0xF8;\n        if (twst != TW_MT_DATA_ACK) return 21;\n\n        /***/\n\n        retry = 2;\n        do {\n            TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO) | (1 << TWSTA);\n            if (!waitInt()) return 22;\n            twst = TWSR & 0xF8;\n            if (twst != TW_START && twst != TW_REP_START) return 23;\n\n            TWDR = device | 0x01; // send device address with the read bit (1)\n            TWCR = (1 << TWINT) | (1 << TWEN);\n            if (!waitInt()) return 24;\n            twst = TWSR & 0xF8;\n        } while (twst == TW_MR_SLA_NACK && retry-- > 0);\n        if (twst != TW_MR_SLA_ACK) return 25;\n\n        for(uint8_t i = 0; i < num; i++) {\n            if (i == num - 1)\n               TWCR = (1 << TWINT) | (1 << TWEN);\n            else\n                TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);\n            if (!waitInt()) return 26;\n            twst = TWSR & 0xF8;\n            if (twst != TW_MR_DATA_ACK && twst != TW_MR_DATA_NACK) return twst;\n            data[i] = TWDR;\n        }\n\n        return 0;\n   }\n#endif\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/topic,68210.30.html\n\n    /*\n    call this version 1.0\n    \n    Offhand, the only funky part that I can think of is in nbrequestFrom, where the buffer\n    length and index are set *before* the data is actually read. The problem is that these\n    are variables local to the TwoWire object, and by the time we actually have read the\n    data, and know what the length actually is, we have no simple access to the object's \n    variables. The actual bytes read *is* given to the callback function, though.\n    \n    The ISR code for a slave receiver is commented out. I don't have that setup, and can't\n    verify it at this time. Save it for 2.0!\n    \n    The handling of the read and write processes here is much like in the demo sketch code: \n    the process is broken down into sequential functions, where each registers the next as a\n    callback, essentially.\n    \n    For example, for the Read process, twi_read00 just returns if TWI is not yet in a \n    ready state. When there's another interrupt, and the interface *is* ready, then it\n    sets up the read, starts it, and registers twi_read01 as the function to call after\n    the *next* interrupt. twi_read01, then, just returns if the interface is still in a\n    \"reading\" state. When the reading is done, it copies the information to the buffer,\n    cleans up, and calls the user-requested callback function with the actual number of \n    bytes read.\n    \n    The writing is similar.\n    \n    Questions, comments and problems can go to Gene@Telobot.com.\n    \n    Thumbs Up!\n    Gene Knight\n    \n    */\n    \n    uint8_t TwoWire::rxBuffer[NBWIRE_BUFFER_LENGTH];\n    uint8_t TwoWire::rxBufferIndex = 0;\n    uint8_t TwoWire::rxBufferLength = 0;\n    \n    uint8_t TwoWire::txAddress = 0;\n    uint8_t TwoWire::txBuffer[NBWIRE_BUFFER_LENGTH];\n    uint8_t TwoWire::txBufferIndex = 0;\n    uint8_t TwoWire::txBufferLength = 0;\n    \n    //uint8_t TwoWire::transmitting = 0;\n    void (*TwoWire::user_onRequest)(void);\n    void (*TwoWire::user_onReceive)(int);\n    \n    static volatile uint8_t twi_transmitting;\n    static volatile uint8_t twi_state;\n    static uint8_t twi_slarw;\n    static volatile uint8_t twi_error;\n    static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];\n    static volatile uint8_t twi_masterBufferIndex;\n    static uint8_t twi_masterBufferLength;\n    static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];\n    static volatile uint8_t twi_rxBufferIndex;\n    //static volatile uint8_t twi_Interrupt_Continue_Command;\n    static volatile uint8_t twi_Return_Value;\n    static volatile uint8_t twi_Done;\n    void (*twi_cbendTransmissionDone)(int);\n    void (*twi_cbreadFromDone)(int);\n    \n    void twi_init() {\n        // initialize state\n        twi_state = TWI_READY;\n\n        // activate internal pull-ups for twi\n        // as per note from atmega8 manual pg167\n        sbi(PORTC, 4);\n        sbi(PORTC, 5);\n\n        // initialize twi prescaler and bit rate\n        cbi(TWSR, TWPS0); // TWI Status Register - Prescaler bits\n        cbi(TWSR, TWPS1);\n\n        /* twi bit rate formula from atmega128 manual pg 204\n        SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n        note: TWBR should be 10 or higher for master mode\n        It is 72 for a 16mhz Wiring board with 100kHz TWI */\n\n        TWBR = ((CPU_FREQ / TWI_FREQ) - 16) / 2; // bitrate register\n        // enable twi module, acks, and twi interrupt\n\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);\n\n        /* TWEN - TWI Enable Bit\n        TWIE - TWI Interrupt Enable\n        TWEA - TWI Enable Acknowledge Bit\n        TWINT - TWI Interrupt Flag\n        TWSTA - TWI Start Condition\n        */\n    }\n    \n    typedef struct {\n        uint8_t address;\n        uint8_t* data;\n        uint8_t length;\n        uint8_t wait;\n        uint8_t i;\n    } twi_Write_Vars;\n\n    twi_Write_Vars *ptwv = 0;\n    static void (*fNextInterruptFunction)(void) = 0;\n    \n    void twi_Finish(byte bRetVal) {\n        if (ptwv) {\n            free(ptwv);\n            ptwv = 0;\n        }\n        twi_Done = 0xFF;\n        twi_Return_Value = bRetVal;\n        fNextInterruptFunction = 0;\n    }\n    \n    uint8_t twii_WaitForDone(uint16_t timeout) {\n        uint32_t endMillis = millis() + timeout;\n        while (!twi_Done && (timeout == 0 || millis() < endMillis)) continue;\n        return twi_Return_Value;\n    }\n    \n    void twii_SetState(uint8_t ucState) {\n        twi_state = ucState;\n    }\n\n    void twii_SetError(uint8_t ucError) {\n        twi_error = ucError ;\n    }\n\n    void twii_InitBuffer(uint8_t ucPos, uint8_t ucLength) {\n        twi_masterBufferIndex = 0;\n        twi_masterBufferLength = ucLength;\n    }\n\n    void twii_CopyToBuf(uint8_t* pData, uint8_t ucLength) {\n        uint8_t i;\n        for (i = 0; i < ucLength; ++i) {\n            twi_masterBuffer[i] = pData[i];\n        }\n    }\n\n    void twii_CopyFromBuf(uint8_t *pData, uint8_t ucLength) {\n        uint8_t i;\n        for (i = 0; i < ucLength; ++i) {\n            pData[i] = twi_masterBuffer[i];\n        }\n    }\n\n    void twii_SetSlaRW(uint8_t ucSlaRW) {\n        twi_slarw = ucSlaRW;\n    }\n\n    void twii_SetStart() {\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);\n    }\n\n    void twi_write01() {\n        if (TWI_MTX == twi_state) return; // blocking test\n        twi_transmitting = 0 ;\n        if (twi_error == 0xFF)\n            twi_Finish (0);    // success\n        else if (twi_error == TW_MT_SLA_NACK)\n            twi_Finish (2);    // error: address send, nack received\n        else if (twi_error == TW_MT_DATA_NACK)\n            twi_Finish (3);    // error: data send, nack received\n        else\n            twi_Finish (4);    // other twi error\n        if (twi_cbendTransmissionDone) return twi_cbendTransmissionDone(twi_Return_Value);\n        return;\n    }\n    \n    \n    void twi_write00() {\n        if (TWI_READY != twi_state) return; // blocking test\n        if (TWI_BUFFER_LENGTH < ptwv -> length) {\n            twi_Finish(1); // end write with error 1\n            return;\n        }\n        twi_Done = 0x00; // show as working\n        twii_SetState(TWI_MTX); // to transmitting\n        twii_SetError(0xFF); // to No Error\n        twii_InitBuffer(0, ptwv -> length); // pointer and length\n        twii_CopyToBuf(ptwv -> data, ptwv -> length); // get the data\n        twii_SetSlaRW((ptwv -> address << 1) | TW_WRITE); // write command\n        twii_SetStart(); // start the cycle\n        fNextInterruptFunction = twi_write01; // next routine\n        return twi_write01();\n    }\n    \n    void twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait) {\n        uint8_t i;\n        ptwv = (twi_Write_Vars *)malloc(sizeof(twi_Write_Vars));\n        ptwv -> address = address;\n        ptwv -> data = data;\n        ptwv -> length = length;\n        ptwv -> wait = wait;\n        fNextInterruptFunction = twi_write00;\n        return twi_write00();\n    }\n\n    void twi_read01() {\n        if (TWI_MRX == twi_state) return; // blocking test\n        if (twi_masterBufferIndex < ptwv -> length) ptwv -> length = twi_masterBufferIndex;\n        twii_CopyFromBuf(ptwv -> data, ptwv -> length);\n        twi_Finish(ptwv -> length);\n        if (twi_cbreadFromDone) return twi_cbreadFromDone(twi_Return_Value);\n        return;\n    }\n    \n    void twi_read00() {\n        if (TWI_READY != twi_state) return; // blocking test\n        if (TWI_BUFFER_LENGTH < ptwv -> length) twi_Finish(0); // error return\n        twi_Done = 0x00; // show as working\n        twii_SetState(TWI_MRX); // reading\n        twii_SetError(0xFF); // reset error\n        twii_InitBuffer(0, ptwv -> length - 1); // init to one less than length\n        twii_SetSlaRW((ptwv -> address << 1) | TW_READ); // read command\n        twii_SetStart(); // start cycle\n        fNextInterruptFunction = twi_read01;\n        return twi_read01();\n    }\n\n    void twi_readFrom(uint8_t address, uint8_t* data, uint8_t length) {\n        uint8_t i;\n\n        ptwv = (twi_Write_Vars *)malloc(sizeof(twi_Write_Vars));\n        ptwv -> address = address;\n        ptwv -> data = data;\n        ptwv -> length = length;\n        fNextInterruptFunction = twi_read00;\n        return twi_read00();\n    }\n\n    void twi_reply(uint8_t ack) {\n        // transmit master read ready signal, with or without ack\n        if (ack){\n            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);\n        } else {\n            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);\n        }\n    }\n    \n    void twi_stop(void) {\n        // send stop condition\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);\n    \n        // wait for stop condition to be exectued on bus\n        // TWINT is not set after a stop condition!\n        while (TWCR & _BV(TWSTO)) {\n            continue;\n        }\n    \n        // update twi state\n        twi_state = TWI_READY;\n    }\n\n    void twi_releaseBus(void) {\n        // release bus\n        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);\n    \n        // update twi state\n        twi_state = TWI_READY;\n    }\n    \n    SIGNAL(TWI_vect) {\n        switch (TW_STATUS) {\n            // All Master\n            case TW_START:     // sent start condition\n            case TW_REP_START: // sent repeated start condition\n                // copy device address and r/w bit to output register and ack\n                TWDR = twi_slarw;\n                twi_reply(1);\n                break;\n    \n            // Master Transmitter\n            case TW_MT_SLA_ACK:  // slave receiver acked address\n            case TW_MT_DATA_ACK: // slave receiver acked data\n                // if there is data to send, send it, otherwise stop\n                if (twi_masterBufferIndex < twi_masterBufferLength) {\n                    // copy data to output register and ack\n                    TWDR = twi_masterBuffer[twi_masterBufferIndex++];\n                    twi_reply(1);\n                } else {\n                    twi_stop();\n                }\n                break;\n\n            case TW_MT_SLA_NACK:  // address sent, nack received\n                twi_error = TW_MT_SLA_NACK;\n                twi_stop();\n                break;\n\n            case TW_MT_DATA_NACK: // data sent, nack received\n                twi_error = TW_MT_DATA_NACK;\n                twi_stop();\n                break;\n\n            case TW_MT_ARB_LOST: // lost bus arbitration\n                twi_error = TW_MT_ARB_LOST;\n                twi_releaseBus();\n                break;\n    \n            // Master Receiver\n            case TW_MR_DATA_ACK: // data received, ack sent\n                // put byte into buffer\n                twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n\n            case TW_MR_SLA_ACK:  // address sent, ack received\n                // ack if more bytes are expected, otherwise nack\n                if (twi_masterBufferIndex < twi_masterBufferLength) {\n                    twi_reply(1);\n                } else {\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_MR_DATA_NACK: // data received, nack sent\n                // put final byte into buffer\n                twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n\n            case TW_MR_SLA_NACK: // address sent, nack received\n                twi_stop();\n                break;\n\n        // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case\n\n        // Slave Receiver (NOT IMPLEMENTED YET)\n        /*\n            case TW_SR_SLA_ACK:   // addressed, returned ack\n            case TW_SR_GCALL_ACK: // addressed generally, returned ack\n            case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack\n            case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack\n                // enter slave receiver mode\n                twi_state = TWI_SRX;\n\n                // indicate that rx buffer can be overwritten and ack\n                twi_rxBufferIndex = 0;\n                twi_reply(1);\n                break;\n\n            case TW_SR_DATA_ACK:       // data received, returned ack\n            case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack\n                // if there is still room in the rx buffer\n                if (twi_rxBufferIndex < TWI_BUFFER_LENGTH) {\n                    // put byte in buffer and ack\n                    twi_rxBuffer[twi_rxBufferIndex++] = TWDR;\n                    twi_reply(1);\n                } else {\n                    // otherwise nack\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_SR_STOP: // stop or repeated start condition received\n                // put a null char after data if there's room\n                if (twi_rxBufferIndex < TWI_BUFFER_LENGTH) {\n                    twi_rxBuffer[twi_rxBufferIndex] = 0;\n                }\n\n                // sends ack and stops interface for clock stretching\n                twi_stop();\n\n                // callback to user defined callback\n                twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);\n\n                // since we submit rx buffer to \"wire\" library, we can reset it\n                twi_rxBufferIndex = 0;\n\n                // ack future responses and leave slave receiver state\n                twi_releaseBus();\n                break;\n\n            case TW_SR_DATA_NACK:       // data received, returned nack\n            case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack\n                // nack back at master\n                twi_reply(0);\n                break;\n\n            // Slave Transmitter\n            case TW_ST_SLA_ACK:          // addressed, returned ack\n            case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack\n                // enter slave transmitter mode\n                twi_state = TWI_STX;\n\n                // ready the tx buffer index for iteration\n                twi_txBufferIndex = 0;\n\n                // set tx buffer length to be zero, to verify if user changes it\n                twi_txBufferLength = 0;\n\n                // request for txBuffer to be filled and length to be set\n                // note: user must call twi_transmit(bytes, length) to do this\n                twi_onSlaveTransmit();\n\n                // if they didn't change buffer & length, initialize it\n                if (0 == twi_txBufferLength) {\n                    twi_txBufferLength = 1;\n                    twi_txBuffer[0] = 0x00;\n                }\n                \n                // transmit first byte from buffer, fall through\n\n            case TW_ST_DATA_ACK: // byte sent, ack returned\n                // copy data to output register\n                TWDR = twi_txBuffer[twi_txBufferIndex++];\n\n                // if there is more to send, ack, otherwise nack\n                if (twi_txBufferIndex < twi_txBufferLength) {\n                    twi_reply(1);\n                } else {\n                    twi_reply(0);\n                }\n                break;\n\n            case TW_ST_DATA_NACK: // received nack, we are done\n            case TW_ST_LAST_DATA: // received ack, but we are done already!\n                // ack future responses\n                twi_reply(1);\n                // leave slave receiver state\n                twi_state = TWI_READY;\n                break;\n            */\n\n            // all\n            case TW_NO_INFO:   // no state information\n                break;\n\n            case TW_BUS_ERROR: // bus error, illegal stop/start\n                twi_error = TW_BUS_ERROR;\n                twi_stop();\n                break;\n        }\n\n        if (fNextInterruptFunction) return fNextInterruptFunction();\n    }\n\n    TwoWire::TwoWire() { }\n    \n    void TwoWire::begin(void) {\n        rxBufferIndex = 0;\n        rxBufferLength = 0;\n    \n        txBufferIndex = 0;\n        txBufferLength = 0;\n\n        twi_init();\n    }\n    \n    void TwoWire::beginTransmission(uint8_t address) {\n        //beginTransmission((uint8_t)address);\n\n        // indicate that we are transmitting\n        twi_transmitting = 1;\n        \n        // set address of targeted slave\n        txAddress = address;\n        \n        // reset tx buffer iterator vars\n        txBufferIndex = 0;\n        txBufferLength = 0;\n    }\n    \n    uint8_t TwoWire::endTransmission(uint16_t timeout) {\n        // transmit buffer (blocking)\n        //int8_t ret =\n        twi_cbendTransmissionDone = NULL;\n        twi_writeTo(txAddress, txBuffer, txBufferLength, 1);\n        int8_t ret = twii_WaitForDone(timeout);\n\n        // reset tx buffer iterator vars\n        txBufferIndex = 0;\n        txBufferLength = 0;\n\n        // indicate that we are done transmitting\n        // twi_transmitting = 0;\n        return ret;\n    }\n\n    void TwoWire::nbendTransmission(void (*function)(int)) {\n        twi_cbendTransmissionDone = function;\n        twi_writeTo(txAddress, txBuffer, txBufferLength, 1);\n        return;\n    }\n    \n    void TwoWire::send(uint8_t data) {\n        if (twi_transmitting) {\n            // in master transmitter mode\n            // don't bother if buffer is full\n            if (txBufferLength >= NBWIRE_BUFFER_LENGTH) {\n                return;\n            }\n\n            // put byte in tx buffer\n            txBuffer[txBufferIndex] = data;\n            ++txBufferIndex;\n\n            // update amount in buffer\n            txBufferLength = txBufferIndex;\n        } else {\n            // in slave send mode\n            // reply to master\n            //twi_transmit(&data, 1);\n        }\n    }\n    \n    uint8_t TwoWire::receive(void) {\n        // default to returning null char\n        // for people using with char strings\n        uint8_t value = 0;\n      \n        // get each successive byte on each call\n        if (rxBufferIndex < rxBufferLength) {\n            value = rxBuffer[rxBufferIndex];\n            ++rxBufferIndex;\n        }\n    \n        return value;\n    }\n    \n    uint8_t TwoWire::requestFrom(uint8_t address, int quantity, uint16_t timeout) {\n        // clamp to buffer length\n        if (quantity > NBWIRE_BUFFER_LENGTH) {\n            quantity = NBWIRE_BUFFER_LENGTH;\n        }\n\n        // perform blocking read into buffer\n        twi_cbreadFromDone = NULL;\n        twi_readFrom(address, rxBuffer, quantity);\n        uint8_t read = twii_WaitForDone(timeout);\n\n        // set rx buffer iterator vars\n        rxBufferIndex = 0;\n        rxBufferLength = read;\n    \n        return read;\n    }\n    \n    void TwoWire::nbrequestFrom(uint8_t address, int quantity, void (*function)(int)) {\n        // clamp to buffer length\n        if (quantity > NBWIRE_BUFFER_LENGTH) {\n            quantity = NBWIRE_BUFFER_LENGTH;\n        }\n\n        // perform blocking read into buffer\n        twi_cbreadFromDone = function;\n        twi_readFrom(address, rxBuffer, quantity);\n        //uint8_t read = twii_WaitForDone();\n\n        // set rx buffer iterator vars\n        //rxBufferIndex = 0;\n        //rxBufferLength = read;\n\n        rxBufferIndex = 0;\n        rxBufferLength = quantity; // this is a hack\n\n        return; //read;\n    }\n\n    uint8_t TwoWire::available(void) {\n        return rxBufferLength - rxBufferIndex;\n    }\n\n#endif\n"},{"name":"MPU6050.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\AppData\\Roaming\\MathWorks\\MATLAB Add-Ons\\Collections\\Rensselaer Arduino Support Package Library (RASPLib)\\RASPlib\\src","tag":"","groupDisplay":"Other files","code":"// I2Cdev library collection - MPU6050 I2C device class\n// Based on InvenSense MPU-6050 register map document rev. 2.0, 5/19/2011 (RM-MPU-6000A-00)\n// 8/24/2011 by Jeff Rowberg <jeff@rowberg.net>\n// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib\n//\n// Changelog:\n//     ... - ongoing debug release\n\n// NOTE: THIS IS ONLY A PARIAL RELEASE. THIS DEVICE CLASS IS CURRENTLY UNDERGOING ACTIVE\n// DEVELOPMENT AND IS STILL MISSING SOME IMPORTANT FEATURES. PLEASE KEEP THIS IN MIND IF\n// YOU DECIDE TO USE THIS PARTICULAR CODE FOR ANYTHING.\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2012 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"MPU6050.h\"\n\n/** Default constructor, uses default I2C address.\n * @see MPU6050_DEFAULT_ADDRESS\n */\nMPU6050::MPU6050() {\n    devAddr = MPU6050_DEFAULT_ADDRESS;\n}\n\n/** Specific address constructor.\n * @param address I2C address\n * @see MPU6050_DEFAULT_ADDRESS\n * @see MPU6050_ADDRESS_AD0_LOW\n * @see MPU6050_ADDRESS_AD0_HIGH\n */\nMPU6050::MPU6050(uint8_t address) {\n    devAddr = address;\n}\n\n/** Power on and prepare for general usage.\n * This will activate the device and take it out of sleep mode (which must be done\n * after start-up). This function also sets both the accelerometer and the gyroscope\n * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec, and sets\n * the clock source to use the X Gyro for reference, which is slightly better than\n * the default internal clock source.\n */\nvoid MPU6050::initialize() {\n    setClockSource(MPU6050_CLOCK_PLL_XGYRO);\n    setFullScaleGyroRange(MPU6050_GYRO_FS_250); // JLH MPU6050_GYRO_FS_2000  MPU6050_GYRO_FS_250\n    setFullScaleAccelRange(MPU6050_ACCEL_FS_2);\n    setSleepEnabled(false); // thanks to Jack Elston for pointing this one out!\n}\n\n/** Verify the I2C connection.\n * Make sure the device is connected and responds as expected.\n * @return True if connection is valid, false otherwise\n */\nbool MPU6050::testConnection() {\n    return getDeviceID() == 0x34;\n}\n\n// AUX_VDDIO register (InvenSense demo code calls this RA_*G_OFFS_TC)\n\n/** Get the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @return I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nuint8_t MPU6050::getAuxVDDIOLevel() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, buffer);\n    return buffer[0];\n}\n/** Set the auxiliary I2C supply voltage level.\n * When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to\n * 0, the auxiliary I2C bus high logic level is VLOGIC. This does not apply to\n * the MPU-6000, which does not have a VLOGIC pin.\n * @param level I2C supply voltage level (0=VLOGIC, 1=VDD)\n */\nvoid MPU6050::setAuxVDDIOLevel(uint8_t level) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_PWR_MODE_BIT, level);\n}\n\n// SMPLRT_DIV register\n\n/** Get gyroscope output rate divider.\n * The sensor register output, FIFO output, DMP sampling, Motion detection, Zero\n * Motion detection, and Free Fall detection are all based on the Sample Rate.\n * The Sample Rate is generated by dividing the gyroscope output rate by\n * SMPLRT_DIV:\n *\n * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)\n *\n * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or\n * 7), and 1kHz when the DLPF is enabled (see Register 26).\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * For a diagram of the gyroscope and accelerometer signal paths, see Section 8\n * of the MPU-6000/MPU-6050 Product Specification document.\n *\n * @return Current sample rate\n * @see MPU6050_RA_SMPLRT_DIV\n */\nuint8_t MPU6050::getRate() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_SMPLRT_DIV, buffer);\n    return buffer[0];\n}\n/** Set gyroscope sample rate divider.\n * @param rate New sample rate divider\n * @see getRate()\n * @see MPU6050_RA_SMPLRT_DIV\n */\nvoid MPU6050::setRate(uint8_t rate) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_SMPLRT_DIV, rate);\n}\n\n// CONFIG register\n\n/** Get external FSYNC configuration.\n * Configures the external Frame Synchronization (FSYNC) pin sampling. An\n * external signal connected to the FSYNC pin can be sampled by configuring\n * EXT_SYNC_SET. Signal changes to the FSYNC pin are latched so that short\n * strobes may be captured. The latched FSYNC signal will be sampled at the\n * Sampling Rate, as defined in register 25. After sampling, the latch will\n * reset to the current FSYNC signal state.\n *\n * The sampled value will be reported in place of the least significant bit in\n * a sensor data register determined by the value of EXT_SYNC_SET according to\n * the following table.\n *\n * <pre>\n * EXT_SYNC_SET | FSYNC Bit Location\n * -------------+-------------------\n * 0            | Input disabled\n * 1            | TEMP_OUT_L[0]\n * 2            | GYRO_XOUT_L[0]\n * 3            | GYRO_YOUT_L[0]\n * 4            | GYRO_ZOUT_L[0]\n * 5            | ACCEL_XOUT_L[0]\n * 6            | ACCEL_YOUT_L[0]\n * 7            | ACCEL_ZOUT_L[0]\n * </pre>\n *\n * @return FSYNC configuration value\n */\nuint8_t MPU6050::getExternalFrameSync() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set external FSYNC configuration.\n * @see getExternalFrameSync()\n * @see MPU6050_RA_CONFIG\n * @param sync New FSYNC configuration value\n */\nvoid MPU6050::setExternalFrameSync(uint8_t sync) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, sync);\n}\n/** Get digital low-pass filter configuration.\n * The DLPF_CFG parameter sets the digital low pass filter configuration. It\n * also determines the internal sampling rate used by the device as shown in\n * the table below.\n *\n * Note: The accelerometer output rate is 1kHz. This means that for a Sample\n * Rate greater than 1kHz, the same accelerometer sample may be output to the\n * FIFO, DMP, and sensor registers more than once.\n *\n * <pre>\n *          |   ACCELEROMETER    |           GYROSCOPE\n * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate\n * ---------+-----------+--------+-----------+--------+-------------\n * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz\n * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz\n * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz\n * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz\n * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz\n * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz\n * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz\n * 7        |   -- Reserved --   |   -- Reserved --   | Reserved\n * </pre>\n *\n * @return DLFP configuration\n * @see MPU6050_RA_CONFIG\n * @see MPU6050_CFG_DLPF_CFG_BIT\n * @see MPU6050_CFG_DLPF_CFG_LENGTH\n */\nuint8_t MPU6050::getDLPFMode() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set digital low-pass filter configuration.\n * @param mode New DLFP configuration setting\n * @see getDLPFBandwidth()\n * @see MPU6050_DLPF_BW_256\n * @see MPU6050_RA_CONFIG\n * @see MPU6050_CFG_DLPF_CFG_BIT\n * @see MPU6050_CFG_DLPF_CFG_LENGTH\n */\nvoid MPU6050::setDLPFMode(uint8_t mode) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);\n}\n\n// GYRO_CONFIG register\n\n/** Get full-scale gyroscope range.\n * The FS_SEL parameter allows setting the full-scale range of the gyro sensors,\n * as described in the table below.\n *\n * <pre>\n * 0 = +/- 250 degrees/sec\n * 1 = +/- 500 degrees/sec\n * 2 = +/- 1000 degrees/sec\n * 3 = +/- 2000 degrees/sec\n * </pre>\n *\n * @return Current full-scale gyroscope range setting\n * @see MPU6050_GYRO_FS_250\n * @see MPU6050_RA_GYRO_CONFIG\n * @see MPU6050_GCONFIG_FS_SEL_BIT\n * @see MPU6050_GCONFIG_FS_SEL_LENGTH\n */\nuint8_t MPU6050::getFullScaleGyroRange() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set full-scale gyroscope range.\n * @param range New full-scale gyroscope range value\n * @see getFullScaleRange()\n * @see MPU6050_GYRO_FS_250\n * @see MPU6050_RA_GYRO_CONFIG\n * @see MPU6050_GCONFIG_FS_SEL_BIT\n * @see MPU6050_GCONFIG_FS_SEL_LENGTH\n */\nvoid MPU6050::setFullScaleGyroRange(uint8_t range) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);\n}\n\n// ACCEL_CONFIG register\n\n/** Get self-test enabled setting for accelerometer X axis.\n * @return Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nbool MPU6050::getAccelXSelfTest() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_XA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Get self-test enabled setting for accelerometer X axis.\n * @param enabled Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setAccelXSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_XA_ST_BIT, enabled);\n}\n/** Get self-test enabled value for accelerometer Y axis.\n * @return Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nbool MPU6050::getAccelYSelfTest() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_YA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Get self-test enabled value for accelerometer Y axis.\n * @param enabled Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setAccelYSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_YA_ST_BIT, enabled);\n}\n/** Get self-test enabled value for accelerometer Z axis.\n * @return Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nbool MPU6050::getAccelZSelfTest() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ZA_ST_BIT, buffer);\n    return buffer[0];\n}\n/** Set self-test enabled value for accelerometer Z axis.\n * @param enabled Self-test enabled value\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setAccelZSelfTest(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ZA_ST_BIT, enabled);\n}\n/** Get full-scale accelerometer range.\n * The FS_SEL parameter allows setting the full-scale range of the accelerometer\n * sensors, as described in the table below.\n *\n * <pre>\n * 0 = +/- 2g\n * 1 = +/- 4g\n * 2 = +/- 8g\n * 3 = +/- 16g\n * </pre>\n *\n * @return Current full-scale accelerometer range setting\n * @see MPU6050_ACCEL_FS_2\n * @see MPU6050_RA_ACCEL_CONFIG\n * @see MPU6050_ACONFIG_AFS_SEL_BIT\n * @see MPU6050_ACONFIG_AFS_SEL_LENGTH\n */\nuint8_t MPU6050::getFullScaleAccelRange() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set full-scale accelerometer range.\n * @param range New full-scale accelerometer range setting\n * @see getFullScaleAccelRange()\n */\nvoid MPU6050::setFullScaleAccelRange(uint8_t range) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, range);\n}\n/** Get the high-pass filter configuration.\n * The DHPF is a filter module in the path leading to motion detectors (Free\n * Fall, Motion threshold, and Zero Motion). The high pass filter output is not\n * available to the data registers (see Figure in Section 8 of the MPU-6000/\n * MPU-6050 Product Specification document).\n *\n * The high pass filter has three modes:\n *\n * <pre>\n *    Reset: The filter output settles to zero within one sample. This\n *           effectively disables the high pass filter. This mode may be toggled\n *           to quickly settle the filter.\n *\n *    On:    The high pass filter will pass signals above the cut off frequency.\n *\n *    Hold:  When triggered, the filter holds the present sample. The filter\n *           output will be the difference between the input sample and the held\n *           sample.\n * </pre>\n *\n * <pre>\n * ACCEL_HPF | Filter Mode | Cut-off Frequency\n * ----------+-------------+------------------\n * 0         | Reset       | None\n * 1         | On          | 5Hz\n * 2         | On          | 2.5Hz\n * 3         | On          | 1.25Hz\n * 4         | On          | 0.63Hz\n * 7         | Hold        | None\n * </pre>\n *\n * @return Current high-pass filter configuration\n * @see MPU6050_DHPF_RESET\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nuint8_t MPU6050::getDHPFMode() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU6050_ACONFIG_ACCEL_HPF_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set the high-pass filter configuration.\n * @param bandwidth New high-pass filter configuration\n * @see setDHPFMode()\n * @see MPU6050_DHPF_RESET\n * @see MPU6050_RA_ACCEL_CONFIG\n */\nvoid MPU6050::setDHPFMode(uint8_t bandwidth) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_ACCEL_HPF_BIT, MPU6050_ACONFIG_ACCEL_HPF_LENGTH, bandwidth);\n}\n\n// FF_THR register\n\n/** Get free-fall event acceleration threshold.\n * This register configures the detection threshold for Free Fall event\n * detection. The unit of FF_THR is 1LSB = 2mg. Free Fall is detected when the\n * absolute value of the accelerometer measurements for the three axes are each\n * less than the detection threshold. This condition increments the Free Fall\n * duration counter (Register 30). The Free Fall interrupt is triggered when the\n * Free Fall duration counter reaches the time specified in FF_DUR.\n *\n * For more details on the Free Fall detection interrupt, see Section 8.2 of the\n * MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and\n * 58 of this document.\n *\n * @return Current free-fall acceleration threshold value (LSB = 2mg)\n * @see MPU6050_RA_FF_THR\n */\nuint8_t MPU6050::getFreefallDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_FF_THR, buffer);\n    return buffer[0];\n}\n/** Get free-fall event acceleration threshold.\n * @param threshold New free-fall acceleration threshold value (LSB = 2mg)\n * @see getFreefallDetectionThreshold()\n * @see MPU6050_RA_FF_THR\n */\nvoid MPU6050::setFreefallDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_FF_THR, threshold);\n}\n\n// FF_DUR register\n\n/** Get free-fall event duration threshold.\n * This register configures the duration counter threshold for Free Fall event\n * detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit\n * of 1 LSB = 1 ms.\n *\n * The Free Fall duration counter increments while the absolute value of the\n * accelerometer measurements are each less than the detection threshold\n * (Register 29). The Free Fall interrupt is triggered when the Free Fall\n * duration counter reaches the time specified in this register.\n *\n * For more details on the Free Fall detection interrupt, see Section 8.2 of\n * the MPU-6000/MPU-6050 Product Specification document as well as Registers 56\n * and 58 of this document.\n *\n * @return Current free-fall duration threshold value (LSB = 1ms)\n * @see MPU6050_RA_FF_DUR\n */\nuint8_t MPU6050::getFreefallDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_FF_DUR, buffer);\n    return buffer[0];\n}\n/** Get free-fall event duration threshold.\n * @param duration New free-fall duration threshold value (LSB = 1ms)\n * @see getFreefallDetectionDuration()\n * @see MPU6050_RA_FF_DUR\n */\nvoid MPU6050::setFreefallDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_FF_DUR, duration);\n}\n\n// MOT_THR register\n\n/** Get motion detection event acceleration threshold.\n * This register configures the detection threshold for Motion interrupt\n * generation. The unit of MOT_THR is 1LSB = 2mg. Motion is detected when the\n * absolute value of any of the accelerometer measurements exceeds this Motion\n * detection threshold. This condition increments the Motion detection duration\n * counter (Register 32). The Motion detection interrupt is triggered when the\n * Motion Detection counter reaches the time count specified in MOT_DUR\n * (Register 32).\n *\n * The Motion interrupt will indicate the axis and polarity of detected motion\n * in MOT_DETECT_STATUS (Register 97).\n *\n * For more details on the Motion detection interrupt, see Section 8.3 of the\n * MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and\n * 58 of this document.\n *\n * @return Current motion detection acceleration threshold value (LSB = 2mg)\n * @see MPU6050_RA_MOT_THR\n */\nuint8_t MPU6050::getMotionDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_MOT_THR, buffer);\n    return buffer[0];\n}\n/** Set free-fall event acceleration threshold.\n * @param threshold New motion detection acceleration threshold value (LSB = 2mg)\n * @see getMotionDetectionThreshold()\n * @see MPU6050_RA_MOT_THR\n */\nvoid MPU6050::setMotionDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_THR, threshold);\n}\n\n// MOT_DUR register\n\n/** Get motion detection event duration threshold.\n * This register configures the duration counter threshold for Motion interrupt\n * generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit\n * of 1LSB = 1ms. The Motion detection duration counter increments when the\n * absolute value of any of the accelerometer measurements exceeds the Motion\n * detection threshold (Register 31). The Motion detection interrupt is\n * triggered when the Motion detection counter reaches the time count specified\n * in this register.\n *\n * For more details on the Motion detection interrupt, see Section 8.3 of the\n * MPU-6000/MPU-6050 Product Specification document.\n *\n * @return Current motion detection duration threshold value (LSB = 1ms)\n * @see MPU6050_RA_MOT_DUR\n */\nuint8_t MPU6050::getMotionDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_MOT_DUR, buffer);\n    return buffer[0];\n}\n/** Set motion detection event duration threshold.\n * @param duration New motion detection duration threshold value (LSB = 1ms)\n * @see getMotionDetectionDuration()\n * @see MPU6050_RA_MOT_DUR\n */\nvoid MPU6050::setMotionDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MOT_DUR, duration);\n}\n\n// ZRMOT_THR register\n\n/** Get zero motion detection event acceleration threshold.\n * This register configures the detection threshold for Zero Motion interrupt\n * generation. The unit of ZRMOT_THR is 1LSB = 2mg. Zero Motion is detected when\n * the absolute value of the accelerometer measurements for the 3 axes are each\n * less than the detection threshold. This condition increments the Zero Motion\n * duration counter (Register 34). The Zero Motion interrupt is triggered when\n * the Zero Motion duration counter reaches the time count specified in\n * ZRMOT_DUR (Register 34).\n *\n * Unlike Free Fall or Motion detection, Zero Motion detection triggers an\n * interrupt both when Zero Motion is first detected and when Zero Motion is no\n * longer detected.\n *\n * When a zero motion event is detected, a Zero Motion Status will be indicated\n * in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion\n * condition is detected, the status bit is set to 1. When a zero-motion-to-\n * motion condition is detected, the status bit is set to 0.\n *\n * For more details on the Zero Motion detection interrupt, see Section 8.4 of\n * the MPU-6000/MPU-6050 Product Specification document as well as Registers 56\n * and 58 of this document.\n *\n * @return Current zero motion detection acceleration threshold value (LSB = 2mg)\n * @see MPU6050_RA_ZRMOT_THR\n */\nuint8_t MPU6050::getZeroMotionDetectionThreshold() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_ZRMOT_THR, buffer);\n    return buffer[0];\n}\n/** Set zero motion detection event acceleration threshold.\n * @param threshold New zero motion detection acceleration threshold value (LSB = 2mg)\n * @see getZeroMotionDetectionThreshold()\n * @see MPU6050_RA_ZRMOT_THR\n */\nvoid MPU6050::setZeroMotionDetectionThreshold(uint8_t threshold) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_THR, threshold);\n}\n\n// ZRMOT_DUR register\n\n/** Get zero motion detection event duration threshold.\n * This register configures the duration counter threshold for Zero Motion\n * interrupt generation. The duration counter ticks at 16 Hz, therefore\n * ZRMOT_DUR has a unit of 1 LSB = 64 ms. The Zero Motion duration counter\n * increments while the absolute value of the accelerometer measurements are\n * each less than the detection threshold (Register 33). The Zero Motion\n * interrupt is triggered when the Zero Motion duration counter reaches the time\n * count specified in this register.\n *\n * For more details on the Zero Motion detection interrupt, see Section 8.4 of\n * the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56\n * and 58 of this document.\n *\n * @return Current zero motion detection duration threshold value (LSB = 64ms)\n * @see MPU6050_RA_ZRMOT_DUR\n */\nuint8_t MPU6050::getZeroMotionDetectionDuration() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_ZRMOT_DUR, buffer);\n    return buffer[0];\n}\n/** Set zero motion detection event duration threshold.\n * @param duration New zero motion detection duration threshold value (LSB = 1ms)\n * @see getZeroMotionDetectionDuration()\n * @see MPU6050_RA_ZRMOT_DUR\n */\nvoid MPU6050::setZeroMotionDetectionDuration(uint8_t duration) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_ZRMOT_DUR, duration);\n}\n\n// FIFO_EN register\n\n/** Get temperature FIFO enabled value.\n * When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and\n * 66) to be written into the FIFO buffer.\n * @return Current temperature FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getTempFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set temperature FIFO enabled value.\n * @param enabled New temperature FIFO enabled value\n * @see getTempFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setTempFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_TEMP_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope X-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and\n * 68) to be written into the FIFO buffer.\n * @return Current gyroscope X-axis FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getXGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope X-axis FIFO enabled value.\n * @param enabled New gyroscope X-axis FIFO enabled value\n * @see getXGyroFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setXGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_XG_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope Y-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and\n * 70) to be written into the FIFO buffer.\n * @return Current gyroscope Y-axis FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getYGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope Y-axis FIFO enabled value.\n * @param enabled New gyroscope Y-axis FIFO enabled value\n * @see getYGyroFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setYGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_YG_FIFO_EN_BIT, enabled);\n}\n/** Get gyroscope Z-axis FIFO enabled value.\n * When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and\n * 72) to be written into the FIFO buffer.\n * @return Current gyroscope Z-axis FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getZGyroFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set gyroscope Z-axis FIFO enabled value.\n * @param enabled New gyroscope Z-axis FIFO enabled value\n * @see getZGyroFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setZGyroFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ZG_FIFO_EN_BIT, enabled);\n}\n/** Get accelerometer FIFO enabled value.\n * When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H,\n * ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be\n * written into the FIFO buffer.\n * @return Current accelerometer FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getAccelFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set accelerometer FIFO enabled value.\n * @param enabled New accelerometer FIFO enabled value\n * @see getAccelFIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setAccelFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_ACCEL_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 2 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 2 to be written into the FIFO buffer.\n * @return Current Slave 2 FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getSlave2FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV2_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 2 FIFO enabled value.\n * @param enabled New Slave 2 FIFO enabled value\n * @see getSlave2FIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setSlave2FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV2_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 1 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 1 to be written into the FIFO buffer.\n * @return Current Slave 1 FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getSlave1FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV1_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 1 FIFO enabled value.\n * @param enabled New Slave 1 FIFO enabled value\n * @see getSlave1FIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setSlave1FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV1_FIFO_EN_BIT, enabled);\n}\n/** Get Slave 0 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 0 to be written into the FIFO buffer.\n * @return Current Slave 0 FIFO enabled value\n * @see MPU6050_RA_FIFO_EN\n */\nbool MPU6050::getSlave0FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV0_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 0 FIFO enabled value.\n * @param enabled New Slave 0 FIFO enabled value\n * @see getSlave0FIFOEnabled()\n * @see MPU6050_RA_FIFO_EN\n */\nvoid MPU6050::setSlave0FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_FIFO_EN, MPU6050_SLV0_FIFO_EN_BIT, enabled);\n}\n\n// I2C_MST_CTRL register\n\n/** Get multi-master enabled value.\n * Multi-master capability allows multiple I2C masters to operate on the same\n * bus. In circuits where multi-master capability is required, set MULT_MST_EN\n * to 1. This will increase current drawn by approximately 30uA.\n *\n * In circuits where multi-master capability is required, the state of the I2C\n * bus must always be monitored by each separate I2C Master. Before an I2C\n * Master can assume arbitration of the bus, it must first confirm that no other\n * I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the\n * MPU-60X0's bus arbitration detection logic is turned on, enabling it to\n * detect when the bus is available.\n *\n * @return Current multi-master enabled value\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nbool MPU6050::getMultiMasterEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_MULT_MST_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set multi-master enabled value.\n * @param enabled New multi-master enabled value\n * @see getMultiMasterEnabled()\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setMultiMasterEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_MULT_MST_EN_BIT, enabled);\n}\n/** Get wait-for-external-sensor-data enabled value.\n * When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be\n * delayed until External Sensor data from the Slave Devices are loaded into the\n * EXT_SENS_DATA registers. This is used to ensure that both the internal sensor\n * data (i.e. from gyro and accel) and external sensor data have been loaded to\n * their respective data registers (i.e. the data is synced) when the Data Ready\n * interrupt is triggered.\n *\n * @return Current wait-for-external-sensor-data enabled value\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nbool MPU6050::getWaitForExternalSensorEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_WAIT_FOR_ES_BIT, buffer);\n    return buffer[0];\n}\n/** Set wait-for-external-sensor-data enabled value.\n * @param enabled New wait-for-external-sensor-data enabled value\n * @see getWaitForExternalSensorEnabled()\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setWaitForExternalSensorEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_WAIT_FOR_ES_BIT, enabled);\n}\n/** Get Slave 3 FIFO enabled value.\n * When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96)\n * associated with Slave 3 to be written into the FIFO buffer.\n * @return Current Slave 3 FIFO enabled value\n * @see MPU6050_RA_MST_CTRL\n */\nbool MPU6050::getSlave3FIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_SLV_3_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set Slave 3 FIFO enabled value.\n * @param enabled New Slave 3 FIFO enabled value\n * @see getSlave3FIFOEnabled()\n * @see MPU6050_RA_MST_CTRL\n */\nvoid MPU6050::setSlave3FIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_SLV_3_FIFO_EN_BIT, enabled);\n}\n/** Get slave read/write transition enabled value.\n * The I2C_MST_P_NSR bit configures the I2C Master's transition from one slave\n * read to the next slave read. If the bit equals 0, there will be a restart\n * between reads. If the bit equals 1, there will be a stop followed by a start\n * of the following read. When a write transaction follows a read transaction,\n * the stop followed by a start of the successive write will be always used.\n *\n * @return Current slave read/write transition enabled value\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nbool MPU6050::getSlaveReadWriteTransitionEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_P_NSR_BIT, buffer);\n    return buffer[0];\n}\n/** Set slave read/write transition enabled value.\n * @param enabled New slave read/write transition enabled value\n * @see getSlaveReadWriteTransitionEnabled()\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setSlaveReadWriteTransitionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_P_NSR_BIT, enabled);\n}\n/** Get I2C master clock speed.\n * I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the\n * MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to\n * the following table:\n *\n * <pre>\n * I2C_MST_CLK | I2C Master Clock Speed | 8MHz Clock Divider\n * ------------+------------------------+-------------------\n * 0           | 348kHz                 | 23\n * 1           | 333kHz                 | 24\n * 2           | 320kHz                 | 25\n * 3           | 308kHz                 | 26\n * 4           | 296kHz                 | 27\n * 5           | 286kHz                 | 28\n * 6           | 276kHz                 | 29\n * 7           | 267kHz                 | 30\n * 8           | 258kHz                 | 31\n * 9           | 500kHz                 | 16\n * 10          | 471kHz                 | 17\n * 11          | 444kHz                 | 18\n * 12          | 421kHz                 | 19\n * 13          | 400kHz                 | 20\n * 14          | 381kHz                 | 21\n * 15          | 364kHz                 | 22\n * </pre>\n *\n * @return Current I2C master clock speed\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nuint8_t MPU6050::getMasterClockSpeed() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C_MST_CLK_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set I2C master clock speed.\n * @reparam speed Current I2C master clock speed\n * @see MPU6050_RA_I2C_MST_CTRL\n */\nvoid MPU6050::setMasterClockSpeed(uint8_t speed) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_MST_CTRL, MPU6050_I2C_MST_CLK_BIT, MPU6050_I2C_MST_CLK_LENGTH, speed);\n}\n\n// I2C_SLV* registers (Slave 0-3)\n\n/** Get the I2C address of the specified slave (0-3).\n * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read\n * operation, and if it is cleared, then it's a write operation. The remaining\n * bits (6-0) are the 7-bit device address of the slave device.\n *\n * In read mode, the result of the read is placed in the lowest available \n * EXT_SENS_DATA register. For further information regarding the allocation of\n * read results, please refer to the EXT_SENS_DATA register description\n * (Registers 73 - 96).\n *\n * The MPU-6050 supports a total of five slaves, but Slave 4 has unique\n * characteristics, and so it has its own functions (getSlave4* and setSlave4*).\n *\n * I2C data transactions are performed at the Sample Rate, as defined in\n * Register 25. The user is responsible for ensuring that I2C data transactions\n * to and from each enabled Slave can be completed within a single period of the\n * Sample Rate.\n *\n * The I2C slave access rate can be reduced relative to the Sample Rate. This\n * reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a\n * slave's access rate is reduced relative to the Sample Rate is determined by\n * I2C_MST_DELAY_CTRL (Register 103).\n *\n * The processing order for the slaves is fixed. The sequence followed for\n * processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a\n * particular Slave is disabled it will be skipped.\n *\n * Each slave can either be accessed at the sample rate or at a reduced sample\n * rate. In a case where some slaves are accessed at the Sample Rate and some\n * slaves are accessed at the reduced rate, the sequence of accessing the slaves\n * (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will\n * be skipped if their access rate dictates that they should not be accessed\n * during that particular cycle. For further information regarding the reduced\n * access rate, please refer to Register 52. Whether a slave is accessed at the\n * Sample Rate or at the reduced rate is determined by the Delay Enable bits in\n * Register 103.\n *\n * @param num Slave number (0-3)\n * @return Current address for specified slave\n * @see MPU6050_RA_I2C_SLV0_ADDR\n */\nuint8_t MPU6050::getSlaveAddress(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, buffer);\n    return buffer[0];\n}\n/** Set the I2C address of the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param address New address for specified slave\n * @see getSlaveAddress()\n * @see MPU6050_RA_I2C_SLV0_ADDR\n */\nvoid MPU6050::setSlaveAddress(uint8_t num, uint8_t address) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, address);\n}\n/** Get the active internal register for the specified slave (0-3).\n * Read/write operations for this slave will be done to whatever internal\n * register address is stored in this MPU register.\n *\n * The MPU-6050 supports a total of five slaves, but Slave 4 has unique\n * characteristics, and so it has its own functions.\n *\n * @param num Slave number (0-3)\n * @return Current active register for specified slave\n * @see MPU6050_RA_I2C_SLV0_REG\n */\nuint8_t MPU6050::getSlaveRegister(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV0_REG + num*3, buffer);\n    return buffer[0];\n}\n/** Set the active internal register for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param reg New active register for specified slave\n * @see getSlaveRegister()\n * @see MPU6050_RA_I2C_SLV0_REG\n */\nvoid MPU6050::setSlaveRegister(uint8_t num, uint8_t reg) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_REG + num*3, reg);\n}\n/** Get the enabled value for the specified slave (0-3).\n * When set to 1, this bit enables Slave 0 for data transfer operations. When\n * cleared to 0, this bit disables Slave 0 from data transfer operations.\n * @param num Slave number (0-3)\n * @return Current enabled value for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveEnabled(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New enabled value for specified slave\n * @see getSlaveEnabled()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveEnabled(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_EN_BIT, enabled);\n}\n/** Get word pair byte-swapping enabled for the specified slave (0-3).\n * When set to 1, this bit enables byte swapping. When byte swapping is enabled,\n * the high and low bytes of a word pair are swapped. Please refer to\n * I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0,\n * bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA\n * registers in the order they were transferred.\n *\n * @param num Slave number (0-3)\n * @return Current word pair byte-swapping enabled value for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveWordByteSwap(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_BYTE_SW_BIT, buffer);\n    return buffer[0];\n}\n/** Set word pair byte-swapping enabled for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New word pair byte-swapping enabled value for specified slave\n * @see getSlaveWordByteSwap()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveWordByteSwap(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_BYTE_SW_BIT, enabled);\n}\n/** Get write mode for the specified slave (0-3).\n * When set to 1, the transaction will read or write data only. When cleared to\n * 0, the transaction will write a register address prior to reading or writing\n * data. This should equal 0 when specifying the register address within the\n * Slave device to/from which the ensuing data transaction will take place.\n *\n * @param num Slave number (0-3)\n * @return Current write mode for specified slave (0 = register address + data, 1 = data only)\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveWriteMode(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_REG_DIS_BIT, buffer);\n    return buffer[0];\n}\n/** Set write mode for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param mode New write mode for specified slave (0 = register address + data, 1 = data only)\n * @see getSlaveWriteMode()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveWriteMode(uint8_t num, bool mode) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_REG_DIS_BIT, mode);\n}\n/** Get word pair grouping order offset for the specified slave (0-3).\n * This sets specifies the grouping order of word pairs received from registers.\n * When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even,\n * then odd register addresses) are paired to form a word. When set to 1, bytes\n * from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even\n * register addresses) are paired to form a word.\n *\n * @param num Slave number (0-3)\n * @return Current word pair grouping order offset for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nbool MPU6050::getSlaveWordGroupOffset(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_GRP_BIT, buffer);\n    return buffer[0];\n}\n/** Set word pair grouping order offset for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param enabled New word pair grouping order offset for specified slave\n * @see getSlaveWordGroupOffset()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveWordGroupOffset(uint8_t num, bool enabled) {\n    if (num > 3) return;\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_GRP_BIT, enabled);\n}\n/** Get number of bytes to read for the specified slave (0-3).\n * Specifies the number of bytes transferred to and from Slave 0. Clearing this\n * bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN.\n * @param num Slave number (0-3)\n * @return Number of bytes to read for specified slave\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nuint8_t MPU6050::getSlaveDataLength(uint8_t num) {\n    if (num > 3) return 0;\n    I2Cdev::readBits(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C_SLV_LEN_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set number of bytes to read for the specified slave (0-3).\n * @param num Slave number (0-3)\n * @param length Number of bytes to read for specified slave\n * @see getSlaveDataLength()\n * @see MPU6050_RA_I2C_SLV0_CTRL\n */\nvoid MPU6050::setSlaveDataLength(uint8_t num, uint8_t length) {\n    if (num > 3) return;\n    I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_SLV0_CTRL + num*3, MPU6050_I2C_SLV_LEN_BIT, MPU6050_I2C_SLV_LEN_LENGTH, length);\n}\n\n// I2C_SLV* registers (Slave 4)\n\n/** Get the I2C address of Slave 4.\n * Note that Bit 7 (MSB) controls read/write mode. If Bit 7 is set, it's a read\n * operation, and if it is cleared, then it's a write operation. The remaining\n * bits (6-0) are the 7-bit device address of the slave device.\n *\n * @return Current address for Slave 4\n * @see getSlaveAddress()\n * @see MPU6050_RA_I2C_SLV4_ADDR\n */\nuint8_t MPU6050::getSlave4Address() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_ADDR, buffer);\n    return buffer[0];\n}\n/** Set the I2C address of Slave 4.\n * @param address New address for Slave 4\n * @see getSlave4Address()\n * @see MPU6050_RA_I2C_SLV4_ADDR\n */\nvoid MPU6050::setSlave4Address(uint8_t address) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_ADDR, address);\n}\n/** Get the active internal register for the Slave 4.\n * Read/write operations for this slave will be done to whatever internal\n * register address is stored in this MPU register.\n *\n * @return Current active register for Slave 4\n * @see MPU6050_RA_I2C_SLV4_REG\n */\nuint8_t MPU6050::getSlave4Register() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_REG, buffer);\n    return buffer[0];\n}\n/** Set the active internal register for Slave 4.\n * @param reg New active register for Slave 4\n * @see getSlave4Register()\n * @see MPU6050_RA_I2C_SLV4_REG\n */\nvoid MPU6050::setSlave4Register(uint8_t reg) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_REG, reg);\n}\n/** Set new byte to write to Slave 4.\n * This register stores the data to be written into the Slave 4. If I2C_SLV4_RW\n * is set 1 (set to read), this register has no effect.\n * @param data New byte to write to Slave 4\n * @see MPU6050_RA_I2C_SLV4_DO\n */\nvoid MPU6050::setSlave4OutputByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV4_DO, data);\n}\n/** Get the enabled value for the Slave 4.\n * When set to 1, this bit enables Slave 4 for data transfer operations. When\n * cleared to 0, this bit disables Slave 4 from data transfer operations.\n * @return Current enabled value for Slave 4\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nbool MPU6050::getSlave4Enabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for Slave 4.\n * @param enabled New enabled value for Slave 4\n * @see getSlave4Enabled()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4Enabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_EN_BIT, enabled);\n}\n/** Get the enabled value for Slave 4 transaction interrupts.\n * When set to 1, this bit enables the generation of an interrupt signal upon\n * completion of a Slave 4 transaction. When cleared to 0, this bit disables the\n * generation of an interrupt signal upon completion of a Slave 4 transaction.\n * The interrupt status can be observed in Register 54.\n *\n * @return Current enabled value for Slave 4 transaction interrupts.\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nbool MPU6050::getSlave4InterruptEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set the enabled value for Slave 4 transaction interrupts.\n * @param enabled New enabled value for Slave 4 transaction interrupts.\n * @see getSlave4InterruptEnabled()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4InterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_INT_EN_BIT, enabled);\n}\n/** Get write mode for Slave 4.\n * When set to 1, the transaction will read or write data only. When cleared to\n * 0, the transaction will write a register address prior to reading or writing\n * data. This should equal 0 when specifying the register address within the\n * Slave device to/from which the ensuing data transaction will take place.\n *\n * @return Current write mode for Slave 4 (0 = register address + data, 1 = data only)\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nbool MPU6050::getSlave4WriteMode() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_REG_DIS_BIT, buffer);\n    return buffer[0];\n}\n/** Set write mode for the Slave 4.\n * @param mode New write mode for Slave 4 (0 = register address + data, 1 = data only)\n * @see getSlave4WriteMode()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4WriteMode(bool mode) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_REG_DIS_BIT, mode);\n}\n/** Get Slave 4 master delay value.\n * This configures the reduced access rate of I2C slaves relative to the Sample\n * Rate. When a slave's access rate is decreased relative to the Sample Rate,\n * the slave is accessed every:\n *\n *     1 / (1 + I2C_MST_DLY) samples\n *\n * This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and\n * DLPF_CFG (register 26). Whether a slave's access rate is reduced relative to\n * the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103). For\n * further information regarding the Sample Rate, please refer to register 25.\n *\n * @return Current Slave 4 master delay value\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nuint8_t MPU6050::getSlave4MasterDelay() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_MST_DLY_BIT, MPU6050_I2C_SLV4_MST_DLY_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Slave 4 master delay value.\n * @param delay New Slave 4 master delay value\n * @see getSlave4MasterDelay()\n * @see MPU6050_RA_I2C_SLV4_CTRL\n */\nvoid MPU6050::setSlave4MasterDelay(uint8_t delay) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_I2C_SLV4_CTRL, MPU6050_I2C_SLV4_MST_DLY_BIT, MPU6050_I2C_SLV4_MST_DLY_LENGTH, delay);\n}\n/** Get last available byte read from Slave 4.\n * This register stores the data read from Slave 4. This field is populated\n * after a read transaction.\n * @return Last available byte read from to Slave 4\n * @see MPU6050_RA_I2C_SLV4_DI\n */\nuint8_t MPU6050::getSlate4InputByte() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_I2C_SLV4_DI, buffer);\n    return buffer[0];\n}\n\n// I2C_MST_STATUS register\n\n/** Get FSYNC interrupt status.\n * This bit reflects the status of the FSYNC interrupt from an external device\n * into the MPU-60X0. This is used as a way to pass an external interrupt\n * through the MPU-60X0 to the host application processor. When set to 1, this\n * bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG\n * (Register 55).\n * @return FSYNC interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getPassthroughStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_PASS_THROUGH_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 4 transaction done status.\n * Automatically sets to 1 when a Slave 4 transaction has completed. This\n * triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register\n * (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the\n * I2C_SLV4_CTRL register (Register 52).\n * @return Slave 4 transaction done status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave4IsDone() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV4_DONE_BIT, buffer);\n    return buffer[0];\n}\n/** Get master arbitration lost status.\n * This bit automatically sets to 1 when the I2C Master has lost arbitration of\n * the auxiliary I2C bus (an error condition). This triggers an interrupt if the\n * I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Master arbitration lost status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getLostArbitration() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_LOST_ARB_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 4 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 4 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave4Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV4_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 3 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 3 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave3Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV3_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 2 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 2 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave2Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV2_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 1 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 1 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave1Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV1_NACK_BIT, buffer);\n    return buffer[0];\n}\n/** Get Slave 0 NACK status.\n * This bit automatically sets to 1 when the I2C Master receives a NACK in a\n * transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN\n * bit in the INT_ENABLE register (Register 56) is asserted.\n * @return Slave 0 NACK interrupt status\n * @see MPU6050_RA_I2C_MST_STATUS\n */\nbool MPU6050::getSlave0Nack() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_STATUS, MPU6050_MST_I2C_SLV0_NACK_BIT, buffer);\n    return buffer[0];\n}\n\n// INT_PIN_CFG register\n\n/** Get interrupt logic level mode.\n * Will be set 0 for active-high, 1 for active-low.\n * @return Current interrupt mode (0=active-high, 1=active-low)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_LEVEL_BIT\n */\nbool MPU6050::getInterruptMode() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt logic level mode.\n * @param mode New interrupt mode (0=active-high, 1=active-low)\n * @see getInterruptMode()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_LEVEL_BIT\n */\nvoid MPU6050::setInterruptMode(bool mode) {\n   I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_LEVEL_BIT, mode);\n}\n/** Get interrupt drive mode.\n * Will be set 0 for push-pull, 1 for open-drain.\n * @return Current interrupt drive mode (0=push-pull, 1=open-drain)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_OPEN_BIT\n */\nbool MPU6050::getInterruptDrive() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt drive mode.\n * @param drive New interrupt drive mode (0=push-pull, 1=open-drain)\n * @see getInterruptDrive()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_OPEN_BIT\n */\nvoid MPU6050::setInterruptDrive(bool drive) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_OPEN_BIT, drive);\n}\n/** Get interrupt latch mode.\n * Will be set 0 for 50us-pulse, 1 for latch-until-int-cleared.\n * @return Current latch mode (0=50us-pulse, 1=latch-until-int-cleared)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_LATCH_INT_EN_BIT\n */\nbool MPU6050::getInterruptLatch() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt latch mode.\n * @param latch New latch mode (0=50us-pulse, 1=latch-until-int-cleared)\n * @see getInterruptLatch()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_LATCH_INT_EN_BIT\n */\nvoid MPU6050::setInterruptLatch(bool latch) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_LATCH_INT_EN_BIT, latch);\n}\n/** Get interrupt latch clear mode.\n * Will be set 0 for status-read-only, 1 for any-register-read.\n * @return Current latch clear mode (0=status-read-only, 1=any-register-read)\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT\n */\nbool MPU6050::getInterruptLatchClear() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_RD_CLEAR_BIT, buffer);\n    return buffer[0];\n}\n/** Set interrupt latch clear mode.\n * @param clear New latch clear mode (0=status-read-only, 1=any-register-read)\n * @see getInterruptLatchClear()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_INT_RD_CLEAR_BIT\n */\nvoid MPU6050::setInterruptLatchClear(bool clear) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_INT_RD_CLEAR_BIT, clear);\n}\n/** Get FSYNC interrupt logic level mode.\n * @return Current FSYNC interrupt mode (0=active-high, 1=active-low)\n * @see getFSyncInterruptMode()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT\n */\nbool MPU6050::getFSyncInterruptLevel() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, buffer);\n    return buffer[0];\n}\n/** Set FSYNC interrupt logic level mode.\n * @param mode New FSYNC interrupt mode (0=active-high, 1=active-low)\n * @see getFSyncInterruptMode()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT\n */\nvoid MPU6050::setFSyncInterruptLevel(bool level) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT, level);\n}\n/** Get FSYNC pin interrupt enabled setting.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled setting\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT\n */\nbool MPU6050::getFSyncInterruptEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set FSYNC pin interrupt enabled setting.\n * @param enabled New FSYNC pin interrupt enabled setting\n * @see getFSyncInterruptEnabled()\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_FSYNC_INT_EN_BIT\n */\nvoid MPU6050::setFSyncInterruptEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_FSYNC_INT_EN_BIT, enabled);\n}\n/** Get I2C bypass enabled status.\n * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to\n * 0, the host application processor will be able to directly access the\n * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host\n * application processor will not be able to directly access the auxiliary I2C\n * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106\n * bit[5]).\n * @return Current I2C bypass enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT\n */\nbool MPU6050::getI2CBypassEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C bypass enabled status.\n * When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to\n * 0, the host application processor will be able to directly access the\n * auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host\n * application processor will not be able to directly access the auxiliary I2C\n * bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106\n * bit[5]).\n * @param enabled New I2C bypass enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT\n */\nvoid MPU6050::setI2CBypassEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, enabled);\n}\n/** Get reference clock output enabled status.\n * When this bit is equal to 1, a reference clock output is provided at the\n * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For\n * further information regarding CLKOUT, please refer to the MPU-60X0 Product\n * Specification document.\n * @return Current reference clock output enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_CLKOUT_EN_BIT\n */\nbool MPU6050::getClockOutputEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_CLKOUT_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set reference clock output enabled status.\n * When this bit is equal to 1, a reference clock output is provided at the\n * CLKOUT pin. When this bit is equal to 0, the clock output is disabled. For\n * further information regarding CLKOUT, please refer to the MPU-60X0 Product\n * Specification document.\n * @param enabled New reference clock output enabled status\n * @see MPU6050_RA_INT_PIN_CFG\n * @see MPU6050_INTCFG_CLKOUT_EN_BIT\n */\nvoid MPU6050::setClockOutputEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_CLKOUT_EN_BIT, enabled);\n}\n\n// INT_ENABLE register\n\n/** Get full interrupt enabled status.\n * Full register byte for all interrupts, for quick reading. Each bit will be\n * set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nuint8_t MPU6050::getIntEnabled() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_INT_ENABLE, buffer);\n    return buffer[0];\n}\n/** Set full interrupt enabled status.\n * Full register byte for all interrupts, for quick reading. Each bit should be\n * set 0 for disabled, 1 for enabled.\n * @param enabled New interrupt enabled status\n * @see getIntFreefallEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nvoid MPU6050::setIntEnabled(uint8_t enabled) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_INT_ENABLE, enabled);\n}\n/** Get Free Fall interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nbool MPU6050::getIntFreefallEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FF_BIT, buffer);\n    return buffer[0];\n}\n/** Set Free Fall interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFreefallEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FF_BIT\n **/\nvoid MPU6050::setIntFreefallEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FF_BIT, enabled);\n}\n/** Get Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_MOT_BIT\n **/\nbool MPU6050::getIntMotionEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_MOT_BIT, buffer);\n    return buffer[0];\n}\n/** Set Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntMotionEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_MOT_BIT\n **/\nvoid MPU6050::setIntMotionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_MOT_BIT, enabled);\n}\n/** Get Zero Motion Detection interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_ZMOT_BIT\n **/\nbool MPU6050::getIntZeroMotionEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_ZMOT_BIT, buffer);\n    return buffer[0];\n}\n/** Set Zero Motion Detection interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntZeroMotionEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_ZMOT_BIT\n **/\nvoid MPU6050::setIntZeroMotionEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_ZMOT_BIT, enabled);\n}\n/** Get FIFO Buffer Overflow interrupt enabled status.\n * Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT\n **/\nbool MPU6050::getIntFIFOBufferOverflowEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, buffer);\n    return buffer[0];\n}\n/** Set FIFO Buffer Overflow interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntFIFOBufferOverflowEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT\n **/\nvoid MPU6050::setIntFIFOBufferOverflowEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, enabled);\n}\n/** Get I2C Master interrupt enabled status.\n * This enables any of the I2C Master interrupt sources to generate an\n * interrupt. Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT\n **/\nbool MPU6050::getIntI2CMasterEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_I2C_MST_INT_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C Master interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntI2CMasterEnabled()\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT\n **/\nvoid MPU6050::setIntI2CMasterEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_I2C_MST_INT_BIT, enabled);\n}\n/** Get Data Ready interrupt enabled setting.\n * This event occurs each time a write operation to all of the sensor registers\n * has been completed. Will be set 0 for disabled, 1 for enabled.\n * @return Current interrupt enabled status\n * @see MPU6050_RA_INT_ENABLE\n * @see MPU6050_INTERRUPT_DATA_RDY_BIT\n */\nbool MPU6050::getIntDataReadyEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, buffer);\n    return buffer[0];\n}\n/** Set Data Ready interrupt enabled status.\n * @param enabled New interrupt enabled status\n * @see getIntDataReadyEnabled()\n * @see MPU6050_RA_INT_CFG\n * @see MPU6050_INTERRUPT_DATA_RDY_BIT\n */\nvoid MPU6050::setIntDataReadyEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DATA_RDY_BIT, enabled);\n}\n\n// INT_STATUS register\n\n/** Get full set of interrupt status bits.\n * These bits clear to 0 after the register has been read. Very useful\n * for getting multiple INT statuses, since each single bit read clears\n * all of them because it has to read the whole byte.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n */\nuint8_t MPU6050::getIntStatus() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_INT_STATUS, buffer);\n    return buffer[0];\n}\n/** Get Free Fall interrupt status.\n * This bit automatically sets to 1 when a Free Fall interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_FF_BIT\n */\nbool MPU6050::getIntFreefallStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_FF_BIT, buffer);\n    return buffer[0];\n}\n/** Get Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Motion Detection interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_MOT_BIT\n */\nbool MPU6050::getIntMotionStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_MOT_BIT, buffer);\n    return buffer[0];\n}\n/** Get Zero Motion Detection interrupt status.\n * This bit automatically sets to 1 when a Zero Motion Detection interrupt has\n * been generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_ZMOT_BIT\n */\nbool MPU6050::getIntZeroMotionStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_ZMOT_BIT, buffer);\n    return buffer[0];\n}\n/** Get FIFO Buffer Overflow interrupt status.\n * This bit automatically sets to 1 when a Free Fall interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_FIFO_OFLOW_BIT\n */\nbool MPU6050::getIntFIFOBufferOverflowStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, buffer);\n    return buffer[0];\n}\n/** Get I2C Master interrupt status.\n * This bit automatically sets to 1 when an I2C Master interrupt has been\n * generated. For a list of I2C Master interrupts, please refer to Register 54.\n * The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_I2C_MST_INT_BIT\n */\nbool MPU6050::getIntI2CMasterStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_I2C_MST_INT_BIT, buffer);\n    return buffer[0];\n}\n/** Get Data Ready interrupt status.\n * This bit automatically sets to 1 when a Data Ready interrupt has been\n * generated. The bit clears to 0 after the register has been read.\n * @return Current interrupt status\n * @see MPU6050_RA_INT_STATUS\n * @see MPU6050_INTERRUPT_DATA_RDY_BIT\n */\nbool MPU6050::getIntDataReadyStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_DATA_RDY_BIT, buffer);\n    return buffer[0];\n}\n\n// ACCEL_*OUT_* registers\n\n/** Get raw 9-axis motion sensor readings (accel/gyro/compass).\n * FUNCTION NOT FULLY IMPLEMENTED YET.\n * @param ax 16-bit signed integer container for accelerometer X-axis value\n * @param ay 16-bit signed integer container for accelerometer Y-axis value\n * @param az 16-bit signed integer container for accelerometer Z-axis value\n * @param gx 16-bit signed integer container for gyroscope X-axis value\n * @param gy 16-bit signed integer container for gyroscope Y-axis value\n * @param gz 16-bit signed integer container for gyroscope Z-axis value\n * @param mx 16-bit signed integer container for magnetometer X-axis value\n * @param my 16-bit signed integer container for magnetometer Y-axis value\n * @param mz 16-bit signed integer container for magnetometer Z-axis value\n * @see getMotion6()\n * @see getAcceleration()\n * @see getRotation()\n * @see MPU6050_RA_ACCEL_XOUT_H\n */\nvoid MPU6050::getMotion9(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int16_t* mx, int16_t* my, int16_t* mz) {\n    getMotion6(ax, ay, az, gx, gy, gz);\n    // TODO: magnetometer integration\n}\n/** Get raw 6-axis motion sensor readings (accel/gyro).\n * Retrieves all currently available motion sensor values.\n * @param ax 16-bit signed integer container for accelerometer X-axis value\n * @param ay 16-bit signed integer container for accelerometer Y-axis value\n * @param az 16-bit signed integer container for accelerometer Z-axis value\n * @param gx 16-bit signed integer container for gyroscope X-axis value\n * @param gy 16-bit signed integer container for gyroscope Y-axis value\n * @param gz 16-bit signed integer container for gyroscope Z-axis value\n * @see getAcceleration()\n * @see getRotation()\n * @see MPU6050_RA_ACCEL_XOUT_H\n */\nvoid MPU6050::getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 14, buffer);\n    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *az = (((int16_t)buffer[4]) << 8) | buffer[5];\n    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];\n    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];\n    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];\n}\n/** Get 3-axis accelerometer readings.\n * These registers store the most recent accelerometer measurements.\n * Accelerometer measurements are written to these registers at the Sample Rate\n * as defined in Register 25.\n *\n * The accelerometer measurement registers, along with the temperature\n * measurement registers, gyroscope measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n *\n * The data within the accelerometer sensors' internal register set is always\n * updated at the Sample Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS\n * (Register 28). For each full scale setting, the accelerometers' sensitivity\n * per LSB in ACCEL_xOUT is shown in the table below:\n *\n * <pre>\n * AFS_SEL | Full Scale Range | LSB Sensitivity\n * --------+------------------+----------------\n * 0       | +/- 2g           | 8192 LSB/mg\n * 1       | +/- 4g           | 4096 LSB/mg\n * 2       | +/- 8g           | 2048 LSB/mg\n * 3       | +/- 16g          | 1024 LSB/mg\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis acceleration\n * @param y 16-bit signed integer container for Y-axis acceleration\n * @param z 16-bit signed integer container for Z-axis acceleration\n * @see MPU6050_RA_GYRO_XOUT_H\n */\nvoid MPU6050::getAcceleration(int16_t* x, int16_t* y, int16_t* z) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 6, buffer);\n    *x = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *y = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *z = (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n/** Get X-axis accelerometer reading.\n * @return X-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_ACCEL_XOUT_H\n */\nint16_t MPU6050::getAccelerationX() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_XOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Y-axis accelerometer reading.\n * @return Y-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_ACCEL_YOUT_H\n */\nint16_t MPU6050::getAccelerationY() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_YOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Z-axis accelerometer reading.\n * @return Z-axis acceleration measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_ACCEL_ZOUT_H\n */\nint16_t MPU6050::getAccelerationZ() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ACCEL_ZOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// TEMP_OUT_* registers\n\n/** Get current internal temperature.\n * @return Temperature reading in 16-bit 2's complement format\n * @see MPU6050_RA_TEMP_OUT_H\n */\nint16_t MPU6050::getTemperature() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_TEMP_OUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// GYRO_*OUT_* registers\n\n/** Get 3-axis gyroscope readings.\n * These gyroscope measurement registers, along with the accelerometer\n * measurement registers, temperature measurement registers, and external sensor\n * data registers, are composed of two sets of registers: an internal register\n * set and a user-facing read register set.\n * The data within the gyroscope sensors' internal register set is always\n * updated at the Sample Rate. Meanwhile, the user-facing read register set\n * duplicates the internal register set's data values whenever the serial\n * interface is idle. This guarantees that a burst read of sensor registers will\n * read measurements from the same sampling instant. Note that if burst reads\n * are not used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Each 16-bit gyroscope measurement has a full scale defined in FS_SEL\n * (Register 27). For each full scale setting, the gyroscopes' sensitivity per\n * LSB in GYRO_xOUT is shown in the table below:\n *\n * <pre>\n * FS_SEL | Full Scale Range   | LSB Sensitivity\n * -------+--------------------+----------------\n * 0      | +/- 250 degrees/s  | 131 LSB/deg/s\n * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s\n * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s\n * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s\n * </pre>\n *\n * @param x 16-bit signed integer container for X-axis rotation\n * @param y 16-bit signed integer container for Y-axis rotation\n * @param z 16-bit signed integer container for Z-axis rotation\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_XOUT_H\n */\nvoid MPU6050::getRotation(int16_t* x, int16_t* y, int16_t* z) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_XOUT_H, 6, buffer);\n    *x = (((int16_t)buffer[0]) << 8) | buffer[1];\n    *y = (((int16_t)buffer[2]) << 8) | buffer[3];\n    *z = (((int16_t)buffer[4]) << 8) | buffer[5];\n}\n/** Get X-axis gyroscope reading.\n * @return X-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_XOUT_H\n */\nint16_t MPU6050::getRotationX() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_XOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Y-axis gyroscope reading.\n * @return Y-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_YOUT_H\n */\nint16_t MPU6050::getRotationY() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_YOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Get Z-axis gyroscope reading.\n * @return Z-axis rotation measurement in 16-bit 2's complement format\n * @see getMotion6()\n * @see MPU6050_RA_GYRO_ZOUT_H\n */\nint16_t MPU6050::getRotationZ() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_GYRO_ZOUT_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// EXT_SENS_DATA_* registers\n\n/** Read single byte from external sensor data register.\n * These registers store data read from external sensors by the Slave 0, 1, 2,\n * and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in\n * I2C_SLV4_DI (Register 53).\n *\n * External sensor data is written to these registers at the Sample Rate as\n * defined in Register 25. This access rate can be reduced by using the Slave\n * Delay Enable registers (Register 103).\n *\n * External sensor data registers, along with the gyroscope measurement\n * registers, accelerometer measurement registers, and temperature measurement\n * registers, are composed of two sets of registers: an internal register set\n * and a user-facing read register set.\n *\n * The data within the external sensors' internal register set is always updated\n * at the Sample Rate (or the reduced access rate) whenever the serial interface\n * is idle. This guarantees that a burst read of sensor registers will read\n * measurements from the same sampling instant. Note that if burst reads are not\n * used, the user is responsible for ensuring a set of single byte reads\n * correspond to a single sampling instant by checking the Data Ready interrupt.\n *\n * Data is placed in these external sensor data registers according to\n * I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39,\n * 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN > 0) from\n * an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as\n * defined in Register 25) or delayed rate (if specified in Register 52 and\n * 103). During each Sample cycle, slave reads are performed in order of Slave\n * number. If all slaves are enabled with more than zero bytes to be read, the\n * order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.\n *\n * Each enabled slave will have EXT_SENS_DATA registers associated with it by\n * number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from\n * EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may\n * change the higher numbered slaves' associated registers. Furthermore, if\n * fewer total bytes are being read from the external sensors as a result of\n * such a change, then the data remaining in the registers which no longer have\n * an associated slave device (i.e. high numbered registers) will remain in\n * these previously allocated registers unless reset.\n *\n * If the sum of the read lengths of all SLVx transactions exceed the number of\n * available EXT_SENS_DATA registers, the excess bytes will be dropped. There\n * are 24 EXT_SENS_DATA registers and hence the total read lengths between all\n * the slaves cannot be greater than 24 or some bytes will be lost.\n *\n * Note: Slave 4's behavior is distinct from that of Slaves 0-3. For further\n * information regarding the characteristics of Slave 4, please refer to\n * Registers 49 to 53.\n *\n * EXAMPLE:\n * Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and\n * I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read so that\n * I2C_SLV1_EN = 1 and I2C_SLV1_LEN = 2. In such a situation, EXT_SENS_DATA _00\n * through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05\n * will be associated with Slave 1. If Slave 2 is enabled as well, registers\n * starting from EXT_SENS_DATA_06 will be allocated to Slave 2.\n *\n * If Slave 2 is disabled while Slave 3 is enabled in this same situation, then\n * registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3\n * instead.\n *\n * REGISTER ALLOCATION FOR DYNAMIC DISABLE VS. NORMAL DISABLE:\n * If a slave is disabled at any time, the space initially allocated to the\n * slave in the EXT_SENS_DATA register, will remain associated with that slave.\n * This is to avoid dynamic adjustment of the register allocation.\n *\n * The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all\n * slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106).\n *\n * This above is also true if one of the slaves gets NACKed and stops\n * functioning.\n *\n * @param position Starting position (0-23)\n * @return Byte read from register\n */\nuint8_t MPU6050::getExternalSensorByte(int position) {\n    I2Cdev::readByte(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, buffer);\n    return buffer[0];\n}\n/** Read word (2 bytes) from external sensor data registers.\n * @param position Starting position (0-21)\n * @return Word read from register\n * @see getExternalSensorByte()\n */\nuint16_t MPU6050::getExternalSensorWord(int position) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, 2, buffer);\n    return (((uint16_t)buffer[0]) << 8) | buffer[1];\n}\n/** Read double word (4 bytes) from external sensor data registers.\n * @param position Starting position (0-20)\n * @return Double word read from registers\n * @see getExternalSensorByte()\n */\nuint32_t MPU6050::getExternalSensorDWord(int position) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_EXT_SENS_DATA_00 + position, 4, buffer);\n    return (((uint32_t)buffer[0]) << 24) | (((uint32_t)buffer[1]) << 16) | (((uint16_t)buffer[2]) << 8) | buffer[3];\n}\n\n// MOT_DETECT_STATUS register\n\n/** Get X-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_XNEG_BIT\n */\nbool MPU6050::getXNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_XNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get X-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_XPOS_BIT\n */\nbool MPU6050::getXPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_XPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get Y-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_YNEG_BIT\n */\nbool MPU6050::getYNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_YNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get Y-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_YPOS_BIT\n */\nbool MPU6050::getYPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_YPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get Z-axis negative motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_ZNEG_BIT\n */\nbool MPU6050::getZNegMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZNEG_BIT, buffer);\n    return buffer[0];\n}\n/** Get Z-axis positive motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_ZPOS_BIT\n */\nbool MPU6050::getZPosMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZPOS_BIT, buffer);\n    return buffer[0];\n}\n/** Get zero motion detection interrupt status.\n * @return Motion detection status\n * @see MPU6050_RA_MOT_DETECT_STATUS\n * @see MPU6050_MOTION_MOT_ZRMOT_BIT\n */\nbool MPU6050::getZeroMotionDetected() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_MOT_DETECT_STATUS, MPU6050_MOTION_MOT_ZRMOT_BIT, buffer);\n    return buffer[0];\n}\n\n// I2C_SLV*_DO register\n\n/** Write byte to Data Output container for specified slave.\n * This register holds the output data written into Slave when Slave is set to\n * write mode. For further information regarding Slave control, please\n * refer to Registers 37 to 39 and immediately following.\n * @param num Slave number (0-3)\n * @param data Byte to write\n * @see MPU6050_RA_I2C_SLV0_DO\n */\nvoid MPU6050::setSlaveOutputByte(uint8_t num, uint8_t data) {\n    if (num > 3) return;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_I2C_SLV0_DO + num, data);\n}\n\n// I2C_MST_DELAY_CTRL register\n\n/** Get external data shadow delay enabled status.\n * This register is used to specify the timing of external sensor data\n * shadowing. When DELAY_ES_SHADOW is set to 1, shadowing of external\n * sensor data is delayed until all data has been received.\n * @return Current external data shadow delay enabled status.\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT\n */\nbool MPU6050::getExternalShadowDelayEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT, buffer);\n    return buffer[0];\n}\n/** Set external data shadow delay enabled status.\n * @param enabled New external data shadow delay enabled status.\n * @see getExternalShadowDelayEnabled()\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT\n */\nvoid MPU6050::setExternalShadowDelayEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT, enabled);\n}\n/** Get slave delay enabled status.\n * When a particular slave delay is enabled, the rate of access for the that\n * slave device is reduced. When a slave's access rate is decreased relative to\n * the Sample Rate, the slave is accessed every:\n *\n *     1 / (1 + I2C_MST_DLY) Samples\n *\n * This base Sample Rate in turn is determined by SMPLRT_DIV (register  * 25)\n * and DLPF_CFG (register 26).\n *\n * For further information regarding I2C_MST_DLY, please refer to register 52.\n * For further information regarding the Sample Rate, please refer to register 25.\n *\n * @param num Slave number (0-4)\n * @return Current slave delay enabled status.\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT\n */\nbool MPU6050::getSlaveDelayEnabled(uint8_t num) {\n    // MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT is 4, SLV3 is 3, etc.\n    if (num > 4) return 0;\n    I2Cdev::readBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, num, buffer);\n    return buffer[0];\n}\n/** Set slave delay enabled status.\n * @param num Slave number (0-4)\n * @param enabled New slave delay enabled status.\n * @see MPU6050_RA_I2C_MST_DELAY_CTRL\n * @see MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT\n */\nvoid MPU6050::setSlaveDelayEnabled(uint8_t num, bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_I2C_MST_DELAY_CTRL, num, enabled);\n}\n\n// SIGNAL_PATH_RESET register\n\n/** Reset gyroscope signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU6050_RA_SIGNAL_PATH_RESET\n * @see MPU6050_PATHRESET_GYRO_RESET_BIT\n */\nvoid MPU6050::resetGyroscopePath() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_GYRO_RESET_BIT, true);\n}\n/** Reset accelerometer signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU6050_RA_SIGNAL_PATH_RESET\n * @see MPU6050_PATHRESET_ACCEL_RESET_BIT\n */\nvoid MPU6050::resetAccelerometerPath() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_ACCEL_RESET_BIT, true);\n}\n/** Reset temperature sensor signal path.\n * The reset will revert the signal path analog to digital converters and\n * filters to their power up configurations.\n * @see MPU6050_RA_SIGNAL_PATH_RESET\n * @see MPU6050_PATHRESET_TEMP_RESET_BIT\n */\nvoid MPU6050::resetTemperaturePath() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_SIGNAL_PATH_RESET, MPU6050_PATHRESET_TEMP_RESET_BIT, true);\n}\n\n// MOT_DETECT_CTRL register\n\n/** Get accelerometer power-on delay.\n * The accelerometer data path provides samples to the sensor registers, Motion\n * detection, Zero Motion detection, and Free Fall detection modules. The\n * signal path contains filters which must be flushed on wake-up with new\n * samples before the detection modules begin operations. The default wake-up\n * delay, of 4ms can be lengthened by up to 3ms. This additional delay is\n * specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select\n * any value above zero unless instructed otherwise by InvenSense. Please refer\n * to Section 8 of the MPU-6000/MPU-6050 Product Specification document for\n * further information regarding the detection modules.\n * @return Current accelerometer power-on delay\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT\n */\nuint8_t MPU6050::getAccelerometerPowerOnDelay() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_ACCEL_ON_DELAY_BIT, MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set accelerometer power-on delay.\n * @param delay New accelerometer power-on delay (0-3)\n * @see getAccelerometerPowerOnDelay()\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_ACCEL_ON_DELAY_BIT\n */\nvoid MPU6050::setAccelerometerPowerOnDelay(uint8_t delay) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_ACCEL_ON_DELAY_BIT, MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH, delay);\n}\n/** Get Free Fall detection counter decrement configuration.\n * Detection is registered by the Free Fall detection module after accelerometer\n * measurements meet their respective threshold conditions over a specified\n * number of samples. When the threshold conditions are met, the corresponding\n * detection counter increments by 1. The user may control the rate at which the\n * detection counter decrements when the threshold condition is not met by\n * configuring FF_COUNT. The decrement rate can be set according to the\n * following table:\n *\n * <pre>\n * FF_COUNT | Counter Decrement\n * ---------+------------------\n * 0        | Reset\n * 1        | 1\n * 2        | 2\n * 3        | 4\n * </pre>\n *\n * When FF_COUNT is configured to 0 (reset), any non-qualifying sample will\n * reset the counter to 0. For further information on Free Fall detection,\n * please refer to Registers 29 to 32.\n *\n * @return Current decrement configuration\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_FF_COUNT_BIT\n */\nuint8_t MPU6050::getFreefallDetectionCounterDecrement() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_FF_COUNT_BIT, MPU6050_DETECT_FF_COUNT_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Free Fall detection counter decrement configuration.\n * @param decrement New decrement configuration value\n * @see getFreefallDetectionCounterDecrement()\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_FF_COUNT_BIT\n */\nvoid MPU6050::setFreefallDetectionCounterDecrement(uint8_t decrement) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_FF_COUNT_BIT, MPU6050_DETECT_FF_COUNT_LENGTH, decrement);\n}\n/** Get Motion detection counter decrement configuration.\n * Detection is registered by the Motion detection module after accelerometer\n * measurements meet their respective threshold conditions over a specified\n * number of samples. When the threshold conditions are met, the corresponding\n * detection counter increments by 1. The user may control the rate at which the\n * detection counter decrements when the threshold condition is not met by\n * configuring MOT_COUNT. The decrement rate can be set according to the\n * following table:\n *\n * <pre>\n * MOT_COUNT | Counter Decrement\n * ----------+------------------\n * 0         | Reset\n * 1         | 1\n * 2         | 2\n * 3         | 4\n * </pre>\n *\n * When MOT_COUNT is configured to 0 (reset), any non-qualifying sample will\n * reset the counter to 0. For further information on Motion detection,\n * please refer to Registers 29 to 32.\n *\n */\nuint8_t MPU6050::getMotionDetectionCounterDecrement() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_MOT_COUNT_BIT, MPU6050_DETECT_MOT_COUNT_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Motion detection counter decrement configuration.\n * @param decrement New decrement configuration value\n * @see getMotionDetectionCounterDecrement()\n * @see MPU6050_RA_MOT_DETECT_CTRL\n * @see MPU6050_DETECT_MOT_COUNT_BIT\n */\nvoid MPU6050::setMotionDetectionCounterDecrement(uint8_t decrement) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_MOT_DETECT_CTRL, MPU6050_DETECT_MOT_COUNT_BIT, MPU6050_DETECT_MOT_COUNT_LENGTH, decrement);\n}\n\n// USER_CTRL register\n\n/** Get FIFO enabled status.\n * When this bit is set to 0, the FIFO buffer is disabled. The FIFO buffer\n * cannot be written to or read from while disabled. The FIFO buffer's state\n * does not change unless the MPU-60X0 is power cycled.\n * @return Current FIFO enabled status\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_FIFO_EN_BIT\n */\nbool MPU6050::getFIFOEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set FIFO enabled status.\n * @param enabled New FIFO enabled status\n * @see getFIFOEnabled()\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_FIFO_EN_BIT\n */\nvoid MPU6050::setFIFOEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, enabled);\n}\n/** Get I2C Master Mode enabled status.\n * When this mode is enabled, the MPU-60X0 acts as the I2C Master to the\n * external sensor slave devices on the auxiliary I2C bus. When this bit is\n * cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically\n * driven by the primary I2C bus (SDA and SCL). This is a precondition to\n * enabling Bypass Mode. For further information regarding Bypass Mode, please\n * refer to Register 55.\n * @return Current I2C Master Mode enabled status\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_I2C_MST_EN_BIT\n */\nbool MPU6050::getI2CMasterModeEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, buffer);\n    return buffer[0];\n}\n/** Set I2C Master Mode enabled status.\n * @param enabled New I2C Master Mode enabled status\n * @see getI2CMasterModeEnabled()\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_I2C_MST_EN_BIT\n */\nvoid MPU6050::setI2CMasterModeEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled);\n}\n/** Switch from I2C to SPI mode (MPU-6000 only)\n * If this is set, the primary SPI interface will be enabled in place of the\n * disabled primary I2C interface.\n */\nvoid MPU6050::switchSPIEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_IF_DIS_BIT, enabled);\n}\n/** Reset the FIFO.\n * This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This\n * bit automatically clears to 0 after the reset has been triggered.\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_FIFO_RESET_BIT\n */\nvoid MPU6050::resetFIFO() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, true);\n}\n/** Reset the I2C Master.\n * This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0.\n * This bit automatically clears to 0 after the reset has been triggered.\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_I2C_MST_RESET_BIT\n */\nvoid MPU6050::resetI2CMaster() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_RESET_BIT, true);\n}\n/** Reset all sensor registers and signal paths.\n * When set to 1, this bit resets the signal paths for all sensors (gyroscopes,\n * accelerometers, and temperature sensor). This operation will also clear the\n * sensor registers. This bit automatically clears to 0 after the reset has been\n * triggered.\n *\n * When resetting only the signal path (and not the sensor registers), please\n * use Register 104, SIGNAL_PATH_RESET.\n *\n * @see MPU6050_RA_USER_CTRL\n * @see MPU6050_USERCTRL_SIG_COND_RESET_BIT\n */\nvoid MPU6050::resetSensors() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_SIG_COND_RESET_BIT, true);\n}\n\n// PWR_MGMT_1 register\n\n/** Trigger a full device reset.\n * A small delay of ~50ms may be desirable after triggering a reset.\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_DEVICE_RESET_BIT\n */\nvoid MPU6050::reset() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, true);\n}\n/** Get sleep mode status.\n * Setting the SLEEP bit in the register puts the device into very low power\n * sleep mode. In this mode, only the serial interface and internal registers\n * remain active, allowing for a very low standby current. Clearing this bit\n * puts the device back into normal mode. To save power, the individual standby\n * selections for each of the gyros should be used if any gyro axis is not used\n * by the application.\n * @return Current sleep mode enabled status\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_SLEEP_BIT\n */\nbool MPU6050::getSleepEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, buffer);\n    return buffer[0];\n}\n/** Set sleep mode status.\n * @param enabled New sleep mode enabled status\n * @see getSleepEnabled()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_SLEEP_BIT\n */\nvoid MPU6050::setSleepEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled);\n}\n/** Get wake cycle enabled status.\n * When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle\n * between sleep mode and waking up to take a single sample of data from active\n * sensors at a rate determined by LP_WAKE_CTRL (register 108).\n * @return Current sleep mode enabled status\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CYCLE_BIT\n */\nbool MPU6050::getWakeCycleEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CYCLE_BIT, buffer);\n    return buffer[0];\n}\n/** Set wake cycle enabled status.\n * @param enabled New sleep mode enabled status\n * @see getWakeCycleEnabled()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CYCLE_BIT\n */\nvoid MPU6050::setWakeCycleEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CYCLE_BIT, enabled);\n}\n/** Get temperature sensor enabled status.\n * Control the usage of the internal temperature sensor.\n *\n * Note: this register stores the *disabled* value, but for consistency with the\n * rest of the code, the function is named and used with standard true/false\n * values to indicate whether the sensor is enabled or disabled, respectively.\n *\n * @return Current temperature sensor enabled status\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_TEMP_DIS_BIT\n */\nbool MPU6050::getTempSensorEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, buffer);\n    return buffer[0] == 0; // 1 is actually disabled here\n}\n/** Set temperature sensor enabled status.\n * Note: this register stores the *disabled* value, but for consistency with the\n * rest of the code, the function is named and used with standard true/false\n * values to indicate whether the sensor is enabled or disabled, respectively.\n *\n * @param enabled New temperature sensor enabled status\n * @see getTempSensorEnabled()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_TEMP_DIS_BIT\n */\nvoid MPU6050::setTempSensorEnabled(bool enabled) {\n    // 1 is actually disabled here\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_TEMP_DIS_BIT, !enabled);\n}\n/** Get clock source setting.\n * @return Current clock source setting\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CLKSEL_BIT\n * @see MPU6050_PWR1_CLKSEL_LENGTH\n */\nuint8_t MPU6050::getClockSource() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set clock source setting.\n * An internal 8MHz oscillator, gyroscope based clock, or external sources can\n * be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator\n * or an external source is chosen as the clock source, the MPU-60X0 can operate\n * in low power modes with the gyroscopes disabled.\n *\n * Upon power up, the MPU-60X0 clock source defaults to the internal oscillator.\n * However, it is highly recommended that the device be configured to use one of\n * the gyroscopes (or an external clock source) as the clock reference for\n * improved stability. The clock source can be selected according to the following table:\n *\n * <pre>\n * CLK_SEL | Clock Source\n * --------+--------------------------------------\n * 0       | Internal oscillator\n * 1       | PLL with X Gyro reference\n * 2       | PLL with Y Gyro reference\n * 3       | PLL with Z Gyro reference\n * 4       | PLL with external 32.768kHz reference\n * 5       | PLL with external 19.2MHz reference\n * 6       | Reserved\n * 7       | Stops the clock and keeps the timing generator in reset\n * </pre>\n *\n * @param source New clock source setting\n * @see getClockSource()\n * @see MPU6050_RA_PWR_MGMT_1\n * @see MPU6050_PWR1_CLKSEL_BIT\n * @see MPU6050_PWR1_CLKSEL_LENGTH\n */\nvoid MPU6050::setClockSource(uint8_t source) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);\n}\n\n// PWR_MGMT_2 register\n\n/** Get wake frequency in Accel-Only Low Power Mode.\n * The MPU-60X0 can be put into Accerlerometer Only Low Power Mode by setting\n * PWRSEL to 1 in the Power Management 1 register (Register 107). In this mode,\n * the device will power off all devices except for the primary I2C interface,\n * waking only the accelerometer at fixed intervals to take a single\n * measurement. The frequency of wake-ups can be configured with LP_WAKE_CTRL\n * as shown below:\n *\n * <pre>\n * LP_WAKE_CTRL | Wake-up Frequency\n * -------------+------------------\n * 0            | 1.25 Hz\n * 1            | 2.5 Hz\n * 2            | 5 Hz\n * 3            | 10 Hz\n * <pre>\n *\n * For further information regarding the MPU-60X0's power modes, please refer to\n * Register 107.\n *\n * @return Current wake frequency\n * @see MPU6050_RA_PWR_MGMT_2\n */\nuint8_t MPU6050::getWakeFrequency() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU6050_PWR2_LP_WAKE_CTRL_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set wake frequency in Accel-Only Low Power Mode.\n * @param frequency New wake frequency\n * @see MPU6050_RA_PWR_MGMT_2\n */\nvoid MPU6050::setWakeFrequency(uint8_t frequency) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_LP_WAKE_CTRL_BIT, MPU6050_PWR2_LP_WAKE_CTRL_LENGTH, frequency);\n}\n\n/** Get X-axis accelerometer standby enabled status.\n * If enabled, the X-axis will not gather or report data (or use power).\n * @return Current X-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XA_BIT\n */\nbool MPU6050::getStandbyXAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XA_BIT, buffer);\n    return buffer[0];\n}\n/** Set X-axis accelerometer standby enabled status.\n * @param New X-axis standby enabled status\n * @see getStandbyXAccelEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XA_BIT\n */\nvoid MPU6050::setStandbyXAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XA_BIT, enabled);\n}\n/** Get Y-axis accelerometer standby enabled status.\n * If enabled, the Y-axis will not gather or report data (or use power).\n * @return Current Y-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YA_BIT\n */\nbool MPU6050::getStandbyYAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YA_BIT, buffer);\n    return buffer[0];\n}\n/** Set Y-axis accelerometer standby enabled status.\n * @param New Y-axis standby enabled status\n * @see getStandbyYAccelEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YA_BIT\n */\nvoid MPU6050::setStandbyYAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YA_BIT, enabled);\n}\n/** Get Z-axis accelerometer standby enabled status.\n * If enabled, the Z-axis will not gather or report data (or use power).\n * @return Current Z-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZA_BIT\n */\nbool MPU6050::getStandbyZAccelEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZA_BIT, buffer);\n    return buffer[0];\n}\n/** Set Z-axis accelerometer standby enabled status.\n * @param New Z-axis standby enabled status\n * @see getStandbyZAccelEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZA_BIT\n */\nvoid MPU6050::setStandbyZAccelEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZA_BIT, enabled);\n}\n/** Get X-axis gyroscope standby enabled status.\n * If enabled, the X-axis will not gather or report data (or use power).\n * @return Current X-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XG_BIT\n */\nbool MPU6050::getStandbyXGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XG_BIT, buffer);\n    return buffer[0];\n}\n/** Set X-axis gyroscope standby enabled status.\n * @param New X-axis standby enabled status\n * @see getStandbyXGyroEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_XG_BIT\n */\nvoid MPU6050::setStandbyXGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_XG_BIT, enabled);\n}\n/** Get Y-axis gyroscope standby enabled status.\n * If enabled, the Y-axis will not gather or report data (or use power).\n * @return Current Y-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YG_BIT\n */\nbool MPU6050::getStandbyYGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YG_BIT, buffer);\n    return buffer[0];\n}\n/** Set Y-axis gyroscope standby enabled status.\n * @param New Y-axis standby enabled status\n * @see getStandbyYGyroEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_YG_BIT\n */\nvoid MPU6050::setStandbyYGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_YG_BIT, enabled);\n}\n/** Get Z-axis gyroscope standby enabled status.\n * If enabled, the Z-axis will not gather or report data (or use power).\n * @return Current Z-axis standby enabled status\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZG_BIT\n */\nbool MPU6050::getStandbyZGyroEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZG_BIT, buffer);\n    return buffer[0];\n}\n/** Set Z-axis gyroscope standby enabled status.\n * @param New Z-axis standby enabled status\n * @see getStandbyZGyroEnabled()\n * @see MPU6050_RA_PWR_MGMT_2\n * @see MPU6050_PWR2_STBY_ZG_BIT\n */\nvoid MPU6050::setStandbyZGyroEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_PWR_MGMT_2, MPU6050_PWR2_STBY_ZG_BIT, enabled);\n}\n\n// FIFO_COUNT* registers\n\n/** Get current FIFO buffer size.\n * This value indicates the number of bytes stored in the FIFO buffer. This\n * number is in turn the number of bytes that can be read from the FIFO buffer\n * and it is directly proportional to the number of samples available given the\n * set of sensor data bound to be stored in the FIFO (register 35 and 36).\n * @return Current FIFO buffer size\n */\nuint16_t MPU6050::getFIFOCount() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_COUNTH, 2, buffer);\n    return (((uint16_t)buffer[0]) << 8) | buffer[1];\n}\n\n// FIFO_R_W register\n\n/** Get byte from FIFO buffer.\n * This register is used to read and write data from the FIFO buffer. Data is\n * written to the FIFO in order of register number (from lowest to highest). If\n * all the FIFO enable flags (see below) are enabled and all External Sensor\n * Data registers (Registers 73 to 96) are associated with a Slave device, the\n * contents of registers 59 through 96 will be written in order at the Sample\n * Rate.\n *\n * The contents of the sensor data registers (Registers 59 to 96) are written\n * into the FIFO buffer when their corresponding FIFO enable flags are set to 1\n * in FIFO_EN (Register 35). An additional flag for the sensor data registers\n * associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).\n *\n * If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is\n * automatically set to 1. This bit is located in INT_STATUS (Register 58).\n * When the FIFO buffer has overflowed, the oldest data will be lost and new\n * data will be written to the FIFO.\n *\n * If the FIFO buffer is empty, reading this register will return the last byte\n * that was previously read from the FIFO until new data is available. The user\n * should check FIFO_COUNT to ensure that the FIFO buffer is not read when\n * empty.\n *\n * @return Byte from FIFO buffer\n */\nuint8_t MPU6050::getFIFOByte() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_FIFO_R_W, buffer);\n    return buffer[0];\n}\nvoid MPU6050::getFIFOBytes(uint8_t *data, uint8_t length) {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_FIFO_R_W, length, data);\n}\n/** Write byte to FIFO buffer.\n * @see getFIFOByte()\n * @see MPU6050_RA_FIFO_R_W\n */\nvoid MPU6050::setFIFOByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_FIFO_R_W, data);\n}\n\n// WHO_AM_I register\n\n/** Get Device ID.\n * This register is used to verify the identity of the device (0b110100, 0x34).\n * @return Device ID (6 bits only! should be 0x34)\n * @see MPU6050_RA_WHO_AM_I\n * @see MPU6050_WHO_AM_I_BIT\n * @see MPU6050_WHO_AM_I_LENGTH\n */\nuint8_t MPU6050::getDeviceID() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_WHO_AM_I, MPU6050_WHO_AM_I_BIT, MPU6050_WHO_AM_I_LENGTH, buffer);\n    return buffer[0];\n}\n/** Set Device ID.\n * Write a new ID into the WHO_AM_I register (no idea why this should ever be\n * necessary though).\n * @param id New device ID to set.\n * @see getDeviceID()\n * @see MPU6050_RA_WHO_AM_I\n * @see MPU6050_WHO_AM_I_BIT\n * @see MPU6050_WHO_AM_I_LENGTH\n */\nvoid MPU6050::setDeviceID(uint8_t id) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_WHO_AM_I, MPU6050_WHO_AM_I_BIT, MPU6050_WHO_AM_I_LENGTH, id);\n}\n\n// ======== UNDOCUMENTED/DMP REGISTERS/METHODS ========\n\n// XG_OFFS_TC register\n\nuint8_t MPU6050::getOTPBankValid() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setOTPBankValid(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, enabled);\n}\nint8_t MPU6050::getXGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setXGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);\n}\n\n// YG_OFFS_TC register\n\nint8_t MPU6050::getYGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setYGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);\n}\n\n// ZG_OFFS_TC register\n\nint8_t MPU6050::getZGyroOffset() {\n    I2Cdev::readBits(devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setZGyroOffset(int8_t offset) {\n    I2Cdev::writeBits(devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);\n}\n\n// X_FINE_GAIN register\n\nint8_t MPU6050::getXFineGain() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_X_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setXFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_X_FINE_GAIN, gain);\n}\n\n// Y_FINE_GAIN register\n\nint8_t MPU6050::getYFineGain() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_Y_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setYFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_Y_FINE_GAIN, gain);\n}\n\n// Z_FINE_GAIN register\n\nint8_t MPU6050::getZFineGain() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_Z_FINE_GAIN, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setZFineGain(int8_t gain) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_Z_FINE_GAIN, gain);\n}\n\n// XA_OFFS_* registers\n\nint16_t MPU6050::getXAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_XA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setXAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_XA_OFFS_H, offset);\n}\n\n// YA_OFFS_* register\n\nint16_t MPU6050::getYAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_YA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setYAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_YA_OFFS_H, offset);\n}\n\n// ZA_OFFS_* register\n\nint16_t MPU6050::getZAccelOffset() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ZA_OFFS_H, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setZAccelOffset(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_ZA_OFFS_H, offset);\n}\n\n// XG_OFFS_USR* registers\n\nint16_t MPU6050::getXGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_XG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setXGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_XG_OFFS_USRH, offset);\n}\n\n// YG_OFFS_USR* register\n\nint16_t MPU6050::getYGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_YG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setYGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_YG_OFFS_USRH, offset);\n}\n\n// ZG_OFFS_USR* register\n\nint16_t MPU6050::getZGyroOffsetUser() {\n    I2Cdev::readBytes(devAddr, MPU6050_RA_ZG_OFFS_USRH, 2, buffer);\n    return (((int16_t)buffer[0]) << 8) | buffer[1];\n}\nvoid MPU6050::setZGyroOffsetUser(int16_t offset) {\n    I2Cdev::writeWord(devAddr, MPU6050_RA_ZG_OFFS_USRH, offset);\n}\n\n// INT_ENABLE register (DMP functions)\n\nbool MPU6050::getIntPLLReadyEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setIntPLLReadyEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, enabled);\n}\nbool MPU6050::getIntDMPEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setIntDMPEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, enabled);\n}\n\n// DMP_INT_STATUS\n\nbool MPU6050::getDMPInt5Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_5_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt4Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_4_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt3Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_3_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt2Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_2_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt1Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_1_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getDMPInt0Status() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_DMP_INT_STATUS, MPU6050_DMPINT_0_BIT, buffer);\n    return buffer[0];\n}\n\n// INT_STATUS register (DMP functions)\n\nbool MPU6050::getIntPLLReadyStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_PLL_RDY_INT_BIT, buffer);\n    return buffer[0];\n}\nbool MPU6050::getIntDMPStatus() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_INT_STATUS, MPU6050_INTERRUPT_DMP_INT_BIT, buffer);\n    return buffer[0];\n}\n\n// USER_CTRL register (DMP functions)\n\nbool MPU6050::getDMPEnabled() {\n    I2Cdev::readBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setDMPEnabled(bool enabled) {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);\n}\nvoid MPU6050::resetDMP() {\n    I2Cdev::writeBit(devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, true);\n}\n\n// BANK_SEL register\n\nvoid MPU6050::setMemoryBank(uint8_t bank, bool prefetchEnabled, bool userBank) {\n    bank &= 0x1F;\n    if (userBank) bank |= 0x20;\n    if (prefetchEnabled) bank |= 0x40;\n    I2Cdev::writeByte(devAddr, MPU6050_RA_BANK_SEL, bank);\n}\n\n// MEM_START_ADDR register\n\nvoid MPU6050::setMemoryStartAddress(uint8_t address) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_START_ADDR, address);\n}\n\n// MEM_R_W register\n\nuint8_t MPU6050::readMemoryByte() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_MEM_R_W, buffer);\n    return buffer[0];\n}\nvoid MPU6050::writeMemoryByte(uint8_t data) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_MEM_R_W, data);\n}\nvoid MPU6050::readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {\n    setMemoryBank(bank);\n    setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    for (uint16_t i = 0; i < dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize > dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize > 256 - address) chunkSize = 256 - address;\n\n        // read the chunk of data as specified\n        I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, data + i);\n        \n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i < dataSize) {\n            if (address == 0) bank++;\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n        }\n    }\n}\nbool MPU6050::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {\n    setMemoryBank(bank);\n    setMemoryStartAddress(address);\n    uint8_t chunkSize;\n    uint8_t *verifyBuffer;\n    uint8_t *progBuffer;\n    uint16_t i;\n    uint8_t j;\n    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);\n    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);\n    for (i = 0; i < dataSize;) {\n        // determine correct chunk size according to bank position and data size\n        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;\n\n        // make sure we don't go past the data size\n        if (i + chunkSize > dataSize) chunkSize = dataSize - i;\n\n        // make sure this chunk doesn't go past the bank boundary (256 bytes)\n        if (chunkSize > 256 - address) chunkSize = 256 - address;\n        \n        if (useProgMem) {\n            // write the chunk of data as specified\n            for (j = 0; j < chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n        } else {\n            // write the chunk of data as specified\n            progBuffer = (uint8_t *)data + i;\n        }\n\n        I2Cdev::writeBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, progBuffer);\n\n        // verify data if needed\n        if (verify && verifyBuffer) {\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n            I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, verifyBuffer);\n            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {\n                /*Serial.print(\"Block write verification error, bank \");\n                Serial.print(bank, DEC);\n                Serial.print(\", address \");\n                Serial.print(address, DEC);\n                Serial.print(\"!\\nExpected:\");\n                for (j = 0; j < chunkSize; j++) {\n                    Serial.print(\" 0x\");\n                    if (progBuffer[j] < 16) Serial.print(\"0\");\n                    Serial.print(progBuffer[j], HEX);\n                }\n                Serial.print(\"\\nReceived:\");\n                for (uint8_t j = 0; j < chunkSize; j++) {\n                    Serial.print(\" 0x\");\n                    if (verifyBuffer[i + j] < 16) Serial.print(\"0\");\n                    Serial.print(verifyBuffer[i + j], HEX);\n                }\n                Serial.print(\"\\n\");*/\n                free(verifyBuffer);\n                if (useProgMem) free(progBuffer);\n                return false; // uh oh.\n            }\n        }\n\n        // increase byte index by [chunkSize]\n        i += chunkSize;\n\n        // uint8_t automatically wraps to 0 at 256\n        address += chunkSize;\n\n        // if we aren't done, update bank (if necessary) and address\n        if (i < dataSize) {\n            if (address == 0) bank++;\n            setMemoryBank(bank);\n            setMemoryStartAddress(address);\n        }\n    }\n    if (verify) free(verifyBuffer);\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool MPU6050::writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {\n    return writeMemoryBlock(data, dataSize, bank, address, verify, true);\n}\nbool MPU6050::writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, bool useProgMem) {\n    uint8_t *progBuffer, success, special;\n    uint16_t i, j;\n    if (useProgMem) {\n        progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary\n    }\n\n    // config set data is a long string of blocks with the following structure:\n    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]\n    uint8_t bank, offset, length;\n    for (i = 0; i < dataSize;) {\n        if (useProgMem) {\n            bank = pgm_read_byte(data + i++);\n            offset = pgm_read_byte(data + i++);\n            length = pgm_read_byte(data + i++);\n        } else {\n            bank = data[i++];\n            offset = data[i++];\n            length = data[i++];\n        }\n\n        // write data or perform special action\n        if (length > 0) {\n            // regular block of data to write\n            /*Serial.print(\"Writing config block to bank \");\n            Serial.print(bank);\n            Serial.print(\", offset \");\n            Serial.print(offset);\n            Serial.print(\", length=\");\n            Serial.println(length);*/\n            if (useProgMem) {\n                if (sizeof(progBuffer) < length) progBuffer = (uint8_t *)realloc(progBuffer, length);\n                for (j = 0; j < length; j++) progBuffer[j] = pgm_read_byte(data + i + j);\n            } else {\n                progBuffer = (uint8_t *)data + i;\n            }\n            success = writeMemoryBlock(progBuffer, length, bank, offset, true);\n            i += length;\n        } else {\n            // special instruction\n            // NOTE: this kind of behavior (what and when to do certain things)\n            // is totally undocumented. This code is in here based on observed\n            // behavior only, and exactly why (or even whether) it has to be here\n            // is anybody's guess for now.\n            if (useProgMem) {\n                special = pgm_read_byte(data + i++);\n            } else {\n                special = data[i++];\n            }\n            /*Serial.print(\"Special command code \");\n            Serial.print(special, HEX);\n            Serial.println(\" found...\");*/\n            if (special == 0x01) {\n                // enable DMP-related interrupts\n                \n                //setIntZeroMotionEnabled(true);\n                //setIntFIFOBufferOverflowEnabled(true);\n                //setIntDMPEnabled(true);\n                I2Cdev::writeByte(devAddr, MPU6050_RA_INT_ENABLE, 0x32);  // single operation\n\n                success = true;\n            } else {\n                // unknown special command\n                success = false;\n            }\n        }\n        \n        if (!success) {\n            if (useProgMem) free(progBuffer);\n            return false; // uh oh\n        }\n    }\n    if (useProgMem) free(progBuffer);\n    return true;\n}\nbool MPU6050::writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {\n    return writeDMPConfigurationSet(data, dataSize, true);\n}\n\n// DMP_CFG_1 register\n\nuint8_t MPU6050::getDMPConfig1() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_1, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setDMPConfig1(uint8_t config) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_1, config);\n}\n\n// DMP_CFG_2 register\n\nuint8_t MPU6050::getDMPConfig2() {\n    I2Cdev::readByte(devAddr, MPU6050_RA_DMP_CFG_2, buffer);\n    return buffer[0];\n}\nvoid MPU6050::setDMPConfig2(uint8_t config) {\n    I2Cdev::writeByte(devAddr, MPU6050_RA_DMP_CFG_2, config);\n}"},{"name":"MPU6050wrapper.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\AppData\\Roaming\\MathWorks\\MATLAB Add-Ons\\Collections\\Rensselaer Arduino Support Package Library (RASPLib)\\RASPlib\\src","tag":"","groupDisplay":"Other files","code":"\n#include \"Wire.h\"\n#include \"twi.h\"\n#include \"I2Cdev.h\"\n#include \"MPU6050.h\"\n\nMPU6050 accelgyro;\n\nextern \"C\" void MPU6050Accel_Init(void)\n{\n    Wire.begin();\n    accelgyro.initialize();\n\t\n/* \t// Make devAddr public and add this line:\n\tif(!accelgyro.testConnection())\n\t{\n\t\t//Serial.println(\"Test Connection Failed Changing I2C addr to 0x69\");\n\t\taccelgyro.devAddr=0x69;\n\t} */\n\t\n\t\n\t//  Enable I2C bypass on MPU6050 so the compass can be accessed\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, false);\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, true);\n\tI2Cdev::writeBit(MPU6050_DEFAULT_ADDRESS, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, false);\n}\nextern \"C\" void MPU6050Accel_Read(int* pfData)\n{\n    pfData[0]=accelgyro.getAccelerationX();\n    pfData[1]=accelgyro.getAccelerationY();\n    pfData[2]=accelgyro.getAccelerationZ();\n}\n\nextern \"C\" void MPU6050Gyro_Init(int DLPFmode)\n{\n    Wire.begin();\n\taccelgyro.setDLPFMode(DLPFmode);\n    accelgyro.initialize();\n}\n\nextern \"C\" void MPU6050Gyro_Read(int* pfData)\n{\n    pfData[0]=accelgyro.getRotationX();\n    pfData[1]=accelgyro.getRotationY();\n    pfData[2]=accelgyro.getRotationZ();    \n}\n\nextern \"C\" void MPU6050Temp_Read(int* pfData)\n{\n    pfData[0]=accelgyro.getTemperature();\n}\n\n"},{"name":"MW_ArduinoHWInit.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinotarget\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n*\n* Copyright 2014-2022 The MathWorks, Inc.\n*/\n\n#include \"Arduino.h\"\n#include \"io_wrappers.h\"\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#include \"arduinoARM_M0plusScheduler.h\"\n#elif defined(ARDUINO_ARM_CORTEX_M3)\n#include \"arduinoARMScheduler.h\"\n#include \"watchdog.h\"\n#else\n#include \"arduinoAVRScheduler.h\"\n#endif\n\n#if defined(ESP_PLATFORM)\n#include \"esp_wpa2.h\" //wpa2 library for connections to Enterprise networks\n#endif\n\n#ifdef _RTT_NUMI2C_\n#include \"MW_arduinoI2C.h\"\n#endif\n\n#if defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"MW_PWM_NANO33BLE.h\"\n#endif\n\n#if (defined(_RTT_SPI_SSPIN_)) || (defined(_RTT_DUE_SPI_SSPIN4_)) || (defined(_RTT_DUE_SPI_SSPIN10_)) || (defined(_RTT_DUE_SPI_SSPIN52_))\n#include \"MW_SPIwriteRead.h\"\n#endif\n\n#if (defined(_RTT_RS485_INUSE_))\n#include \"ArduinoRS485.h\"\n#endif\n\n#if (defined(_RTT_MODBUS_MASTER_)) || (defined(_RTT_MODBUS_SLAVE_))\n#include \"ArduinoModbus.h\"\n#endif\n\n#ifdef NANO_MOTOR_CARRIER\n#include <Wire.h>\n#define PMIC_ADDRESS  0x6B\n#define PMIC_REG00    0x00\n#define PMIC_REG01    0x01\n#define PMIC_REG02    0x02\n#define PMIC_REG04    0x04\n#define PMIC_REG05    0x05\nvoid MW_EnableNanoCarrierBatteryCharging(void);\n#endif\n\n// Wifi init routines\n#include <inttypes.h>\n#if (defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)) || (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n#if defined(ARDUINO_WIFI_LIB_101)\n#include <WiFi101.h>\n#elif defined(ARDUINO_WIFI_LIB_NINA)\n#include <WiFiNINA.h>\n#else\n#include <WiFi.h>\n#endif\n#include <SPI.h>\n\n/*#define that helps to stringify build flags\n//Double evaluation is needed so that the double quotes can be derived out\n//of the build flag and can be assigned to a character array */\n#define RTT_StringifyBuildFlag(x) RTT_StringParamExpanded(x)\n#define RTT_StringParamExpanded(x)  #x\n\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\n#ifdef ESP_PLATFORM\nIPAddress wifigateway(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, uint8_t(1));\nIPAddress subnet(uint8_t(255),uint8_t(255),uint8_t(255),uint8_t(0));\nIPAddress dns1 = (uint32_t)0x00000000;\nIPAddress dns2 = (uint32_t)0x00000000;\n#endif\nchar ssid[] = RTT_StringifyBuildFlag(_RTT_WIFI_SSID);\nint configureSuccess = WL_IDLE_STATUS;\nint trialcount;\n\n#ifdef _RTT_WIFI_WEP\nchar key[] = RTT_StringifyBuildFlag(_RTT_WIFI_KEY);\nint keyIndex = _RTT_WIFI_KEY_INDEX;\n#endif //_RTT_WIFI_WEP\n\n#ifdef _RTT_WIFI_WPA\nchar wpapass[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA_PASSWORD);\n#endif //_RTT_WIFI_WPA\n\n#ifdef _RTT_WIFI_WPA2_ENTERPRISE\nchar wpa2username[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_USERNAME);\nchar wpa2password[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_PASSWORD);\n#endif //_RTT_WIFI_WPA2_ENTERPRISE\n#endif //(defined(_RTT_THINGSPEAK_WIFI_) || (_RTT_WIFI_TCP_ !=0) || defined(_RTT_WEBSOCKET_PORT_))\n\n#include \"MW_ArduinoHWInit.h\"\n#ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n#include \"MW_graphicPrimitive.h\"\n#endif\n\n\n\nvoid MW_Modbus_Slave_Poll(void)\n{\n    #if defined(_RTT_MODBUS_SLAVE_)\n    ModbusRTUServer.poll();\n    #endif\n}\n\nvoid MW_ArduinoNano33BLESenseInit(void)\n{\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    initVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    SerialUSB.begin(115200);\n    #endif\n    #if defined(_RTT_PWM_NANO33BLE_INUSE)\n    MW_NANO33BLE_PWM_Setup();\n    #endif\n    #endif\n}\n\nvoid MW_Arduino_Init(void)\n{\n    //Hardware specific init for Arduino nano 33 ble sense\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    MW_ArduinoNano33BLESenseInit();\n    #endif\n    //Disable watchdog for Arduino Due. watchdog\n    #if (defined(_ROTH_DUE_))\n    watchdogDisable();\n    #endif\n    //Disable watchdog for ESP32\n    #if (defined(ESP_PLATFORM))\n    initArduino();\n    disableCore0WDT();\n    #endif\n\n    /*\n    * Initialize Serial Peripheral\n    */\n    // Always Initialize Serial0\n    #if(defined(ESP_PLATFORM))\n    #else\n    Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n    #endif\n\n    /* Overrun Detection Initialization */\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n    pinMode(_RTT_OVERRUN_DIGITAL_PIN_, OUTPUT);\n\n    /* Init the overrun detection pin to zero or else the Pin is always in a\n    * high/tristate giving the user a wrong indication of overrun conditions */\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, LOW);\n    #endif\n\n    /*\n    * Initialize Analog Reference Voltage\n    * Default - Due\n    * Default, Internal 1.1, Internal 2.56, External -  Mega 2560, Mega ADK\n    * Default, Internal, External - Other Arduino targets\n    */\n    #if (defined(_ROTH_MEGA2560_))\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL1V1);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(INTERNAL2V56);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_INTERNAL1V0);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL1V65);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL2V23);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_EXTERNAL);\n    #endif\n    #else\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(EXTERNAL);\n    #endif\n    #endif\n\n    /*\n    * Initialize SPI bus\n    */\n    //_RTT_SPI_SSPIN_ definition is applicable for all boards excluding Due\n    #if defined(_RTT_SPI_SSPIN_)\n    MW_SPIwriteReadSetup();\n    #endif\n\n    //Initialize Modbus\n    int modStatus;\n    #if defined(_RTT_MODBUS_MASTER_)\n    modStatus = ModbusRTUClient.begin(_RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    ModbusRTUClient.setTimeout(_RTT_MODBUS_MASTERTIMEOUT_/1000);\n    #endif\n\n    #if defined(_RTT_MODBUS_SLAVE_)\n    modStatus = ModbusRTUServer.begin(_RTT_MODBUS_SLAVEID_, _RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    #if defined(_RTT_MODBUS_CONFIGCOIL_)\n    ModbusRTUServer.configureCoils(_RTT_MODBUS_COILADDR_,_RTT_MODBUS_COILNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUT_)\n    ModbusRTUServer.configureDiscreteInputs(_RTT_MODBUS_INPUPTADDR_,_RTT_MODBUS_INPUTNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGHOLDINGREG_)\n    ModbusRTUServer.configureHoldingRegisters(_RTT_MODBUS_HOLDINGREGADDR_,_RTT_MODBUS_HOLDINGREGNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUTREG_)\n    ModbusRTUServer.configureInputRegisters(_RTT_MODBUS_INPUTREGADDR_,_RTT_MODBUS_INPUTREGNUM_);\n    #endif\n    #endif\n\n    /*\n    * Initialize wifi\n    */\n    #if (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n    /* Begin WiFi*/\n    while(configureSuccess!=WL_CONNECTED)\n    {\n        #if (defined(_RTT_DISABLE_Wifi_DHCP_) && (_RTT_DISABLE_Wifi_DHCP_ !=0))\n        #ifdef ESP_PLATFORM\n        WiFi.config(wifiLocalIpAddress, wifigateway, subnet, dns1, dns2);\n        #else\n        WiFi.config(wifiLocalIpAddress);\n        #endif\n        #endif\n\n        #ifdef _RTT_WIFI_WEP\n        configureSuccess=WiFi.begin(ssid,keyIndex,key);\n        #endif //_RTT_WIFI_WEP\n\n        #ifdef _RTT_WIFI_WPA\n        configureSuccess=WiFi.begin(ssid,wpapass);\n        #endif //_RTT_WIFI_WPA\n\n        #ifdef _RTT_WIFI_WPA2_ENTERPRISE\n        #if defined(ESP_PLATFORM)\n        WiFi.disconnect(true);  //disconnect form wifi to set new wifi connection\n        WiFi.mode(WIFI_STA); //init wifi mode\n        esp_wifi_sta_wpa2_ent_set_identity((uint8_t *)wpa2username, strlen(wpa2username)); //provide identity\n        esp_wifi_sta_wpa2_ent_set_username((uint8_t *)wpa2username, strlen(wpa2username)); //provide username --> identity and username is same\n        esp_wifi_sta_wpa2_ent_set_password((uint8_t *)wpa2password, strlen(wpa2password)); //provide password\n        esp_wpa2_config_t config = WPA2_CONFIG_INIT_DEFAULT(); //set config settings to default\n        esp_wifi_sta_wpa2_ent_enable(&config); //set config settings to enable function\n        configureSuccess = WiFi.begin(ssid); //connect to wifi\n        #elif defined(ARDUINO_WIFI_LIB_NINA)\n        configureSuccess=WiFi.beginEnterprise(ssid,wpa2username,wpa2password);\n        #endif\n        #endif //_RTT_WIFI_WPA2_ENTERPRISE\n\n        #ifdef _RTT_WIFI_NONE\n        configureSuccess=WiFi.begin(ssid);\n        #endif //_RTT_WIFI_NONE\n\n        #if (defined(ESP_PLATFORM))\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        configureSuccess=WL_CONNECTED;\n        #else\n        //Wait for 10 seconds for Wifi connection to happen\n        unsigned long startMillis  = millis();\n        while(millis()- startMillis < 1000)\n        {\n        };\n        #endif\n    }\n\n    /* Wait for Serial0 to be up*/\n    for(trialcount=0;trialcount<5;trialcount++)\n    {\n        if(Serial)\n        {\n            break;\n        }else\n        {\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 1000)\n            {\n            };\n        }\n    }\n\n    #if (!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n    if (configureSuccess==WL_CONNECTED)\n    {\n        // If the Configuration is successful, relay back the assigned IP address.\n        #if(defined(ESP_PLATFORM))\n        Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n        #endif\n        IPAddress ip = WiFi.localIP();\n        Serial.print(\"<<< IP address :\");\n        Serial.print(ip);\n        Serial.println(\" >>>\");\n    }\n    else\n    {\n        // If the Configuration failed,relay back the error message.\n        Serial.println(\"<<< IP address :Failed to configure. >>>\");\n    }\n    #endif //(!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n\n    #endif /*Initialize wifi*/\n    #ifdef NANO_MOTOR_CARRIER\n    MW_EnableNanoCarrierBatteryCharging();\n    #endif\n    #ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n    MW_initScreen();\n    #endif\n}\n/* Function: MW_Arduino_Terminate ================================================\n* For Arduino MKR/Leonardo and its variants, the Virtual COM port is handled\n* by the controller. In case the code running on the target exits main,\n* the COM port cannot be accessed until a hard reset is performed.\n* To over come this issue, a while loop is added to make sure that\n* upon getting a stop command from external mode, the code running on\n* the target stops but the code will not exit the main.\n* This will ensure that the COM port is accessible even after the\n* external mode has been stopped. */\nvoid MW_Arduino_Terminate(void){\n    #if defined(ARDUINO_VIRTUAL_COM_PORT) || (defined(ARDUINO_ARDUINO_NANO33BLE) && (!defined(USE_MBEDRTOS)))\n    disable_rt_OneStep();\n    while(1){};     /* To continue virtual COM port functionality */\n    #endif\n}\n\n#ifdef NANO_MOTOR_CARRIER\nvoid MW_EnableNanoCarrierBatteryCharging(void) {\n    Wire.begin();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG00);\n    Wire.write(0x06); // min sys voltage 3.88V + max input current 2.0 A\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG01);\n    Wire.write(0x1B); // Charge Battery + Minimum System Voltage 3.5V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG02);\n    Wire.write(0x00); // Charge current  512 mA\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG04);\n    Wire.write(0x9E); // Charge Voltage Limit 4.128V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG05);\n    Wire.write(0x8A); // Enable Battery Charge termination + disable watchdog\n    Wire.endTransmission();\n}\n#endif\n\n\n// Overrun detection function for ESP32\n#if defined(ESP_PLATFORM) && defined(_RTT_OVERRUN_DIGITAL_PIN_)\nvoid onOverrunDetect(int id)\n{\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n}\n#endif\n// LocalWords:  AVR Bareboard ADK SPI RTT SSPIN Modbus MKR"},{"name":"MW_PWM.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2021 The MathWorks, Inc. */\n\n#include \"MW_PWM.h\"\n#include \"MW_PWMDriver.h\"\n\n#if (defined(ESP_PLATFORM))\n//#include \"soc/soc_caps.h\" This file is present in new core of esp32. Uncomment and remove SOC_GPIO_PIN_COUNT defination once esp32 core is updated\n#define SOC_GPIO_PIN_COUNT              40\n#endif\n\n#if !(( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) ))\n#include \"Arduino.h\"\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n\n#if (defined(ARDUINO_ARDUINO_NANO33BLE))\nuint32_t nano33BLE_dutycycle[21];\nuint16_t nano33BLE_period[21];\n#endif\n\ntypedef uint8_T PeripheralHandleMapType;\nextern PeripheralHandleMapType PWMPinHandleMap[];     /* The array is defined in ArduinoPinHandleMap.cpp */\n\n/* For PWM SVd provides no function to get the handle */\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin);\nvoid setPWMHandle(uint32_T Pin, MW_Handle_Type handle);\n\n#if (defined(ESP_PLATFORM))\n#define ESP32_PWM_RESOLUTION            8\n#if (defined(_RTT_NUMSERVOS_) && (_RTT_NUMSERVOS_ != 0))\n#define LAST_CHAN (8)\n#else\n#define LAST_CHAN (16)\n#endif\nstatic int8_t pin_to_channel[SOC_GPIO_PIN_COUNT] = { 0 };\nstatic int channelCounter = LAST_CHAN;\n#endif\n\n/* PWM Initialisation selected by the pinNumber (PWM Channel) */\nMW_Handle_Type MW_PWM_Open(uint32_T pin, real_T prescaler, real_T period)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    /* This will be run in Rapid Accelerator Mode */\n    return NULL;\n    #else\n    #if (defined(ESP_PLATFORM))\n    if (pin < SOC_GPIO_PIN_COUNT) {\n        if (pin_to_channel[pin] == 0) {\n            if (!channelCounter) {\n                log_e(\"No more analogWrite channels available! You can have maximum %u\", LAST_CHAN);\n                return 0;\n            }\n            pinMode(pin,OUTPUT);\n            pin_to_channel[pin] = channelCounter ;\n            ledcAttachPin(pin, channelCounter-1);\n            if(prescaler == 0)                    // Default frequency\n            {\n                ledcSetup(channelCounter-1, ARDUINO_DEFAULT_PWM_FREQUENCY, ESP32_PWM_RESOLUTION);\n            }\n            else\n            {\n                ledcSetup(channelCounter-1, prescaler, ESP32_PWM_RESOLUTION);\n            }\n            #ifdef _RTT_PWM_CUSTOM_FREQUENCY_\n            channelCounter = channelCounter-2;    // Use only one channel from channel pair\n            #else\n            channelCounter = channelCounter-1;\n            #endif\n        }\n        ledcWrite(pin_to_channel[pin] - 1, 0);\n    }else{\n        return 0;\n    }\n    setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n    return (MW_Handle_Type)(pin+1);\n    #else\n    pinMode(pin,OUTPUT);\n\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    nano33BLE_dutycycle[pin] = 0;\n    nano33BLE_period[pin] = 1000000/500;\n    #endif\n\n    /* handle is stored as Pin+1 because, to reset the handle of a pin, 0 is passed as handle. Otherwise it will create confusion for Pin number 0. */\n    setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n\n    if(period>0) /*No initialization in case of Default frequnecy*/\n    {\n        MW_setAnalogFrequency(pin, prescaler,period);\n    }\n    return (MW_Handle_Type)(pin+1);\n    #endif\n    #endif\n}\n\n/* Start PWM */\nvoid MW_PWM_Start(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Set the duty cycle or pulse width for the PWM signal */\nvoid MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    /* This will be run in Rapid Accelerator Mode */\n    (void)PWMPinHandle;\n    (void)dutyCycle;\n    return;\n    #else\n    #if (defined(ESP_PLATFORM))\n    uint8_T pin;\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        if(dutyCycle < 0)       /* Changed frequency */\n        {\n            dutyCycle = dutyCycle * -1;\n        }\n        ledcWrite(pin_to_channel[pin] - 1, dutyCycle);\n    }\n    #else\n    uint8_T pin;\n    /* If the PWM handle is 0 then do nothing. */\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        if(dutyCycle < 0)       /* Changed frequency*/\n        {\n            dutyCycle = dutyCycle * -1;\n            MW_analogWrite(pin, dutyCycle);\n        }\n        else                    /* Default frequency*/\n        {\n            #if !(defined(ARDUINO_ARDUINO_NANO33BLE))\n            analogWrite(pin, dutyCycle);\n            #else\n            nano33BLE_period[pin] = 1000000/500; //Default frequency of 500Hz\n            nano33BLE_dutycycle[pin] = (dutyCycle* nano33BLE_period[pin]/255);\n            #endif\n        }\n    }\n    #endif\n    #endif\n}\n\n/* Set the PWM signal frequency */\nvoid MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency)\n{\n    (void)PWMPinHandle;\n    (void)frequency;\n}\n\n/* Disable notifications on the channel */\nvoid MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Enable notifications on the channel */\nvoid MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification)\n{\n    (void)PWMPinHandle;\n    (void)Notification;\n}\n\n/* Set PWM output to idle state */\nvoid MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Get the PWM output status */\nboolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n    return 0;\n}\n\n/* Stop PWM */\nvoid MW_PWM_Stop(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Close PWM */\nvoid MW_PWM_Close(MW_Handle_Type PWMPinHandle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return;\n    #else\n    /* If the PWM handle is 0 then do nothing. */\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        uint8_T pin = 0;\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        setPWMHandle(pin, (MW_Handle_Type)0);\n    }\n    (void)PWMPinHandle;\n    #endif\n}\n\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return NULL;\n    #else\n    uint16_T ByteNo=0, handleValue=0;\n\n    uint8_T BitPositionNo=0;\n\n    ByteNo = Pin/8;\n    BitPositionNo = Pin%8;\n\n    handleValue = PWMPinHandleMap[ByteNo] & (PeripheralHandleMapType)(1<<BitPositionNo);\n\n    if(handleValue)\n    {\n        /*\n        Returns the value of the module if the pin is opened earlier\n        */\n        handleValue = Pin+1;\n        /*\n        This allows to differentiate between pin zero and a Null condition\n\n        Another option - return true, and then remove the decrement in the SVD of all functions in Arduino\n        */\n    }\n    else\n    {\n        handleValue = 0;\n    }\n    return (MW_Handle_Type)handleValue;\n    #endif\n}\n\nvoid setPWMHandle(uint32_T module, MW_Handle_Type handle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return;\n    #else\n    /*\n    Assumes pin number from count zero\n    */\n    uint16_T ByteNo=0;\n    uint8_T BitPositionNo=0;\n    PeripheralHandleMapType tempVar=0;\n    /*\n    Integer division rounds off to value providing the abs byte no\n    */\n    ByteNo = module/8;\n    BitPositionNo = module%8;\n\n    tempVar = (1<<BitPositionNo);\n    /*\n    The assumption is module number is the handle,\n    but when handle is Null, reset the handle\n    */\n    if(!handle)\n    {\n        /*reset the handle*/\n        tempVar = ~tempVar;\n        PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] & tempVar;\n    }\n    else\n    {\n        /*set the handle*/\n        PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] | tempVar;\n    }\n    #endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n#else\nMW_Handle_Type MW_PWM_Open(uint32_T pin, real_T frequency, real_T dutyCycle){return 0;}\nvoid MW_PWM_Start(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle){}\nvoid MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency){}\nvoid MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification){}\nvoid MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle){}\nboolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle){return 0;}\nvoid MW_PWM_Stop(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_Close(MW_Handle_Type PWMPinHandle){}\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin){return 0;}\n#endif\n"},{"name":"MW_PWMDriver.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Code to configure Timer and set duty cycle\n * This file is modified version of wiring_analog.c file\n * It separates analogWrite function into two parts:\n * 1. MW_setAnalogFrequency: This function initializes PWM peripheral\n * 2. MW_analogWrite: This function sets the duty cycle\n * /* Copyright 2019 The MathWorks, Inc. */\n\n#include \"MW_PWMDriver.h\"\n\n#if !( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n\n#if defined(ARDUINO_ARCH_SAMD)                                                          /* SAMD Targets */\n#include \"Arduino.h\"\n#include \"wiring_private.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncDAC() __attribute__((always_inline, unused));\nstatic void syncDAC() {\n  while (DAC->STATUS.bit.SYNCBUSY == 1)\n    ;\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));\nstatic void syncTC_8(Tc* TCx) {\n  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));\nstatic void syncTCC(Tcc* TCCx) {\n  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);\n}\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG)\n  {\n    // DAC handling code\n\n    if ((pinDesc.ulADCChannelNumber != ADC_Channel0) && (pinDesc.ulADCChannelNumber != DAC_Channel0)) { // Only 1 DAC on AIN0 / PA02\n      return;\n    }\n\n    value = mapResolution(value, _writeResolution, 10);\n\n    syncDAC();\n    DAC->DATA.reg = value & 0x3FF;  // DAC on 10 bits.\n    syncDAC();\n    DAC->CTRLA.bit.ENABLE = 0x01;     // Enable DAC\n    syncDAC();\n    return;\n  }\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    \n    if (tcNum >= TCC_INST_NUM) {\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n    } else {\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        TCCx->CTRLBSET.bit.LUPD = 1;\n        syncTCC(TCCx);\n        TCCx->CCB[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        TCCx->CTRLBCLR.bit.LUPD = 1;\n        syncTCC(TCCx);\n    }\n    return;\n  }\n\n  // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n  uint32_t value = 0;                 //TODO: Get this value from caller\n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n    static bool tcEnabled[TCC_INST_NUM+TC_INST_NUM];\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    if (!tcEnabled[tcNum]) {\n      tcEnabled[tcNum] = true;\n\n      uint16_t GCLK_CLKCTRL_IDs[] = {\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC0\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC1\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TCC2\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TC3\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC4\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC5\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC6\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC7\n      };\n      GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_IDs[tcNum]);\n      while (GCLK->STATUS.bit.SYNCBUSY == 1);\n\n      // Set PORT\n      if (tcNum >= TCC_INST_NUM) {\n        // -- Configure TC\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 0;\n        syncTC_8(TCx);\n        // Set Timer counter Mode to 16 bits, normal PWM\n        TCx->COUNT8.CTRLA.reg |= TC_CTRLA_MODE_COUNT8 | TC_CTRLA_WAVEGEN_NPWM | (prescaler<<8);\n        syncTC_8(TCx);\n        // Set the initial value\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n        TCx->COUNT8.PER.reg = period - 1;\n        syncTC_8(TCx);\n        // Enable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 1;\n        syncTC_8(TCx);\n      } else {\n        // -- Configure TCC\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCCx\n        TCCx->CTRLA.bit.ENABLE = 0;\n        syncTCC(TCCx);\n        // Prescaler\n        TCCx->CTRLA.reg |= (prescaler<<8);\n        syncTCC(TCCx);\n        // Set TCCx as normal PWM\n        TCCx->WAVE.reg |= TCC_WAVE_WAVEGEN_NPWM;\n        syncTCC(TCCx);\n        // Set the initial value\n        TCCx->CC[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        // Set PER to maximum counter value (resolution : 0xFFFF)\n        TCCx->PER.reg = period - 1;\n        syncTCC(TCCx);\n        // Enable TCCx\n        TCCx->CTRLA.bit.ENABLE = 1;\n        syncTCC(TCCx);\n      }\n    }\n    return;\n  }\n    // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"Arduino.h\"\n#include \"pins_arduino.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\nextern uint32_t nano33BLE_dutycycle[21];\nextern uint16_t nano33BLE_period[21];\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  nano33BLE_dutycycle[pin] = value;\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    nano33BLE_period[pin] = period;\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARCH_AVR)                                                         /* AVR Targets */\n#include \"wiring_private.h\"\n#include \"pins_arduino.h\"\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n    analogWrite(pin, value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    switch(digitalPinToTimer(pin))\n    {\n        // XXX fix needed for atmega8\n        #if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)\n        case TIMER0A:\n            // connect pwm to pin on timer 0\n            sbi(TCCR0, COM00);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0A1)\n        case TIMER0A:\n            // connect pwm to pin on timer 0, channel A\n            sbi(TCCR0A, COM0A1);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0B1)\n        case TIMER0B:\n            // connect pwm to pin on timer 0, channel B\n            sbi(TCCR0A, COM0B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1A1)\n        case TIMER1A:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1A1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1B1)\n        case TIMER1B:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1C1)\n        case TIMER1C:\n            // connect pwm to pin on timer 1, channel B\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1C1);\n            break;\n        #endif\n\n        #if defined(TCCR2) && defined(COM21)\n        case TIMER2:\n            // connect pwm to pin on timer 2\n            sbi(TCCR2, COM21);\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2A1)\n        case TIMER2A:\n            // connect pwm to pin on timer 2, channel A\n            sbi(TCCR2A, COM2A1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2B1)\n        case TIMER2B:\n            // connect pwm to pin on timer 2, channel B\n            sbi(TCCR2A, COM2B1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3A1)\n        case TIMER3A:\n            // connect pwm to pin on timer 3, channel A\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3A1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3B1)\n        case TIMER3B:\n            // connect pwm to pin on timer 3, channel B\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3B1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3C1)\n        case TIMER3C:\n            // connect pwm to pin on timer 3, channel C\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3C1);\n            break;\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4A1) && defined(COM4A0)/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4A:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4A1);\n            cbi(TCCR4A, COM4A0);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4A1)\n        case TIMER4A:\n            //connect pwm to pin on timer 4, channel A\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4A1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4B1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4B:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4B1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4B1)    \n        case TIMER4B:\n            // connect pwm to pin on timer 4, channel B\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4B1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4C1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4C:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4C1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4C1)    \n        case TIMER4C:\n            // connect pwm to pin on timer 4, channel C\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4C1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4D1) && defined(COM4D0)\t/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4D:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            cbi(TCCR4C, COM4D0);\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4C) && defined(COM4D1)\n        case TIMER4D:\t\t\t\t\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            #if defined(COM4D0)\t\t// only used on 32U4\n            cbi(TCCR4C, COM4D0);\n            #endif\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5A1)\n        case TIMER5A:\n            // connect pwm to pin on timer 5, channel A\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5A1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5B1)\n        case TIMER5B:\n            // connect pwm to pin on timer 5, channel B\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5B1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5C1)\n        case TIMER5C:\n            // connect pwm to pin on timer 5, channel C\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5C1);\n            break;\n        #endif\n    }\n    digitalWrite(pin, LOW);\n}\n\n#elif defined(ARDUINO_ARCH_SAM)                                                         /* SAM Targets */\n#include \"Arduino.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \nstatic int _writeResolution = 8;\nstatic uint8_t PWMEnabled = 0;\nstatic uint8_t TCChanEnabled[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to) {\n\tif (from == to)\n\t\treturn value;\n\tif (from > to)\n\t\treturn value >> (from-to);\n\telse\n\t\treturn value << (to-from);\n}\n\nstatic void TC_SetCMR_ChannelA(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xFFF0FFFF) | v;\n}\n\nstatic void TC_SetCMR_ChannelB(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xF0FFFFFF) | v;\n}\n\nvoid MW_analogWrite(uint32_t ulPin, uint32_t ulValue)\n{\n\tuint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n\n\tif ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG) {\n\t\tEAnalogChannel channel = g_APinDescription[ulPin].ulADCChannelNumber;\n\t\tif (channel == DA0 || channel == DA1) {\n\t\t\tuint32_t chDACC = ((channel == DA0) ? 0 : 1);\n\t\t\tif (dacc_get_channel_status(DACC_INTERFACE) == 0) {\n\t\t\t\t/* Enable clock for DACC_INTERFACE */\n\t\t\t\tpmc_enable_periph_clk(DACC_INTERFACE_ID);\n\n\t\t\t\t/* Reset DACC registers */\n\t\t\t\tdacc_reset(DACC_INTERFACE);\n\n\t\t\t\t/* Half word transfer mode */\n\t\t\t\tdacc_set_transfer_mode(DACC_INTERFACE, 0);\n\n\t\t\t\t/* Power save:\n\t\t\t\t * sleep mode  - 0 (disabled)\n\t\t\t\t * fast wakeup - 0 (disabled)\n\t\t\t\t */\n\t\t\t\tdacc_set_power_save(DACC_INTERFACE, 0, 0);\n\t\t\t\t/* Timing:\n\t\t\t\t * refresh        - 0x08 (1024*8 dacc clocks)\n\t\t\t\t * max speed mode -    0 (disabled)\n\t\t\t\t * startup time   - 0x10 (1024 dacc clocks)\n\t\t\t\t */\n\t\t\t\tdacc_set_timing(DACC_INTERFACE, 0x08, 0, 0x10);\n\n\t\t\t\t/* Set up analog current */\n\t\t\t\tdacc_set_analog_control(DACC_INTERFACE, DACC_ACR_IBCTLCH0(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLCH1(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLDACCORE(0x01));\n\t\t\t}\n\n\t\t\t/* Disable TAG and select output channel chDACC */\n\t\t\tdacc_set_channel_selection(DACC_INTERFACE, chDACC);\n\n\t\t\tif ((dacc_get_channel_status(DACC_INTERFACE) & (1 << chDACC)) == 0) {\n\t\t\t\tdacc_enable_channel(DACC_INTERFACE, chDACC);\n\t\t\t}\n\n\t\t\t// Write user value\n\t\t\tulValue = mapResolution(ulValue, _writeResolution, DACC_RESOLUTION);\n\t\t\tdacc_write_conversion_data(DACC_INTERFACE, ulValue);\n\t\t\twhile ((dacc_get_interrupt_status(DACC_INTERFACE) & DACC_ISR_EOC) == 0);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n        uint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\t//ulValue = mapResolution(ulValue, _writeResolution, PWM_RESOLUTION);\n\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, ulValue);\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (ulValue == 0) {\n\t\t\tif (chA)\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR);\n\t\t\telse\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t} else {\n\t\t\tif (chA) {\n\t\t\t\tTC_SetRA(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_SET);\n\t\t\t} else {\n\t\t\t\tTC_SetRB(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_SET);\n\t\t\t}\n\t\t}\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Defaults to digital write\n\tpinMode(ulPin, OUTPUT);\n\tulValue = mapResolution(ulValue, _writeResolution, 8);\n\tif (ulValue < 128)\n\t\tdigitalWrite(ulPin, LOW);\n\telse\n\t\tdigitalWrite(ulPin, HIGH);\n}\nvoid MW_setAnalogFrequency(uint16_t ulPin,uint16_t prescaler,uint16_t period)\n{\n    uint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n\t\tif (!PWMEnabled) {\n\t\t\t// PWM Startup code\n\t\t    pmc_enable_periph_clk(PWM_INTERFACE_ID);\n\t\t    PWMC_ConfigureClocks(PWM_FREQUENCY * PWM_MAX_DUTY_CYCLE, 0, VARIANT_MCK);\n\t\t\tPWMEnabled = 1;\n\t\t}\n\n\t\tuint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\t// Setup PWM for this pin\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tPWMC_ConfigureChannel(PWM_INTERFACE, chan, prescaler, 0, 0);\n\t\t\tPWMC_SetPeriod(PWM_INTERFACE, chan, period);\n\t\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, 0);\n\t\t\tPWMC_EnableChannel(PWM_INTERFACE, chan);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// We use MCLK/2 as clock.\n\t\tconst uint32_t TC = period;\n\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tpmc_enable_periph_clk(TC_INTERFACE_ID + interfaceID);\n\t\t\tTC_Configure(chTC, chNo,\n\t\t\t\tprescaler |\n\t\t\t\tTC_CMR_WAVE |         // Waveform mode\n\t\t\t\tTC_CMR_WAVSEL_UP_RC | // Counter running up and reset when equals to RC\n\t\t\t\tTC_CMR_EEVT_XC0 |     // Set external events from XC0 (this setup TIOB as output)\n\t\t\t\tTC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR |\n\t\t\t\tTC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t\tTC_SetRC(chTC, chNo, TC);\n\t\t}\n\t\t\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tTC_Start(chTC, chNo);\n\t\t\tTCChanEnabled[interfaceID] = 1;\n\t\t}\n\t\treturn;\n\t}\n}\n\n#ifdef __cplusplus\n}\n#endif\n#endif                                                                                  /* Architecture selection endif*/                                                                             \n\n#endif /*Rapid Accel condition check*/\n/* [EOF] */"},{"name":"MW_SerialRead.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2023 The MathWorks, Inc. */\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"MW_SerialRead.h\"\n#include \"io_wrappers.h\"\n\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" {\n\tuint32_t getCurrentTime(){\n\t\treturn millis();\n\t}\n}\n\n// Serial Read functions\nextern \"C\" void MW_Serial0_read(char *bufferData,const uint16_t DataSizeInBytes)\n{\n    Serial.readBytes(bufferData,DataSizeInBytes);\n}\n\nextern \"C\" int MW_Serial0_available()\n{\n    int BufferSize;\n    BufferSize = Serial.available();\n    return(BufferSize);    \n}\n\n#if defined(ARDUINO_NUM_SERIAL_PORTS)\n    #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n        extern \"C\" void MW_Serial1_read(char *bufferData,const uint16_t DataSizeInBytes)\n        {\n            Serial1.readBytes(bufferData,DataSizeInBytes);\n        }\n\n        extern \"C\" int MW_Serial1_available()\n        {\n            int BufferSize;\n            BufferSize = Serial1.available();\n            return(BufferSize);\n        }\n    #endif\n    #if(ARDUINO_NUM_SERIAL_PORTS > 2)\n        extern \"C\" void MW_Serial2_read(char *bufferData,const uint16_t DataSizeInBytes)\n        {\n            Serial2.readBytes(bufferData,DataSizeInBytes);\n        }\n\n        extern \"C\" int MW_Serial2_available()\n        {\n            int BufferSize;\n            BufferSize = Serial2.available();\n            return(BufferSize);\n        }\n    #endif\n\n    #if(ARDUINO_NUM_SERIAL_PORTS > 3)\n        extern \"C\" void MW_Serial3_read(char *bufferData,const uint16_t DataSizeInBytes)\n        {\n            Serial3.readBytes(bufferData,DataSizeInBytes);\n        }\n\n        extern \"C\" int MW_Serial3_available()\n        {\n            int BufferSize;\n            BufferSize = Serial3.available();\n            return(BufferSize);\n        }\n    #endif\n#endif\n\n#if defined(ARDUINO_NUM_SERIAL_PORTS)\nextern \"C\" int getNumbytesAvailable(const uint8_T port){\n\t/* This function is used only during code generation from MATLAB IO API. */\n\tif(port == 0){\n\t\treturn MW_Serial0_available();\n\t}\n\t#if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n\t\tif (port == 1){\n\t\t\treturn MW_Serial1_available();\n\t\t}\n\t#endif\n\t#if(ARDUINO_NUM_SERIAL_PORTS > 2)\n\t\tif (port == 2){\n\t\t\treturn MW_Serial2_available();\n\t\t}\n\t#endif\n\t#if(ARDUINO_NUM_SERIAL_PORTS > 3)\n\t\tif (port == 3){\n\t\t\treturn MW_Serial3_available();\n\t\t}\n\t#endif\n\treturn 0;\n}\n#endif\n        \n        \n#if defined(ARDUINO_NUM_SERIAL_PORTS)\n    #if(ARDUINO_NUM_SERIAL_PORTS > 3)\n        void (*read_func_ptr[])(char *, uint16_t) = {MW_Serial0_read, MW_Serial1_read, MW_Serial2_read, MW_Serial3_read};\n        int (*available_func_ptr[])() = {MW_Serial0_available,MW_Serial1_available,MW_Serial2_available,MW_Serial3_available};\n    #elif(ARDUINO_NUM_SERIAL_PORTS > 2)\n        void (*read_func_ptr[])(char *, uint16_t) = {MW_Serial0_read, MW_Serial1_read, MW_Serial2_read};\n        int (*available_func_ptr[])() = {MW_Serial0_available,MW_Serial1_available,MW_Serial2_available};\n    #elif(ARDUINO_NUM_SERIAL_PORTS == 2)\n        void (*read_func_ptr[])(char *, uint16_t) = {MW_Serial0_read, MW_Serial1_read};\n        int (*available_func_ptr[])() = {MW_Serial0_available,MW_Serial1_available};\n    #else\n        void (*read_func_ptr[])(char *, uint16_t) = {MW_Serial0_read};\n        int (*available_func_ptr[])() = {MW_Serial0_available};\n    #endif\n#else\n    void (*read_func_ptr[])(char *, uint16_t) = {MW_Serial0_read};\n    int (*available_func_ptr[])() = {MW_Serial0_available};\n#endif\n\n\nextern \"C\" void fillDataBuffer(const uint8_T port,const uint16_t DataSizeInBytes,char *data,uint8_T *status)\n{\n    char databuffer[2*DataSizeInBytes];    \n    (*read_func_ptr[port])(databuffer,DataSizeInBytes);\n    for(int ii=0;ii< DataSizeInBytes;ii++)\n    {\n        *data++ = databuffer[ii];\n    }\n    *status = 1;\n}\n\n\n\nextern \"C\" void MW_Serial_read(const uint8_T port,const uint16_t DataSizeInBytes, char *data,uint8_T *status)\n{    \n    int dataSizeinBuffer;\n    #if defined(ARDUINO_ARCH_AVR) || defined(ARDUINO_ARCH_MBED)\n        char tempdatabuffer[64];\n    #elif defined(ARDUINO_ARCH_SAM)\n        char tempdatabuffer[128];\n    #else //for (ARDUINO_ARCH_SAMD) and (ESP_PLATFORM)\n        char tempdatabuffer[256];\n    #endif    \n        \n    /* Read the size of data available in the Arduino Serial buffer */\n    dataSizeinBuffer = (*available_func_ptr[port])();\n    if (dataSizeinBuffer == DataSizeInBytes)\n    {\n        /* If the size of data in buffer == required data size, data=received data and status =1 */\n        fillDataBuffer(port,DataSizeInBytes,data,status);\n    }\n    else if ( dataSizeinBuffer >= DataSizeInBytes)\n    {\n        if (dataSizeinBuffer <= 2*DataSizeInBytes)\n        {\n            /* If the size of data in buffer > required data size and < 2*required data size, data=received data(of the rqquired size) and status =1 */\n            fillDataBuffer(port,DataSizeInBytes,data,status);\n        }\n        else\n        {\n            /* If the size of data in buffer >  2*required data size, trash data till size of data in buffer < 2*required data size.data=received data and status =1 */\n            (*read_func_ptr[port])(tempdatabuffer,(((dataSizeinBuffer/DataSizeInBytes)-1)*DataSizeInBytes));\n            fillDataBuffer(port,DataSizeInBytes,data,status);\n        }\n    }\n    else\n    {\n        /* If the size of data in buffer < required data size, data=0's  and status =0 */\n        for(int ii=0;ii< DataSizeInBytes;ii++)\n        {\n            *data++ = 0;\n        }\n        *status = 0;\n    }\n}\n\n"},{"name":"MW_SerialWrite.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":" /* Copyright 2015-2021 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"MW_SerialWrite.h\"\n#include \"io_wrappers.h\"\n\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\n// One-time initialization\nextern \"C\" void MW_SCI_Open(const uint8_T port){\n    if (port==0){\n        #if(defined(ESP_PLATFORM))\n            static uint8_t esp32_serial0_init_f=0;\n            if(esp32_serial0_init_f==0){\n                Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n                esp32_serial0_init_f=1;\n            }\n        #endif\n        // Module 0 is by default initialized by MW_Arduino_Init function\n        return;\n    }\n    switch(port){\n        case 1:\n            #if defined(_RTT_BAUDRATE_SERIAL1_)\n            Serial_begin(1, _RTT_BAUDRATE_SERIAL1_, _RTT_CONFIG_SERIAL1_);\n            #endif\n            break;\n        case 2:\n            #if defined(_RTT_BAUDRATE_SERIAL2_)\n            Serial_begin(2, _RTT_BAUDRATE_SERIAL2_, _RTT_CONFIG_SERIAL2_);\n            #endif\n            break;\n        case 3:\n            #if defined(_RTT_BAUDRATE_SERIAL3_)\n            Serial_begin(3, _RTT_BAUDRATE_SERIAL3_, _RTT_CONFIG_SERIAL3_);\n            #endif\n            break;\n        default:\n            break;\n    }\n}\nextern \"C\" void MW_Serial_write(const uint8_T port, void *dataInput, size_t s,const uint8_T dataSizeInBytes, \\\n        const uint8_T sendModeEnum, const uint8_T dataType, const uint8_T sendFormatEnum, \\\n        const uint8_T floatprecision, char* label)\n{\n    int dataSize=dataSizeInBytes;\n    unsigned int counter = s;\n    int base;\n    \n#if !(defined(ARDUINO_ARM)|| defined(ARDUINO_ARDUINO_NANO33BLE))\n    if (dataSize==8){\n        dataSize=4;\n    }\n#endif\n    \n    if (sendFormatEnum == 0) { //DEC\n        base=DEC;\n    }\n    else if(sendFormatEnum == 1) { //HEX\n        base=HEX;\n    }\n    else if(sendFormatEnum == 2) { //OCT\n        base=OCT;\n    }\n    else { //BIN\n        base=BIN;\n    }\n    \n    switch(port) {\n        case 0:\n            if (sendModeEnum == 0)\n            {\n                Serial.write((uint8_t *)dataInput,(s*dataSize));\n            }\n            else\n            {\n                Serial.print(label);\n                if(dataType == 0)\n                {\n                    uint8_t * ptr = (uint8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial.println(*(ptr++),base);\n                        }\n                        \n                    }\n                } //uint8\n                else if(dataType == 1)\n                {\n                    uint16_t * ptr = (uint16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial.println(*(ptr++),base);\n                        }\n                    }\n                } //uint16\n                else if(dataType == 2)\n                {\n                    uint32_t * ptr = (uint32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial.println(*(ptr++),base);\n                        }\n                    }\n                } //uint32\n                else if(dataType == 3)\n                {\n                    int8_t * ptr = (int8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial.println(*(ptr++),base);\n                        }\n                    }\n                } //int8\n                else if(dataType == 4)\n                {\n                    int16_t * ptr = (int16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial.println(*(ptr++),base);\n                        }\n                    }\n                } //int16\n                else if(dataType == 5)\n                {\n                    int32_t * ptr = (int32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial.println(*(ptr++),base);\n                        }\n                    }\n                } //int32\n                else if(dataType == 6)\n                {\n                    double * ptr = (double *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                          Serial.print(*(ptr++),floatprecision); // for double and single, DE is the only supported mode                          \n                        }\n                        else\n                        {\n                           Serial.println(*(ptr++),floatprecision);   // for double and single, DE is the only supported mode                      \n                        }\n                    }\n                } //double, single\n            } //print and println\n            break;\n#if defined(ARDUINO_NUM_SERIAL_PORTS)\n    #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n        case 1:\n            if (sendModeEnum == 0)\n            {\n                Serial1.write((uint8_t *)dataInput,(s*dataSize));\n            }\n            else\n            {\n                Serial1.print(label);\n                if(dataType == 0)\n                {\n                    uint8_t * ptr = (uint8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial1.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial1.println(*(ptr++),base);\n                        }\n                        \n                    }\n                } //uint8\n                else if(dataType == 1)\n                {\n                    uint16_t * ptr = (uint16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial1.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial1.println(*(ptr++),base);\n                        }\n                    }\n                } //uint16\n                else if(dataType == 2)\n                {\n                    uint32_t * ptr = (uint32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial1.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial1.println(*(ptr++),base);\n                        }\n                    }\n                } //uint32\n                else if(dataType == 3)\n                {\n                    int8_t * ptr = (int8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial1.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial1.println(*(ptr++),base);\n                        }\n                    }\n                } //int8\n                else if(dataType == 4)\n                {\n                    int16_t * ptr = (int16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial1.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial1.println(*(ptr++),base);\n                        }\n                    }\n                } //int16\n                else if(dataType == 5)\n                {\n                    int32_t * ptr = (int32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial1.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial1.println(*(ptr++),base);\n                        }\n                    }\n                } //int32\n                else if(dataType == 6)\n                {\n                    double * ptr = (double *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            if (sendFormatEnum == 0) { //DEC\n                                Serial1.print(*(ptr++),floatprecision);\n                            }\n                            else { //HEX, OCT, BIN\n                                Serial1.print((long)*(ptr++),base);\n                            }\n                        }\n                        else\n                        {\n                            if (sendFormatEnum == 0) { //DEC\n                                Serial1.println(*(ptr++),floatprecision);\n                            }\n                            else { //HEX, OCT, BIN\n                                Serial1.println((long)*(ptr++),base);\n                            }\n                        }\n                    }\n                } //double, single\n            } //print and println\n            break;\n    #endif\n    #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n        case 2:\n            if (sendModeEnum == 0)\n            {\n                Serial2.write((uint8_t *)dataInput,(s*dataSize));\n            }\n            else\n            {\n                Serial2.print(label);\n                if(dataType == 0)\n                {\n                    uint8_t * ptr = (uint8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial2.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial2.println(*(ptr++),base);\n                        }\n                        \n                    }\n                } //uint8\n                else if(dataType == 1)\n                {\n                    uint16_t * ptr = (uint16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial2.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial2.println(*(ptr++),base);\n                        }\n                    }\n                } //uint16\n                else if(dataType == 2)\n                {\n                    uint32_t * ptr = (uint32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial2.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial2.println(*(ptr++),base);\n                        }\n                    }\n                } //uint32\n                else if(dataType == 3)\n                {\n                    int8_t * ptr = (int8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial2.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial2.println(*(ptr++),base);\n                        }\n                    }\n                } //int8\n                else if(dataType == 4)\n                {\n                    int16_t * ptr = (int16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial2.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial2.println(*(ptr++),base);\n                        }\n                    }\n                } //int16\n                else if(dataType == 5)\n                {\n                    int32_t * ptr = (int32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial2.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial2.println(*(ptr++),base);\n                        }\n                    }\n                } //int32\n                else if(dataType == 6)\n                {\n                    double * ptr = (double *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            if (sendFormatEnum == 0) { //DEC\n                                Serial2.print(*(ptr++),floatprecision);\n                            }\n                            else { //HEX, OCT, BIN\n                                Serial2.print((long)*(ptr++),base);\n                            }\n                        }\n                        else\n                        {\n                            if (sendFormatEnum == 0) { //DEC\n                                Serial2.println(*(ptr++),floatprecision);\n                            }\n                            else { //HEX, OCT, BIN\n                                Serial2.println((long)*(ptr++),base);\n                            }\n                        }\n                    }\n                } //double, single\n            } //print and println\n            break;\n    #endif\n    #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n        case 3:\n            if (sendModeEnum == 0)\n            {\n                Serial3.write((uint8_t *)dataInput,(s*dataSize));\n            }\n            else\n            {\n                Serial3.print(label);\n                if(dataType == 0)\n                {\n                    uint8_t * ptr = (uint8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial3.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial3.println(*(ptr++),base);\n                        }\n                        \n                    }\n                } //uint8\n                else if(dataType == 1)\n                {\n                    uint16_t * ptr = (uint16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial3.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial3.println(*(ptr++),base);\n                        }\n                    }\n                } //uint16\n                else if(dataType == 2)\n                {\n                    uint32_t * ptr = (uint32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial3.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial3.println(*(ptr++),base);\n                        }\n                    }\n                } //uint32\n                else if(dataType == 3)\n                {\n                    int8_t * ptr = (int8_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial3.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial3.println(*(ptr++),base);\n                        }\n                    }\n                } //int8\n                else if(dataType == 4)\n                {\n                    int16_t * ptr = (int16_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial3.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial3.println(*(ptr++),base);\n                        }\n                    }\n                } //int16\n                else if(dataType == 5)\n                {\n                    int32_t * ptr = (int32_t *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            Serial3.print(*(ptr++),base);\n                        }\n                        else\n                        {\n                            Serial3.println(*(ptr++),base);\n                        }\n                    }\n                } //int32\n                else if(dataType == 6)\n                {\n                    double * ptr = (double *) dataInput;\n                    while(counter--)\n                    {\n                        if (sendModeEnum == 1)\n                        {\n                            if (sendFormatEnum == 0) { //DEC\n                                Serial3.print(*(ptr++),floatprecision);\n                            }\n                            else { //HEX, OCT, BIN\n                                Serial3.print((long)*(ptr++),base);\n                            }\n                        }\n                        else\n                        {\n                            if (sendFormatEnum == 0) { //DEC\n                                Serial3.println(*(ptr++),floatprecision);\n                            }\n                            else { //HEX, OCT, BIN\n                                Serial3.println((long)*(ptr++),base);\n                            }\n                        }\n                    }\n                } //double, single\n            } //print and println\n            break;\n    #endif\n#endif\n    } //Port\n}"},{"name":"MW_arduino_digitalio.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"#ifndef MATLAB_MEX_FILE\n#include <Arduino.h>\n#include \"MW_arduino_digitalio.h\"\n#endif\n#include \"rtwtypes.h\"\n\n// Digital I/O initialization\nextern \"C\" void digitalIOSetup(uint8_T pin, uint8_T mode) \n{ \n    #ifndef MATLAB_MEX_FILE\n    // mode = 0: Input\n    // mode = 1: Output\n    // mode = 2: Input pullup\n    if (mode==0) {\n        pinMode(pin, INPUT);\n    }\n    else if (mode==1) {\n        pinMode(pin, OUTPUT);\n    }\n    else {\n        // mode = 2 is for input pullup\n        pinMode(pin, INPUT_PULLUP);\n    }\n    #endif\n}\n\n// Write a logic value to pin\nextern \"C\" void writeDigitalPin(uint8_T pin, boolean_T val)\n{\n    #ifndef MATLAB_MEX_FILE\n    if (val) {\n        digitalWrite(pin, HIGH);\n    } \n    else {\n        digitalWrite(pin, LOW);\n    }\n    #endif\n}\n\n// Read logical state of a digital pin\nextern \"C\" boolean_T readDigitalPin(uint8_T pin)\n{\n    #ifndef MATLAB_MEX_FILE\n    boolean_T ret;\n     \n    ret = (digitalRead(pin) == HIGH) ? 1:0;\n    return ret;\n    #else\n    return (boolean_T)0;\n    #endif\n}\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_ArduinoHWInit.h\"\n#include \"arduinoAVRScheduler.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Arduino Mega 2560\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.arduinobase.registry.getBaudRate\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.arduinobase.internal.getExternalModeMexArgs('Serial')\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Ethernet')\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONWIFI_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Wifi')\n#define MW_CONNECTIONINFO_XCPONWIFI_PORT 17725\n#define MW_CONNECTIONINFO_XCPONWIFI_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_COMPORTBAUD 921600\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_FORCEBUILDSTATICLIBRARY 0\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 1\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 13\n#define MW_ANALOGINREFVOLTAGE_ANALOG_INPUT_REFERENCE_VOLTAGE 0.000000\n#define MW_SERIAL_SERIAL0_BAUD_RATE 1\n#define MW_SERIAL_SERIAL1_BAUD_RATE 8\n#define MW_SERIAL_SERIAL2_BAUD_RATE 8\n#define MW_SERIAL_SERIAL3_BAUD_RATE 8\n#define MW_SERIAL_SERIAL0_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL0_CONFIG 3\n#define MW_SERIAL_SERIAL1_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL1_CONFIG 3\n#define MW_SERIAL_SERIAL2_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL2_CONFIG 3\n#define MW_SERIAL_SERIAL3_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL3_CONFIG 3\n#define MW_SPI_SPI_CLOCK_OUT_FREQUENCY 1\n#define MW_SPI_SPI_MODE 0\n#define MW_SPI_SPI_BITORDER 0\n#define MW_SPI_SDSLAVESELECT 4.000000\n#define MW_SPI_CANCHIPSELECT 9.000000\n#define MW_ETHERNET_DISABLE_DHCP_ETHERNET 0\n#define MW_ETHERNET_LOCAL_IP_ADDRESS 192.168.0.20\n#define MW_ETHERNET_LOCAL_MAC_ADDRESS DE:AD:BE:EF:FE:ED\n#define MW_WIFI_DISABLE_DHCP_WIFI 0\n#define MW_WIFI_WIFI_IP_ADDRESS 192.168.1.20\n#define MW_WIFI_WIFI_SSID yourNetwork\n#define MW_WIFI_SET_WIFI_ENCRYPTION 0\n#define MW_WIFI_WIFI_WEP_KEY D0D0DEADF00DABBADEAFBEADED\n#define MW_WIFI_WIFI_WEP_KEY_INDEX 0\n#define MW_WIFI_WIFI_WPA_PASSWORD secretPassword\n#define MW_WIFI_WIFI_HARDWARE 0\n#define MW_WIFI_WIFI_ESP8266_HW_SERIAL_PORT 0\n#define MW_THINGSPEAK_ENABLE_CUSTOMSERVER 48\n#define MW_THINGSPEAK_IP_ADDRESS 184.106.153.149\n#define MW_THINGSPEAK_PORT 80\n#define MW_DATAVERSION 2016.02\n#define MW_BUILD_ACTION Build, load and run\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_PORT_SOURCE 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_PIL_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD 0\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD_SPECIFY \n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 500\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERSIZE 500\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERSIZE 500\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_MAXCONTIGSAMPLES 10\n#define MW_CONNECTEDIO_CONNECTEDIOMODE 0\n#define MW_CONNECTEDIO_ACTIONONOVERRUN 0\n#define MW_I2C_I2C0BUSSPEEDHZ 100000\n#define MW_CAN_CANBUSSPEED 10\n#define MW_CAN_CANOSCILLATORFREQUENCY 1\n#define MW_CAN_INTERRUPTPIN 2.000000\n#define MW_CAN_ALLOWALLFILTER 0\n#define MW_CAN_BUFFER0IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK0_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER0_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER1_NOR 255\n#define MW_CAN_ACCEPTANCEMASK0_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER0_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER1_EXT 255\n#define MW_CAN_BUFFER1IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK1_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER2_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER3_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER4_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER5_NOR 255\n#define MW_CAN_ACCEPTANCEMASK1_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER2_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER3_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER4_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER5_EXT 255\n#define MW_MODBUS_MODBUS_COMMS 0\n#define MW_MODBUS_MODBUS_MODE 0\n#define MW_MODBUS_MODBUS_SLAVEID 1\n#define MW_MODBUS_MODBUS_CONFIGCOIL 49\n#define MW_MODBUS_MODBUS_COILADDR 0\n#define MW_MODBUS_MODBUS_COILNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUT 49\n#define MW_MODBUS_MODBUS_INPUTADDR 0\n#define MW_MODBUS_MODBUS_INPUTNUM 1\n#define MW_MODBUS_MODBUS_CONFIGHOLDINGREG 49\n#define MW_MODBUS_MODBUS_HOLDINGREGADDR 0\n#define MW_MODBUS_MODBUS_HOLDINGREGNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUTREG 49\n#define MW_MODBUS_MODBUS_INPUTREGADDR 0\n#define MW_MODBUS_MODBUS_INPUTREGNUM 1\n#define MW_MODBUS_MODBUS_MASTERTIMEOUT 100\n#define MW_RS485_RS485_SERIAL 1\n#define MW_RS485_RS485_BAUD 9600\n#define MW_RS485_RS485_CONFIG 3\n#define MW_RS485_RS485_DEPIN 8\n#define MW_RS485_RS485_REPIN 9\n#define MW_DISPLAY_ENABLECODEGEN 0\n#define MW_DISPLAY_APPLAUNCHBUTTON \n#define MW_IOBLOCKSMODE deployed\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"Wire.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\aIDE\\hardware\\arduino\\avr\\libraries\\Wire\\src","tag":"","groupDisplay":"Other files","code":"/*\n  TwoWire.cpp - TWI/I2C library for Wiring & Arduino\n  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n \n  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts\n  Modified 2017 by Chuck Todd (ctodd@cableone.net) to correct Unconfigured Slave Mode reboot\n  Modified 2020 by Greyson Christoforo (grey@christoforo.net) to implement timeouts\n*/\n\nextern \"C\" {\n  #include <stdlib.h>\n  #include <string.h>\n  #include <inttypes.h>\n  #include \"utility/twi.h\"\n}\n\n#include \"Wire.h\"\n\n// Initialize Class Variables //////////////////////////////////////////////////\n\nuint8_t TwoWire::rxBuffer[BUFFER_LENGTH];\nuint8_t TwoWire::rxBufferIndex = 0;\nuint8_t TwoWire::rxBufferLength = 0;\n\nuint8_t TwoWire::txAddress = 0;\nuint8_t TwoWire::txBuffer[BUFFER_LENGTH];\nuint8_t TwoWire::txBufferIndex = 0;\nuint8_t TwoWire::txBufferLength = 0;\n\nuint8_t TwoWire::transmitting = 0;\nvoid (*TwoWire::user_onRequest)(void);\nvoid (*TwoWire::user_onReceive)(int);\n\n// Constructors ////////////////////////////////////////////////////////////////\n\nTwoWire::TwoWire()\n{\n}\n\n// Public Methods //////////////////////////////////////////////////////////////\n\nvoid TwoWire::begin(void)\n{\n  rxBufferIndex = 0;\n  rxBufferLength = 0;\n\n  txBufferIndex = 0;\n  txBufferLength = 0;\n\n  twi_init();\n  twi_attachSlaveTxEvent(onRequestService); // default callback must exist\n  twi_attachSlaveRxEvent(onReceiveService); // default callback must exist\n}\n\nvoid TwoWire::begin(uint8_t address)\n{\n  begin();\n  twi_setAddress(address);\n}\n\nvoid TwoWire::begin(int address)\n{\n  begin((uint8_t)address);\n}\n\nvoid TwoWire::end(void)\n{\n  twi_disable();\n}\n\nvoid TwoWire::setClock(uint32_t clock)\n{\n  twi_setFrequency(clock);\n}\n\n/***\n * Sets the TWI timeout.\n *\n * This limits the maximum time to wait for the TWI hardware. If more time passes, the bus is assumed\n * to have locked up (e.g. due to noise-induced glitches or faulty slaves) and the transaction is aborted.\n * Optionally, the TWI hardware is also reset, which can be required to allow subsequent transactions to\n * succeed in some cases (in particular when noise has made the TWI hardware think there is a second\n * master that has claimed the bus).\n *\n * When a timeout is triggered, a flag is set that can be queried with `getWireTimeoutFlag()` and is cleared\n * when `clearWireTimeoutFlag()` or `setWireTimeoutUs()` is called.\n *\n * Note that this timeout can also trigger while waiting for clock stretching or waiting for a second master\n * to complete its transaction. So make sure to adapt the timeout to accomodate for those cases if needed.\n * A typical timeout would be 25ms (which is the maximum clock stretching allowed by the SMBus protocol),\n * but (much) shorter values will usually also work.\n *\n * In the future, a timeout will be enabled by default, so if you require the timeout to be disabled, it is\n * recommended you disable it by default using `setWireTimeoutUs(0)`, even though that is currently\n * the default.\n *\n * @param timeout a timeout value in microseconds, if zero then timeout checking is disabled\n * @param reset_with_timeout if true then TWI interface will be automatically reset on timeout\n *                           if false then TWI interface will not be reset on timeout\n\n */\nvoid TwoWire::setWireTimeout(uint32_t timeout, bool reset_with_timeout){\n  twi_setTimeoutInMicros(timeout, reset_with_timeout);\n}\n\n/***\n * Returns the TWI timeout flag.\n *\n * @return true if timeout has occured since the flag was last cleared.\n */\nbool TwoWire::getWireTimeoutFlag(void){\n  return(twi_manageTimeoutFlag(false));\n}\n\n/***\n * Clears the TWI timeout flag.\n */\nvoid TwoWire::clearWireTimeoutFlag(void){\n  twi_manageTimeoutFlag(true);\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint32_t iaddress, uint8_t isize, uint8_t sendStop)\n{\n  if (isize > 0) {\n  // send internal address; this mode allows sending a repeated start to access\n  // some devices' internal registers. This function is executed by the hardware\n  // TWI module on other processors (for example Due's TWI_IADR and TWI_MMR registers)\n\n  beginTransmission(address);\n\n  // the maximum size of internal address is 3 bytes\n  if (isize > 3){\n    isize = 3;\n  }\n\n  // write internal register address - most significant byte first\n  while (isize-- > 0)\n    write((uint8_t)(iaddress >> (isize*8)));\n  endTransmission(false);\n  }\n\n  // clamp to buffer length\n  if(quantity > BUFFER_LENGTH){\n    quantity = BUFFER_LENGTH;\n  }\n  // perform blocking read into buffer\n  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);\n  // set rx buffer iterator vars\n  rxBufferIndex = 0;\n  rxBufferLength = read;\n\n  return read;\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop) {\n\treturn requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0, (uint8_t)0, (uint8_t)sendStop);\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)\n{\n  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);\n}\n\nuint8_t TwoWire::requestFrom(int address, int quantity)\n{\n  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);\n}\n\nuint8_t TwoWire::requestFrom(int address, int quantity, int sendStop)\n{\n  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);\n}\n\nvoid TwoWire::beginTransmission(uint8_t address)\n{\n  // indicate that we are transmitting\n  transmitting = 1;\n  // set address of targeted slave\n  txAddress = address;\n  // reset tx buffer iterator vars\n  txBufferIndex = 0;\n  txBufferLength = 0;\n}\n\nvoid TwoWire::beginTransmission(int address)\n{\n  beginTransmission((uint8_t)address);\n}\n\n//\n//\tOriginally, 'endTransmission' was an f(void) function.\n//\tIt has been modified to take one parameter indicating\n//\twhether or not a STOP should be performed on the bus.\n//\tCalling endTransmission(false) allows a sketch to \n//\tperform a repeated start. \n//\n//\tWARNING: Nothing in the library keeps track of whether\n//\tthe bus tenure has been properly ended with a STOP. It\n//\tis very possible to leave the bus in a hung state if\n//\tno call to endTransmission(true) is made. Some I2C\n//\tdevices will behave oddly if they do not see a STOP.\n//\nuint8_t TwoWire::endTransmission(uint8_t sendStop)\n{\n  // transmit buffer (blocking)\n  uint8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);\n  // reset tx buffer iterator vars\n  txBufferIndex = 0;\n  txBufferLength = 0;\n  // indicate that we are done transmitting\n  transmitting = 0;\n  return ret;\n}\n\n//\tThis provides backwards compatibility with the original\n//\tdefinition, and expected behaviour, of endTransmission\n//\nuint8_t TwoWire::endTransmission(void)\n{\n  return endTransmission(true);\n}\n\n// must be called in:\n// slave tx event callback\n// or after beginTransmission(address)\nsize_t TwoWire::write(uint8_t data)\n{\n  if(transmitting){\n  // in master transmitter mode\n    // don't bother if buffer is full\n    if(txBufferLength >= BUFFER_LENGTH){\n      setWriteError();\n      return 0;\n    }\n    // put byte in tx buffer\n    txBuffer[txBufferIndex] = data;\n    ++txBufferIndex;\n    // update amount in buffer   \n    txBufferLength = txBufferIndex;\n  }else{\n  // in slave send mode\n    // reply to master\n    twi_transmit(&data, 1);\n  }\n  return 1;\n}\n\n// must be called in:\n// slave tx event callback\n// or after beginTransmission(address)\nsize_t TwoWire::write(const uint8_t *data, size_t quantity)\n{\n  if(transmitting){\n  // in master transmitter mode\n    for(size_t i = 0; i < quantity; ++i){\n      write(data[i]);\n    }\n  }else{\n  // in slave send mode\n    // reply to master\n    twi_transmit(data, quantity);\n  }\n  return quantity;\n}\n\n// must be called in:\n// slave rx event callback\n// or after requestFrom(address, numBytes)\nint TwoWire::available(void)\n{\n  return rxBufferLength - rxBufferIndex;\n}\n\n// must be called in:\n// slave rx event callback\n// or after requestFrom(address, numBytes)\nint TwoWire::read(void)\n{\n  int value = -1;\n  \n  // get each successive byte on each call\n  if(rxBufferIndex < rxBufferLength){\n    value = rxBuffer[rxBufferIndex];\n    ++rxBufferIndex;\n  }\n\n  return value;\n}\n\n// must be called in:\n// slave rx event callback\n// or after requestFrom(address, numBytes)\nint TwoWire::peek(void)\n{\n  int value = -1;\n  \n  if(rxBufferIndex < rxBufferLength){\n    value = rxBuffer[rxBufferIndex];\n  }\n\n  return value;\n}\n\nvoid TwoWire::flush(void)\n{\n  // XXX: to be implemented.\n}\n\n// behind the scenes function that is called when data is received\nvoid TwoWire::onReceiveService(uint8_t* inBytes, int numBytes)\n{\n  // don't bother if user hasn't registered a callback\n  if(!user_onReceive){\n    return;\n  }\n  // don't bother if rx buffer is in use by a master requestFrom() op\n  // i know this drops data, but it allows for slight stupidity\n  // meaning, they may not have read all the master requestFrom() data yet\n  if(rxBufferIndex < rxBufferLength){\n    return;\n  }\n  // copy twi rx buffer into local read buffer\n  // this enables new reads to happen in parallel\n  for(uint8_t i = 0; i < numBytes; ++i){\n    rxBuffer[i] = inBytes[i];    \n  }\n  // set rx iterator vars\n  rxBufferIndex = 0;\n  rxBufferLength = numBytes;\n  // alert user program\n  user_onReceive(numBytes);\n}\n\n// behind the scenes function that is called when data is requested\nvoid TwoWire::onRequestService(void)\n{\n  // don't bother if user hasn't registered a callback\n  if(!user_onRequest){\n    return;\n  }\n  // reset tx buffer iterator vars\n  // !!! this will kill any pending pre-master sendTo() activity\n  txBufferIndex = 0;\n  txBufferLength = 0;\n  // alert user program\n  user_onRequest();\n}\n\n// sets function called on slave write\nvoid TwoWire::onReceive( void (*function)(int) )\n{\n  user_onReceive = function;\n}\n\n// sets function called on slave read\nvoid TwoWire::onRequest( void (*function)(void) )\n{\n  user_onRequest = function;\n}\n\n// Preinstantiate Objects //////////////////////////////////////////////////////\n\nTwoWire Wire = TwoWire();\n\n"},{"name":"arduinoAVRScheduler.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinotarget\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n *\n * Copyright 2013-2015 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"arduinoAVRScheduler.h\"\n\nextern volatile int IsrOverrun;\nunsigned long oldtime = 0L;\nunsigned long actualtime;\n\n\n#if (defined(MW_SCHEDULERCOUNTER) &&  (MW_SCHEDULERCOUNTER > 1))\n   #if (MW_SCHEDULERCOUNTER >= 65536)\n      volatile uint32_t scheduler_counter = 0;\n    #elif (MW_SCHEDULERCOUNTER >= 256)\n      volatile uint16_t scheduler_counter = 0;\n    #else\n      volatile uint8_t scheduler_counter = 0;\n    #endif\n#endif\n                                  \n/*\n * Call the rt_Onestep function when the timer interrupt hits\n *\n */\n#ifndef _MW_ARDUINO_LOOP_\nISR(INTERRUPT_VECTOR)\n{\n    RESET_TIMER;\n    \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      if ((++scheduler_counter) == MW_SCHEDULERCOUNTER) {\n         scheduler_counter = 0;\n    #endif\n\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n          // Overrun detected\n          digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n    #endif\n      rt_OneStep();\n         \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      }\n    #endif\n}\n#endif    \n\nvoid configureArduinoAVRTimer(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n  // Sets up the timer overflow interrupt.\n  RESET_TIMER;\n\n  // Initially disable the overflow interrupt (before configuration).\n  DISABLE_SCHEDULER_INT();\n\n  // Set the timer to normal mode.\n  TIMER_NORMAL_MODE;\n\n  // Set the prescaler.\n  SETUP_PRESCALER;\n\n  // Enable the overflow interrupt.\n  ENABLE_SCHEDULER_INT();    \n#endif  \n}\n\nboolean disable_rt_OneStep(void)\n{\n    boolean t_return = 0U;\n#ifndef _MW_ARDUINO_LOOP_\n    t_return = GET_SCHEDULER_INT_EN_STATUS();\n  // Disable the overflow interrupt for XCP External Mode\n  DISABLE_SCHEDULER_INT();  \n#endif \n  return t_return;\n}\n\nvoid enable_rt_OneStep(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n  // Enable the overflow interrupt\n  ENABLE_SCHEDULER_INT();  \n#endif \n}\n\nboolean MW_Arduino_Loop(void)\n{\n    boolean ret = 0;\n\n#ifdef _MW_ARDUINO_LOOP_\n    unsigned long overruntime;\n#if (defined(MW_ARDUINO_MICROS))\n    actualtime = micros();\n#else\n    actualtime = millis();\n#endif\n  \n    if ((unsigned long) (actualtime - oldtime) >= MW_ARDUINO_STEP_SIZE)\n    {\n        oldtime = actualtime;\n        \n#ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n            // Overrun detected\n            digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n#endif\n        rt_OneStep();\n            #if (defined(_MW_ARDUINO_LOOP_))\n                #if (defined(MW_ARDUINO_MICROS))\n                        overruntime = micros();\n                #else\n                        overruntime = millis();\n                #endif\n                if ((unsigned long) (overruntime - oldtime) >= MW_ARDUINO_STEP_SIZE)   \n                  IsrOverrun = 1;\n                else\n                  IsrOverrun = 0;\n            #endif\n}\n#endif\n\n    ret = 1;\n    return ret;\n}\n\n"},{"name":"encoder_arduino.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\AppData\\Roaming\\MathWorks\\MATLAB Add-Ons\\Collections\\Rensselaer Arduino Support Package Library (RASPLib)\\RASPlib\\src","tag":"","groupDisplay":"Other files","code":"#include <Arduino.h>\n#include \"encoder_arduino.h\"\n\ntypedef struct\n{\n    int pinA;\n    int pinB;\n    long pos;\n    int del;\n\tint Aprev;  //1221\n\tint Bprev;  //1221\n} Encoder;\n//volatile Encoder Enc[4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0},{0,0,0,0}};\nvolatile Encoder Enc[5] = {{0,0,0,0,0,0}, {0,0,0,0,0,0}, {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}};  //1221\n\n// Auxiliary function to handle encoder attachment\nstatic int getIntNum(int pin)\n{\n    // Returns the interrupt number for a given interrupt pin\n    // See http://arduino.cc/it/Reference/AttachInterrupt\n    switch(pin) {\n        case 2:\n            return 0;\n        case 3:\n            return 1;\n        case 21:\n            return 2;\n        case 20:\n            return 3;\n        case 19:\n            return 4;\n        case 18:\n            return 5;\n\t\tcase 6:        // direct access to interrupt 6\n            return 6;\n        case 7:\n            return 7;  // direct access to interrupt 7\n        default:\n            return -1;\n    }\n}\n\n// Auxiliary debouncing function\nstatic void debounce(int del)\n{\n    for (int k = 0; k < del; k++) {\n        // can't use delay in the ISR so need to waste some time\n        // perfoming operations, this uses roughly 0.1ms on uno\n        k = k +0.0 +0.0 -0.0 +3.0 -3.0;\n    }\n}\n\n// Interrupt Service Routine: change on pin A for Encoder 0\nstatic void irsPinAEn0(void)\n{\n    // Read pin B right away\n    //int drB = digitalRead(Enc[0].pinB);int drA = digitalRead(Enc[0].pinA);\n    int PINE_REG=PINE;  // read entire register once\n    int drB = bool(PINE_REG&(1<<5));int drA = bool(PINE_REG&(1<<4));  // PE4 2 PE5 3\n\t\n    // Possibly wait before reading pin A, then read it\n    //debounce(Enc[0].del);\n    \n    // this updates the counter\n    if (drA == HIGH)\n    {\n        // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[0].pos++;  // going clockwise: increment\n        }\n        else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n        \n    }\n    else {\n        // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[0].pos++;  // going clockwise: increment\n        }\n        else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n} // end ISR pin A Encoder 0\n\n\n\n// Interrupt Service Routine: change on pin B for Encoder 0\nstatic void isrPinBEn0(void)\n{\n    // read pin A right away\n    //int drA = digitalRead(Enc[0].pinA);int drB = digitalRead(Enc[0].pinB);\n    int PINE_REG=PINE;  // read entire register once\n    int drA = bool(PINE_REG&(1<<4));int drB = bool(PINE_REG&(1<<5)); // PE4 2 PE5 3\n    // possibly wait before reading pin B, then read it\n    //debounce(Enc[0].del);\n\n    // this updates the counter\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[0].pos++;  // going clockwise: increment\n        } else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } else {                       // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[0].pos++;  // going clockwise: increment\n        } else {\n            Enc[0].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n} // end ISR pin B Encoder 0\n\n// Interrupt Service Routine: change on pin A for Encoder 1\nstatic void irsPinAEn1(void)\n{\n    // read pin B right away\n    // int drB = digitalRead(Enc[1].pinB);int drA = digitalRead(Enc[1].pinA); \n    // possibly wait before reading pin A, then read it\n    //debounce(Enc[1].del);\n    int PIND_REG=PIND;  // read entire register once\n\tint drB = bool(PIND_REG&(1<<3));int drA = bool(PIND_REG&(1<<2));  // PD3 18, PD2 19\n    \n    // this updates the counter\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin A Encoder 1\n\n\n// Interrupt Service Routine: change on pin B for Encoder 1\nstatic void isrPinBEn1(void)\n{\n    // read pin A right away\n    // int drA = digitalRead(Enc[1].pinA);int drB = digitalRead(Enc[1].pinB);\n    // possibly wait before reading pin B, then read it\n    //debounce(Enc[1].del);\n    int PIND_REG=PIND;  // read entire register once\n    int drA = bool(PIND_REG&(1<<2));int drB = bool(PIND_REG&(1<<3)); // PD3 18, PD2 19\n    \n    // this updates the counter\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[1].pos++;  // going clockwise: increment\n        } else {\n            Enc[1].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin B Encoder 1\n\n\n// Interrupt Service Routine: change on pin A for Encoder 2\nstatic void irsPinAEn2(void)\n{\n  /* read pin B right away                                   */\n  //int drB = digitalRead(Enc[0].pinB);  \n  int PDE1=PINE;\n  int drB = (PDE1 & 0x80)>>PINE7;//PINE7; (have to read whole port at once, then AND, then bitshift)\n  int drA = (PDE1 & 0x40)>>PINE6;//PINE6; (have to read whole port at once, then AND, then bitshift)\n   \n  /* possibly wait before reading pin A, then read it        */\n  //debounce(Enc[2].del);\n   \n    // this updates the counter\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin A Encoder 2\n\n\n// Interrupt Service Routine: change on pin B for Encoder 2\nstatic void isrPinBEn2(void)\n{\n  /* read pin A right away                                   */\n  //int drA = digitalRead(Enc[0].pinA);\n  int PDE1=PINE;\n  int drA = (PDE1 & 0x40)>>PINE6;//PINE6; (have to read whole port at once, then AND, then bitshift)\n  int drB = (PDE1 & 0x80)>>PINE7;//PINE7; (have to read whole port at once, then AND, then bitshift) \n  /* possibly wait before reading pin B, then read it        */\n  //debounce(Enc[2].del);\n  //int drB = digitalRead(Enc[0].pinB);\n    \n    // this updates the counter\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[2].pos++;  // going clockwise: increment\n        } else {\n            Enc[2].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n    \n} // end ISR pin B Encoder 2\n\n\n// ISR routines for PCINT0\n// Encoder using PCINT vector will be ENC[4]\n/* Interrupt Service Routine: change on pin A & B */\nISR( PCINT0_vect )\n{\n  /* read pin A & B right away                                   */\n    int PINB_REG=PINB;  // read entire register once\n\tint drB = bool(PINB_REG&(1<<5));int drA = bool(PINB_REG&(1<<6));  // PB5, PB6 --> 11, 12\n\n\t\n  // Find out which pin changed:\n  if(drB==Enc[4].Bprev){\n\t  // A must have changed\n\t  Enc[4].Aprev=drA;\n\t  // this updates the counter if A Changed:\n    if (drA == HIGH) {   // low->high on A?\n        if (drB == LOW) {  // check pin B\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on A\n        if (drB == HIGH) { // check pin B\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t\n  } else {\n\t  // B must have changed\n\t  Enc[4].Bprev=drB;\n\t  // this updates the counter if B changed:\n    if (drB == HIGH) {   // low->high on B?\n        if (drA == HIGH) { // check pin A\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    }\n    else { // must be high to low on B\n        if (drA == LOW) {  // check pin A\n            Enc[4].pos++;  // going clockwise: increment\n        } else {\n            Enc[4].pos--;  // going counterclockwise: decrement\n        }\n    } // end counter update\n\t  \n  }\n\t\n  /* this updates the counter                                */\n  if (drA == HIGH) {   /* low->high on A? */\n      \n    if (drB == LOW) {  /* check pin B */\n  \tEnc[4].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[4].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } else {                       /* must be high to low on A */\n  \n    if (drB == HIGH) { /* check pin B */\n  \tEnc[4].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[4].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } /* end counter update                                    */\n\n} /* end ISR pin A Encoder 3               \n\n// ISR routines for PCINT\n// Encoder using PCINT vector will be ENC[3]\n/* Interrupt Service Routine: change on pin A for Encoder 1  */\nISR( PCINT1_vect )\n{\n\n  /* read pin B right away                                   */\n  //int drB = digitalRead(Enc[3].pinB);  int drA = digitalRead(Enc[3].pinA);\n  int drB = bool(PINK&(1<<0));int drA = bool(PINJ&(1<<0));  // PK0 A8, PJ0 D15\n  /* possibly wait before reading pin A, then read it        */\n  //debounce(Enc[3].del);\n\n\n  /* this updates the counter                                */\n  if (drA == HIGH) {   /* low->high on A? */\n      \n    if (drB == LOW) {  /* check pin B */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } else {                       /* must be high to low on A */\n  \n    if (drB == HIGH) { /* check pin B */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } /* end counter update                                    */\n\n} /* end ISR pin A Encoder 3                                */\n\n\n\n/* Interrupt Service Routine: change on pin B for Encoder 3  */\nISR( PCINT2_vect )\n{ \n\n  /* read pin A right away                                   */\n  //int drA = digitalRead(Enc[3].pinA);  int drB = digitalRead(Enc[3].pinB);\n  int drA = bool(PINJ&(1<<0)); int drB = bool(PINK&(1<<0)); // PK0 A8, PJ0 D15\n  /* possibly wait before reading pin B, then read it        */\n  //debounce(Enc[3].del);\n\n\n  /* this updates the counter                                */\n  if (drB == HIGH) {   /* low->high on B? */\n  \n    if (drA == HIGH) { /* check pin A */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n  \n  } else {                       /* must be high to low on B */\n  \n    if (drA == LOW) {  /* check pin A */\n  \tEnc[3].pos++;  /* going clockwise: increment         */\n    } else {\n  \tEnc[3].pos--;  /* going counterclockwise: decrement  */\n    }\n    \n  } /* end counter update */\n\n} /* end ISR pin B Encoder 3                                */\n\n// Initialization function called by Encoder System object\nextern \"C\" void enc_init(int enc, int pinA, int pinB)\n{\n    // enc is the encoder number and it can be 0,1 or 2\n    // if other encoder blocks are present in the model\n    // up to a maximum of 3, they need to refer to a\n    // different encoder number\n    \n    // store pinA and pinB in global encoder structure Enc\n    // they will be needed later by the interrupt routine\n    // that will not be able to access s-function parameters\n    \n    Enc[enc].pinA=pinA;      // set pin A\n    Enc[enc].pinB=pinB;      // set pin B\n    \n    // set encoder pins as inputs\n    pinMode(Enc[enc].pinA, INPUT);\n    pinMode(Enc[enc].pinB, INPUT);\n    \n    // turn on pullup resistors\n    digitalWrite(Enc[enc].pinA, HIGH);\n    digitalWrite(Enc[enc].pinB, HIGH);\n    \n    // attach interrupts\n    switch(enc) {\n        case 0:\n            attachInterrupt(getIntNum(Enc[0].pinA), irsPinAEn0, CHANGE);\n            attachInterrupt(getIntNum(Enc[0].pinB), isrPinBEn0, CHANGE);\n            break;\n        case 1:\n            attachInterrupt(getIntNum(Enc[1].pinA), irsPinAEn1, CHANGE);\n            attachInterrupt(getIntNum(Enc[1].pinB), isrPinBEn1, CHANGE);\n            break;\n        case 2:\n            attachInterrupt(getIntNum(Enc[2].pinA), irsPinAEn2, CHANGE);\n            attachInterrupt(getIntNum(Enc[2].pinB), isrPinBEn2, CHANGE);\n            break;\n\t\tcase 3:\n\t\t\t// attach interrupts for enc[3]:\n\t\t\t// make analog pin A8 and RX3 (D13) into pin change interrupts:\n\t\t\tPCICR |= (1 << PCIE2);     // enable PCINT 2\n\t\t\tPCICR |= (1 << PCIE1);     // enable PCINT 1 \n\t\t\tPCMSK2 |= (1 << PCINT16);  // Analog 8 as input\n\t\t\tPCMSK1 |= (1 << PCINT9);  // RX3 D15 as input \n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t// attach interrupts for enc[4]:\n\t\t\t// ping 11 and 12 into pin change interrupts:\n\t\t\tPCICR |= (1 << PCIE0);     // enable PCINT0  (pins 11 and 12 --> PCINT5, PCINT6 --> PCINT0 vec)\n\t\t\tPCMSK0 |= (1 << PCINT5);  // Pin 11\n\t\t\tPCMSK0 |= (1 << PCINT6);  // Pin 12\n\t\t\tbreak;\n\t\t\t\n    }\n}\n\n// Output function called by Encoder System object\nextern \"C\" long enc_output(long enc)\n{\n    return (long)Enc[enc].pos;\n}\n// [EOF]\n\n"},{"name":"io_wrappers.cpp","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Wrappers to make I/O functions available with C linkage. This allows C++\n* methods to be called from C code.\n*\n* Copyright 2011-2022 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"rtwtypes.h\"\n\n#if (defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)) || (defined(_RTT_UDP_) && (_RTT_UDP_ != 0)) || (defined(_RTT_TCP_) && (_RTT_TCP_ != 0) || defined(_RTT_THINGSPEAK_))\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n#include <SPI.h>\n#endif\n\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\nextern \"C\" void __libc_init_array(void);\n#endif\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" void Serial_begin(int port, long r, int c)\n{\n    static int serialInit=0;\n    #if !(defined(ESP_PLATFORM))\n    serialInit=0;   //Reset serialInit flag for all targets except ESP32\n    #endif\n    #if defined(ARDUINO_ARCH_SAM)\n    UARTClass::UARTModes config = UARTClass::UARTModes(c);\n    #else\n    int config = c;\n    #endif\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            if(serialInit & 1)return;\n            serialInit |= 1;\n            #if defined(ESP_PLATFORM)\n            Serial.begin(r,config,_RTT_RX_PIN_SERIAL0_,_RTT_TX_PIN_SERIAL0_);\n            #else\n            Serial.begin(r,config);\n            #endif\n            break;\n        case 1:\n            if(serialInit & 2)return;\n            serialInit |= 2;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            #if defined(ESP_PLATFORM)\n            Serial1.begin(r,config,_RTT_RX_PIN_SERIAL1_,_RTT_TX_PIN_SERIAL1_);\n            #else\n            Serial1.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 2:\n            if(serialInit & 4)return;\n            serialInit |= 4;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            #if defined(ESP_PLATFORM)\n            Serial2.begin(r,config,_RTT_RX_PIN_SERIAL2_,_RTT_TX_PIN_SERIAL2_);\n            #else\n            Serial2.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 3:\n            if(serialInit & 8)return;\n            serialInit |= 8;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.begin(r,config);\n            #endif\n            break;\n    }\n    #else\n    if(serialInit & 1)return;\n    serialInit |= 1;\n    Serial.begin(r,SERIAL_8N1);\n    #endif\n}\n\nextern \"C\" void Serial_read(int port, int showOutStatus, uint8_t *outData, int16_t *outStatus)\n{\n    int libFcnOutput;\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            libFcnOutput = Serial.read();\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            libFcnOutput = Serial1.read();\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            libFcnOutput = Serial2.read();\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            libFcnOutput = Serial3.read();\n            #endif\n            break;\n    }\n    #else\n    libFcnOutput = Serial.read();\n    #endif\n    *outData = (uint8_t) libFcnOutput;\n    *outStatus = (libFcnOutput != -1);\n}\n\nextern \"C\" void Serial_write(int port, uint8_t * c, size_t s)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            Serial.write(c, s);\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            Serial1.write(c, s);\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            Serial2.write(c, s);\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.write(c, s);\n            #endif\n            break;\n    }\n    #else\n    Serial.write(c, s);\n    #endif\n}\n\n#if _RTT_UDP_ != 0\nEthernetUDP Udp[_RTT_UDP_];\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nunsigned int localport[_RTT_UDP_] = {_RTT_UDP_LOCAL_PORT_ORDERED};\nint configureSuccess;\nint trialcount=0;\nextern \"C\" uint8_t MW_EthernetAndUDPBegin(uint8_t udpindex, uint32_t localPort)\n{\n    static int only_one_ethernet_begin;\n    if (only_one_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n    }\n    return (Udp[udpindex].begin(localport[udpindex]));\n}\n\nextern \"C\" int MW_UDPFinalWrite(uint8_t udpindex, uint8_t data, uint8_t remoteIPOctect1,uint8_t remoteIPOctect2,uint8_t remoteIPOctect3,uint8_t remoteIPOctect4, uint32_t remoteport)\n{\n    IPAddress remoteIpAddress(remoteIPOctect1,remoteIPOctect2, remoteIPOctect3, remoteIPOctect4);\n    Udp[udpindex].beginPacket(remoteIpAddress, remoteport);\n    Udp[udpindex].write(data);\n    return(Udp[udpindex].endPacket());\n}\n\nextern \"C\" void MW_UDPFinalRead(uint8_t udpindex, uint8_t *data, int32_t *outStatus)\n{\n    int packetSize = Udp[udpindex].parsePacket();\n    if(packetSize)\n    {\n        int libFcnOutput;\n        libFcnOutput = Udp[udpindex].read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n    }\n\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n}\n#endif\n\n#if defined(_RTT_THINGSPEAK_) || (_RTT_TCP_ != 0)\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nint configureSuccess;\nint trialcount;\n#if _RTT_TCP_ != 0\nEthernetServer server[_RTT_TCP_] = {_RTT_TCP_SERVER_PORT_ORDERED};\n#endif\nextern \"C\" void MW_EthernetAndTCPServerBegin(uint8_t tcpindex, uint32_t serverport)\n{\n    static int only_one_tcp_server_and_ethernet_begin = 0;\n\n    if (only_one_tcp_server_and_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_tcp_server_and_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n\n        #if _RTT_TCP_ != 0\n        // Begin all servers based on the number of different TCP ports.\n        for (int i = 0;i < _RTT_TCP_;i++)\n        {\n            server[i].begin();\n        }\n        #endif\n        only_one_tcp_server_and_ethernet_begin = 1;\n    }\n}\n#endif\n#if _RTT_TCP_ != 0\nextern \"C\" void MW_TCPFinalread(uint8_t tcpindex, uint8_t *data, uint32_t serverport, int32_t *outStatus)\n{\n    int libFcnOutput;\n    EthernetClient client = server[tcpindex].available();\n    if (int(client) == true) {\n        libFcnOutput = client.read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n\n    }\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n\n}\nextern \"C\" void MW_TCPFinalWrite(uint8_t tcpindex, uint8_t data, uint32_t serverport)\n{\n    server[tcpindex].write(data);\n}\n#endif\n\n\n#if defined(_ROTH_LEONARDO_)\nextern \"C\" void MW_usbattach()\n{\n    USBDevice.attach();\n}\n#elif defined(ARDUINO_VIRTUAL_COM_PORT)\nextern \"C\" void MW_usbattach()\n{\n    __libc_init_array();\n    USBDevice.init();\n    USBDevice.attach();\n\n}\n#endif\n\nextern \"C\" void MW_pinModeAnalogInput(uint32_t pinNumber)\n{\n    if (pinNumber < A0)\n        pinNumber += A0;\n    pinMode(pinNumber, INPUT);\n}\n\nextern \"C\" void MW_delay_in_milliseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = millis();\n    while(millis()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" void MW_delay_in_microseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = micros();\n    while(micros()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" uint32_T MW_getCurrentTime_in_milliseconds()\n{\n   return (uint32_T)millis();\n}\n\n\n// #if defined(ARDUINO_ARDUINO_NANO33BLE)\n// #include \"Arduino.h\"\n// #include \"pins_arduino.h\"\n// #include \"mbed/drivers/AnalogIn.h\"\n// #include \"mbed.h\"\n//\n// extern uint8_t nano33BLE_dutycycle[21];\n// extern uint16_t nano33BLE_period[21];\n//\n//\n// events::EventQueue queue(32 * EVENTS_EVENT_SIZE);\n// rtos::Thread t;\n// mbed::Ticker tick;\n//\n// static int write_resolution = 8;\n// static int read_resolution = 10;\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite_1(pin_size_t pin, int val, uint16_t period)\n// {\n//   if (pin >= PINS_COUNT) {\n//     return;\n//   }\n//   float percent = (float)val/(float)((1 << write_resolution)-1);\n//   mbed::PwmOut* pwm = digitalPinToPwm(pin);\n//   if (pwm == NULL) {\n//     pwm = new mbed::PwmOut(digitalPinToPinName(pin));\n//     digitalPinToPwm(pin) = pwm;\n//     pwm->period_ms(period);\n//   }\n//   pwm->write(percent);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Handler()\n// {\n//     MW_NANO33BLE_analogWrite_1(5, nano33BLE_dutycycle[5], nano33BLE_period[5]);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Setup()\n// {\n//   t.start(callback(&queue, &events::EventQueue::dispatch_forever));\n//   tick.attach(queue.event(MW_NANO33BLE_PWM_Handler),_RTT_PWM_PIN5_CST );\n// }\n//\n//\n//\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite(PinName pin, int val, uint16_t period)\n// {\n// //   pin_size_t idx = PinNameToIndex(pin);\n// //   if (idx != NOT_A_PIN) {\n// //     MW_NANO33BLE_analogWrite_1(idx, 50, period);\n// //   } else {\n// //     mbed::PwmOut* pwm = new mbed::PwmOut(pin);\n// //     pwm->period_ms(2);\n// //     float percent = (float)50/(float)((1 << write_resolution)-1);\n// //     pwm->write(percent);\n// //   }\n// }\n//\n// #endif"},{"name":"twi.c","type":"source","group":"legacy","path":"C:\\Users\\oscar\\Documents\\MATLAB\\R7003e\\MatlabAndSimulink\\LabB_PIDOverRobot_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\aIDE\\hardware\\arduino\\avr\\libraries\\Wire\\src\\utility","tag":"","groupDisplay":"Other files","code":"/*\n  twi.c - TWI/I2C library for Wiring & Arduino\n  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts\n  Modified 2020 by Greyson Christoforo (grey@christoforo.net) to implement timeouts\n*/\n\n#include <math.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <util/delay.h>\n#include <compat/twi.h>\n#include \"Arduino.h\" // for digitalWrite and micros\n\n#ifndef cbi\n#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))\n#endif\n\n#ifndef sbi\n#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))\n#endif\n\n#include \"pins_arduino.h\"\n#include \"twi.h\"\n\nstatic volatile uint8_t twi_state;\nstatic volatile uint8_t twi_slarw;\nstatic volatile uint8_t twi_sendStop;\t\t\t// should the transaction end with a stop\nstatic volatile uint8_t twi_inRepStart;\t\t\t// in the middle of a repeated start\n\n// twi_timeout_us > 0 prevents the code from getting stuck in various while loops here\n// if twi_timeout_us == 0 then timeout checking is disabled (the previous Wire lib behavior)\n// at some point in the future, the default twi_timeout_us value could become 25000\n// and twi_do_reset_on_timeout could become true\n// to conform to the SMBus standard\n// http://smbus.org/specs/SMBus_3_1_20180319.pdf\nstatic volatile uint32_t twi_timeout_us = 0ul;\nstatic volatile bool twi_timed_out_flag = false;  // a timeout has been seen\nstatic volatile bool twi_do_reset_on_timeout = false;  // reset the TWI registers on timeout\n\nstatic void (*twi_onSlaveTransmit)(void);\nstatic void (*twi_onSlaveReceive)(uint8_t*, int);\n\nstatic uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];\nstatic volatile uint8_t twi_masterBufferIndex;\nstatic volatile uint8_t twi_masterBufferLength;\n\nstatic uint8_t twi_txBuffer[TWI_BUFFER_LENGTH];\nstatic volatile uint8_t twi_txBufferIndex;\nstatic volatile uint8_t twi_txBufferLength;\n\nstatic uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];\nstatic volatile uint8_t twi_rxBufferIndex;\n\nstatic volatile uint8_t twi_error;\n\n/* \n * Function twi_init\n * Desc     readys twi pins and sets twi bitrate\n * Input    none\n * Output   none\n */\nvoid twi_init(void)\n{\n  // initialize state\n  twi_state = TWI_READY;\n  twi_sendStop = true;\t\t// default value\n  twi_inRepStart = false;\n  \n  // activate internal pullups for twi.\n  digitalWrite(SDA, 1);\n  digitalWrite(SCL, 1);\n\n  // initialize twi prescaler and bit rate\n  cbi(TWSR, TWPS0);\n  cbi(TWSR, TWPS1);\n  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;\n\n  /* twi bit rate formula from atmega128 manual pg 204\n  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n  note: TWBR should be 10 or higher for master mode\n  It is 72 for a 16mhz Wiring board with 100kHz TWI */\n\n  // enable twi module, acks, and twi interrupt\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);\n}\n\n/* \n * Function twi_disable\n * Desc     disables twi pins\n * Input    none\n * Output   none\n */\nvoid twi_disable(void)\n{\n  // disable twi module, acks, and twi interrupt\n  TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));\n\n  // deactivate internal pullups for twi.\n  digitalWrite(SDA, 0);\n  digitalWrite(SCL, 0);\n}\n\n/* \n * Function twi_slaveInit\n * Desc     sets slave address and enables interrupt\n * Input    none\n * Output   none\n */\nvoid twi_setAddress(uint8_t address)\n{\n  // set twi slave address (skip over TWGCE bit)\n  TWAR = address << 1;\n}\n\n/* \n * Function twi_setClock\n * Desc     sets twi bit rate\n * Input    Clock Frequency\n * Output   none\n */\nvoid twi_setFrequency(uint32_t frequency)\n{\n  TWBR = ((F_CPU / frequency) - 16) / 2;\n  \n  /* twi bit rate formula from atmega128 manual pg 204\n  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))\n  note: TWBR should be 10 or higher for master mode\n  It is 72 for a 16mhz Wiring board with 100kHz TWI */\n}\n\n/* \n * Function twi_readFrom\n * Desc     attempts to become twi bus master and read a\n *          series of bytes from a device on the bus\n * Input    address: 7bit i2c device address\n *          data: pointer to byte array\n *          length: number of bytes to read into array\n *          sendStop: Boolean indicating whether to send a stop at the end\n * Output   number of bytes read\n */\nuint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)\n{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < length){\n    return 0;\n  }\n\n  // wait until twi is ready, become master receiver\n  uint32_t startMicros = micros();\n  while(TWI_READY != twi_state){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return 0;\n    }\n  }\n  twi_state = TWI_MRX;\n  twi_sendStop = sendStop;\n  // reset error state (0xFF.. no error occured)\n  twi_error = 0xFF;\n\n  // initialize buffer iteration vars\n  twi_masterBufferIndex = 0;\n  twi_masterBufferLength = length-1;  // This is not intuitive, read on...\n  // On receive, the previously configured ACK/NACK setting is transmitted in\n  // response to the received byte before the interrupt is signalled. \n  // Therefor we must actually set NACK when the _next_ to last byte is\n  // received, causing that NACK to be sent in response to receiving the last\n  // expected byte of data.\n\n  // build sla+w, slave device address + w bit\n  twi_slarw = TW_READ;\n  twi_slarw |= address << 1;\n\n  if (true == twi_inRepStart) {\n    // if we're in the repeated start state, then we've already sent the start,\n    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.\n    // We need to remove ourselves from the repeated start state before we enable interrupts,\n    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning\n    // up. Also, don't enable the START interrupt. There may be one pending from the \n    // repeated start that we sent ourselves, and that would really confuse things.\n    twi_inRepStart = false;\t\t\t// remember, we're dealing with an ASYNC ISR\n    startMicros = micros();\n    do {\n      TWDR = twi_slarw;\n      if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n        twi_handleTimeout(twi_do_reset_on_timeout);\n        return 0;\n      }\n    } while(TWCR & _BV(TWWC));\n    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);\t// enable INTs, but not START\n  } else {\n    // send start condition\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);\n  }\n\n  // wait for read operation to complete\n  startMicros = micros();\n  while(TWI_MRX == twi_state){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return 0;\n    }\n  }\n\n  if (twi_masterBufferIndex < length) {\n    length = twi_masterBufferIndex;\n  }\n\n  // copy twi buffer to data\n  for(i = 0; i < length; ++i){\n    data[i] = twi_masterBuffer[i];\n  }\n\n  return length;\n}\n\n/* \n * Function twi_writeTo\n * Desc     attempts to become twi bus master and write a\n *          series of bytes to a device on the bus\n * Input    address: 7bit i2c device address\n *          data: pointer to byte array\n *          length: number of bytes in array\n *          wait: boolean indicating to wait for write or not\n *          sendStop: boolean indicating whether or not to send a stop at the end\n * Output   0 .. success\n *          1 .. length to long for buffer\n *          2 .. address send, NACK received\n *          3 .. data send, NACK received\n *          4 .. other twi error (lost bus arbitration, bus error, ..)\n *          5 .. timeout\n */\nuint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)\n{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < length){\n    return 1;\n  }\n\n  // wait until twi is ready, become master transmitter\n  uint32_t startMicros = micros();\n  while(TWI_READY != twi_state){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return (5);\n    }\n  }\n  twi_state = TWI_MTX;\n  twi_sendStop = sendStop;\n  // reset error state (0xFF.. no error occured)\n  twi_error = 0xFF;\n\n  // initialize buffer iteration vars\n  twi_masterBufferIndex = 0;\n  twi_masterBufferLength = length;\n  \n  // copy data to twi buffer\n  for(i = 0; i < length; ++i){\n    twi_masterBuffer[i] = data[i];\n  }\n  \n  // build sla+w, slave device address + w bit\n  twi_slarw = TW_WRITE;\n  twi_slarw |= address << 1;\n  \n  // if we're in a repeated start, then we've already sent the START\n  // in the ISR. Don't do it again.\n  //\n  if (true == twi_inRepStart) {\n    // if we're in the repeated start state, then we've already sent the start,\n    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.\n    // We need to remove ourselves from the repeated start state before we enable interrupts,\n    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning\n    // up. Also, don't enable the START interrupt. There may be one pending from the \n    // repeated start that we sent outselves, and that would really confuse things.\n    twi_inRepStart = false;\t\t\t// remember, we're dealing with an ASYNC ISR\n    startMicros = micros();\n    do {\n      TWDR = twi_slarw;\n      if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n        twi_handleTimeout(twi_do_reset_on_timeout);\n        return (5);\n      }\n    } while(TWCR & _BV(TWWC));\n    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);\t// enable INTs, but not START\n  } else {\n    // send start condition\n    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);\t// enable INTs\n  }\n\n  // wait for write operation to complete\n  startMicros = micros();\n  while(wait && (TWI_MTX == twi_state)){\n    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {\n      twi_handleTimeout(twi_do_reset_on_timeout);\n      return (5);\n    }\n  }\n  \n  if (twi_error == 0xFF)\n    return 0;\t// success\n  else if (twi_error == TW_MT_SLA_NACK)\n    return 2;\t// error: address send, nack received\n  else if (twi_error == TW_MT_DATA_NACK)\n    return 3;\t// error: data send, nack received\n  else\n    return 4;\t// other twi error\n}\n\n/* \n * Function twi_transmit\n * Desc     fills slave tx buffer with data\n *          must be called in slave tx event callback\n * Input    data: pointer to byte array\n *          length: number of bytes in array\n * Output   1 length too long for buffer\n *          2 not slave transmitter\n *          0 ok\n */\nuint8_t twi_transmit(const uint8_t* data, uint8_t length)\n{\n  uint8_t i;\n\n  // ensure data will fit into buffer\n  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){\n    return 1;\n  }\n  \n  // ensure we are currently a slave transmitter\n  if(TWI_STX != twi_state){\n    return 2;\n  }\n  \n  // set length and copy data into tx buffer\n  for(i = 0; i < length; ++i){\n    twi_txBuffer[twi_txBufferLength+i] = data[i];\n  }\n  twi_txBufferLength += length;\n  \n  return 0;\n}\n\n/* \n * Function twi_attachSlaveRxEvent\n * Desc     sets function called before a slave read operation\n * Input    function: callback function to use\n * Output   none\n */\nvoid twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )\n{\n  twi_onSlaveReceive = function;\n}\n\n/* \n * Function twi_attachSlaveTxEvent\n * Desc     sets function called before a slave write operation\n * Input    function: callback function to use\n * Output   none\n */\nvoid twi_attachSlaveTxEvent( void (*function)(void) )\n{\n  twi_onSlaveTransmit = function;\n}\n\n/* \n * Function twi_reply\n * Desc     sends byte or readys receive line\n * Input    ack: byte indicating to ack or to nack\n * Output   none\n */\nvoid twi_reply(uint8_t ack)\n{\n  // transmit master read ready signal, with or without ack\n  if(ack){\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);\n  }else{\n    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);\n  }\n}\n\n/* \n * Function twi_stop\n * Desc     relinquishes bus master status\n * Input    none\n * Output   none\n */\nvoid twi_stop(void)\n{\n  // send stop condition\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);\n\n  // wait for stop condition to be exectued on bus\n  // TWINT is not set after a stop condition!\n  // We cannot use micros() from an ISR, so approximate the timeout with cycle-counted delays\n  const uint8_t us_per_loop = 8;\n  uint32_t counter = (twi_timeout_us + us_per_loop - 1)/us_per_loop; // Round up\n  while(TWCR & _BV(TWSTO)){\n    if(twi_timeout_us > 0ul){\n      if (counter > 0ul){\n        _delay_us(10);\n        counter--;\n      } else {\n        twi_handleTimeout(twi_do_reset_on_timeout);\n        return;\n      }\n    }\n  }\n\n  // update twi state\n  twi_state = TWI_READY;\n}\n\n/* \n * Function twi_releaseBus\n * Desc     releases bus control\n * Input    none\n * Output   none\n */\nvoid twi_releaseBus(void)\n{\n  // release bus\n  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);\n\n  // update twi state\n  twi_state = TWI_READY;\n}\n\n/* \n * Function twi_setTimeoutInMicros\n * Desc     set a timeout for while loops that twi might get stuck in\n * Input    timeout value in microseconds (0 means never time out)\n * Input    reset_with_timeout: true causes timeout events to reset twi\n * Output   none\n */\nvoid twi_setTimeoutInMicros(uint32_t timeout, bool reset_with_timeout){\n  twi_timed_out_flag = false;\n  twi_timeout_us = timeout;\n  twi_do_reset_on_timeout = reset_with_timeout;\n}\n\n/* \n * Function twi_handleTimeout\n * Desc     this gets called whenever a while loop here has lasted longer than\n *          twi_timeout_us microseconds. always sets twi_timed_out_flag\n * Input    reset: true causes this function to reset the twi hardware interface\n * Output   none\n */\nvoid twi_handleTimeout(bool reset){\n  twi_timed_out_flag = true;\n\n  if (reset) {\n    // remember bitrate and address settings\n    uint8_t previous_TWBR = TWBR;\n    uint8_t previous_TWAR = TWAR;\n\n    // reset the interface\n    twi_disable();\n    twi_init();\n\n    // reapply the previous register values\n    TWAR = previous_TWAR;\n    TWBR = previous_TWBR;\n  }\n}\n\n/*\n * Function twi_manageTimeoutFlag\n * Desc     returns true if twi has seen a timeout\n *          optionally clears the timeout flag\n * Input    clear_flag: true if we should reset the hardware\n * Output   none\n */\nbool twi_manageTimeoutFlag(bool clear_flag){\n  bool flag = twi_timed_out_flag;\n  if (clear_flag){\n    twi_timed_out_flag = false;\n  }\n  return(flag);\n}\n\nISR(TWI_vect)\n{\n  switch(TW_STATUS){\n    // All Master\n    case TW_START:     // sent start condition\n    case TW_REP_START: // sent repeated start condition\n      // copy device address and r/w bit to output register and ack\n      TWDR = twi_slarw;\n      twi_reply(1);\n      break;\n\n    // Master Transmitter\n    case TW_MT_SLA_ACK:  // slave receiver acked address\n    case TW_MT_DATA_ACK: // slave receiver acked data\n      // if there is data to send, send it, otherwise stop \n      if(twi_masterBufferIndex < twi_masterBufferLength){\n        // copy data to output register and ack\n        TWDR = twi_masterBuffer[twi_masterBufferIndex++];\n        twi_reply(1);\n      }else{\n        if (twi_sendStop){\n          twi_stop();\n       } else {\n         twi_inRepStart = true;\t// we're gonna send the START\n         // don't enable the interrupt. We'll generate the start, but we\n         // avoid handling the interrupt until we're in the next transaction,\n         // at the point where we would normally issue the start.\n         TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;\n         twi_state = TWI_READY;\n        }\n      }\n      break;\n    case TW_MT_SLA_NACK:  // address sent, nack received\n      twi_error = TW_MT_SLA_NACK;\n      twi_stop();\n      break;\n    case TW_MT_DATA_NACK: // data sent, nack received\n      twi_error = TW_MT_DATA_NACK;\n      twi_stop();\n      break;\n    case TW_MT_ARB_LOST: // lost bus arbitration\n      twi_error = TW_MT_ARB_LOST;\n      twi_releaseBus();\n      break;\n\n    // Master Receiver\n    case TW_MR_DATA_ACK: // data received, ack sent\n      // put byte into buffer\n      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n      __attribute__ ((fallthrough));\n    case TW_MR_SLA_ACK:  // address sent, ack received\n      // ack if more bytes are expected, otherwise nack\n      if(twi_masterBufferIndex < twi_masterBufferLength){\n        twi_reply(1);\n      }else{\n        twi_reply(0);\n      }\n      break;\n    case TW_MR_DATA_NACK: // data received, nack sent\n      // put final byte into buffer\n      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;\n      if (twi_sendStop){\n        twi_stop();\n      } else {\n        twi_inRepStart = true;\t// we're gonna send the START\n        // don't enable the interrupt. We'll generate the start, but we\n        // avoid handling the interrupt until we're in the next transaction,\n        // at the point where we would normally issue the start.\n        TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;\n        twi_state = TWI_READY;\n      }\n      break;\n    case TW_MR_SLA_NACK: // address sent, nack received\n      twi_stop();\n      break;\n    // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case\n\n    // Slave Receiver\n    case TW_SR_SLA_ACK:   // addressed, returned ack\n    case TW_SR_GCALL_ACK: // addressed generally, returned ack\n    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack\n    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack\n      // enter slave receiver mode\n      twi_state = TWI_SRX;\n      // indicate that rx buffer can be overwritten and ack\n      twi_rxBufferIndex = 0;\n      twi_reply(1);\n      break;\n    case TW_SR_DATA_ACK:       // data received, returned ack\n    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack\n      // if there is still room in the rx buffer\n      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){\n        // put byte in buffer and ack\n        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;\n        twi_reply(1);\n      }else{\n        // otherwise nack\n        twi_reply(0);\n      }\n      break;\n    case TW_SR_STOP: // stop or repeated start condition received\n      // ack future responses and leave slave receiver state\n      twi_releaseBus();\n      // put a null char after data if there's room\n      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){\n        twi_rxBuffer[twi_rxBufferIndex] = '\\0';\n      }\n      // callback to user defined callback\n      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);\n      // since we submit rx buffer to \"wire\" library, we can reset it\n      twi_rxBufferIndex = 0;\n      break;\n    case TW_SR_DATA_NACK:       // data received, returned nack\n    case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack\n      // nack back at master\n      twi_reply(0);\n      break;\n    \n    // Slave Transmitter\n    case TW_ST_SLA_ACK:          // addressed, returned ack\n    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack\n      // enter slave transmitter mode\n      twi_state = TWI_STX;\n      // ready the tx buffer index for iteration\n      twi_txBufferIndex = 0;\n      // set tx buffer length to be zero, to verify if user changes it\n      twi_txBufferLength = 0;\n      // request for txBuffer to be filled and length to be set\n      // note: user must call twi_transmit(bytes, length) to do this\n      twi_onSlaveTransmit();\n      // if they didn't change buffer & length, initialize it\n      if(0 == twi_txBufferLength){\n        twi_txBufferLength = 1;\n        twi_txBuffer[0] = 0x00;\n      }\n      __attribute__ ((fallthrough));\t\t  \n      // transmit first byte from buffer, fall\n    case TW_ST_DATA_ACK: // byte sent, ack returned\n      // copy data to output register\n      TWDR = twi_txBuffer[twi_txBufferIndex++];\n      // if there is more to send, ack, otherwise nack\n      if(twi_txBufferIndex < twi_txBufferLength){\n        twi_reply(1);\n      }else{\n        twi_reply(0);\n      }\n      break;\n    case TW_ST_DATA_NACK: // received nack, we are done \n    case TW_ST_LAST_DATA: // received ack, but we are done already!\n      // ack future responses\n      twi_reply(1);\n      // leave slave receiver state\n      twi_state = TWI_READY;\n      break;\n\n    // All\n    case TW_NO_INFO:   // no state information\n      break;\n    case TW_BUS_ERROR: // bus error, illegal stop/start\n      twi_error = TW_BUS_ERROR;\n      twi_stop();\n      break;\n  }\n}\n"}],"trace":"{\"model\":\"LabB_PIDOverRobot\",\"sources\":[\"LabB_PIDOverRobot.c\",\"LabB_PIDOverRobot.h\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"InternalData\",\"Default\",\"GlobalParameters\",\"LocalParameters\"],\"sidPrefixes\":[\"LabB_PIDOverRobot\",\"C\"],\"fileRecords\":{\"1\":{\"records\":[{\"tk\":[52,3,52,34],\"els\":[\"1:606\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[52,35,52,38],\"els\":[\"1:606\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[52,38,52,39],\"els\":[\"1:606\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[53,3,53,34],\"els\":[\"1:628\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[53,35,53,40],\"els\":[\"1:628\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[53,40,53,41],\"els\":[\"1:628\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[54,3,54,34],\"els\":[\"1:629\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[54,35,54,41],\"els\":[\"1:629\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[54,41,54,42],\"els\":[\"1:629\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[55,3,55,34],\"els\":[\"1:630:187\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[55,35,55,40],\"els\":[\"1:630:187\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[55,40,55,41],\"els\":[\"1:630:187\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[56,3,56,34],\"els\":[\"1:630:188\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[56,35,56,40],\"els\":[\"1:630:188\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[56,40,56,41],\"els\":[\"1:630:188\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,3,57,11],\"els\":[\"1:616\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,12,57,43],\"els\":[\"1:616\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[57,43,57,44],\"els\":[\"1:616\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[59,3,59,11],\"els\":[\"1:565:843\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[59,12,59,29],\"els\":[\"1:565:843\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[59,29,59,30],\"els\":[\"1:565:843\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[60,3,60,11],\"els\":[\"1:565:737\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[60,12,60,25],\"els\":[\"1:565:737\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[60,25,60,26],\"els\":[\"1:565:737\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[65,3,65,11],\"els\":[\"1:621\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[65,12,65,21],\"els\":[\"1:621\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[65,21,65,22],\"els\":[\"1:621\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[68,3,68,11],\"els\":[\"1:620\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[68,12,68,24],\"els\":[\"1:620\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[68,24,68,25],\"els\":[\"1:620\"],\"ct\":{\"0\":2,\"1\":1}},{\"tk\":[71,3,71,11],\"els\":[\"1:565:688\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[71,12,71,27],\"els\":[\"1:565:688\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[71,27,71,28],\"els\":[\"1:565:688\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[74,3,74,11],\"els\":[\"1:565:791\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[74,12,74,27],\"els\":[\"1:565:791\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[74,27,74,28],\"els\":[\"1:565:791\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[77,3,77,11],\"els\":[\"1:565:737\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[77,12,77,43],\"els\":[\"1:565:737\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[77,43,77,44],\"els\":[\"1:565:737\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[81,3,81,11],\"els\":[\"1:565:843\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[81,12,81,43],\"els\":[\"1:565:843\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[81,43,81,44],\"els\":[\"1:565:843\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[85,3,85,11],\"els\":[\"1:565:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[85,12,85,28],\"els\":[\"1:565:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[85,28,85,29],\"els\":[\"1:565:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[88,3,88,11],\"els\":[\"1:565:923\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[88,12,88,43],\"els\":[\"1:565:923\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[88,43,88,44],\"els\":[\"1:565:923\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[92,3,92,11],\"els\":[\"1:565:882\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[92,12,92,27],\"els\":[\"1:565:882\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[92,27,92,28],\"els\":[\"1:565:882\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[95,3,95,11],\"els\":[\"1:565:913\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[95,12,95,27],\"els\":[\"1:565:913\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[95,27,95,28],\"els\":[\"1:565:913\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[98,3,98,11],\"els\":[\"1:565:923\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[98,12,98,43],\"els\":[\"1:565:923\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[98,43,98,44],\"els\":[\"1:565:923\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[102,3,102,11],\"els\":[\"1:630:189\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[102,12,102,43],\"els\":[\"1:630:189\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[102,43,102,44],\"els\":[\"1:630:189\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[106,3,106,9],\"els\":[\"1:606\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[106,10,106,33],\"els\":[\"1:606\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[106,33,106,34],\"els\":[\"1:606\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[109,3,109,11],\"els\":[\"1:630:185:3\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[109,12,109,26],\"els\":[\"1:630:185:3\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[109,26,109,27],\"els\":[\"1:630:185:3\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[112,3,112,11],\"els\":[\"1:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[112,12,112,43],\"els\":[\"1:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[112,43,112,44],\"els\":[\"1:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[116,3,116,11],\"els\":[\"1:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[116,12,116,43],\"els\":[\"1:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[116,43,116,44],\"els\":[\"1:616\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[120,3,120,11],\"els\":[\"1:565:843\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[120,12,120,30],\"els\":[\"1:565:843\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[120,30,120,31],\"els\":[\"1:565:843\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[123,3,123,11],\"els\":[\"1:565:737\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[123,12,123,26],\"els\":[\"1:565:737\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[123,26,123,27],\"els\":[\"1:565:737\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[126,3,126,11],\"els\":[\"1:619\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[126,12,126,33],\"els\":[\"1:619\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[126,33,126,34],\"els\":[\"1:619\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[129,3,129,11],\"els\":[\"1:618\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[129,12,129,36],\"els\":[\"1:618\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[129,36,129,37],\"els\":[\"1:618\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[133,3,133,11],\"els\":[\"1:630:189\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[133,12,133,43],\"els\":[\"1:630:189\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[133,43,133,44],\"els\":[\"1:630:189\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[137,3,137,11],\"els\":[\"1:630:190\"],\"ct\":{\"0\":3,\"1\":1}},{\"tk\":[137,12,137,43],\"els\":[\"1:630:190\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[137,43,137,44],\"els\":[\"1:630:190\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[141,3,141,10],\"els\":[\"1:576\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[141,11,141,27],\"els\":[\"1:576\"],\"ct\":{\"1\":1,\"0\":3}},{\"tk\":[141,27,141,28],\"els\":[\"1:576\"],\"ct\":{\"0\":3,\"1\":1}}]},\"0\":{\"records\":[{\"tk\":[72,3,72,24],\"els\":[\"0:565:882#out:1\"]},{\"tk\":[72,25,72,26],\"els\":[\"0:565:882\"]},{\"tk\":[72,28,72,47],\"els\":[\"0:565:688\"]},{\"tk\":[72,48,72,63],\"els\":[\"0:565:688\"]},{\"tk\":[72,64,72,65],\"els\":[\"0:565:688\"]},{\"tk\":[73,5,73,28],\"els\":[\"0:616\"]},{\"tk\":[73,29,73,60],\"els\":[\"0:616\"]},{\"tk\":[73,61,73,62],\"els\":[\"0:565:738\"]},{\"tk\":[74,5,74,28],\"els\":[\"0:565:737\"]},{\"tk\":[74,29,74,42],\"els\":[\"0:565:737\"]},{\"tk\":[74,44,74,45],\"els\":[\"0:565:882\"]},{\"tk\":[74,46,74,65],\"els\":[\"0:565:882\"]},{\"tk\":[74,66,74,81],\"els\":[\"0:565:882\"]},{\"tk\":[81,3,81,12],\"els\":[\"0:565:3526#out:1\"]},{\"tk\":[81,13,81,14],\"els\":[\"0:565:3526\"]},{\"tk\":[81,16,81,35],\"els\":[\"0:565:913\"]},{\"tk\":[81,36,81,51],\"els\":[\"0:565:913\"]},{\"tk\":[81,52,81,53],\"els\":[\"0:565:913\"]},{\"tk\":[82,16,82,39],\"els\":[\"0:616\"]},{\"tk\":[82,40,82,71],\"els\":[\"0:616\"]},{\"tk\":[82,72,82,73],\"els\":[\"0:565:3526\"]},{\"tk\":[83,16,83,39],\"els\":[\"0:565:843\"]},{\"tk\":[83,40,83,57],\"els\":[\"0:565:843\"]},{\"tk\":[83,59,83,60],\"els\":[\"0:565:3526\"]},{\"tk\":[84,5,84,26],\"els\":[\"0:565:882#out:1\"]},{\"tk\":[87,3,87,5],\"els\":[\"0:565:923\"]},{\"tk\":[87,7,87,16],\"els\":[\"0:565:3526#out:1\"]},{\"tk\":[87,17,87,18],\"els\":[\"0:565:923\"]},{\"tk\":[87,19,87,38],\"els\":[\"0:565:923\"]},{\"tk\":[87,39,87,70],\"els\":[\"0:565:923\"]},{\"tk\":[88,5,88,35],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[88,36,88,37],\"els\":[\"0:565:923\"]},{\"tk\":[89,7,89,26],\"els\":[\"0:565:923\"]},{\"tk\":[89,27,89,58],\"els\":[\"0:565:923\"]},{\"tk\":[90,10,90,12],\"els\":[\"0:565:923\"]},{\"tk\":[90,14,90,23],\"els\":[\"0:565:3526#out:1\"]},{\"tk\":[90,24,90,25],\"els\":[\"0:565:923\"]},{\"tk\":[90,26,90,45],\"els\":[\"0:565:923\"]},{\"tk\":[90,46,90,77],\"els\":[\"0:565:923\"]},{\"tk\":[91,5,91,35],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[91,36,91,37],\"els\":[\"0:565:923\"]},{\"tk\":[92,7,92,26],\"els\":[\"0:565:923\"]},{\"tk\":[92,27,92,58],\"els\":[\"0:565:923\"]},{\"tk\":[94,5,94,35],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[94,36,94,37],\"els\":[\"0:565:923\"]},{\"tk\":[94,38,94,47],\"els\":[\"0:565:3526#out:1\"]},{\"tk\":[102,3,102,6],\"els\":[\"0:577\"]},{\"tk\":[102,7,102,8],\"els\":[\"0:577\"]},{\"tk\":[102,9,102,10],\"els\":[\"0:577\"]},{\"tk\":[102,19,102,24],\"els\":[\"0:577\"]},{\"tk\":[102,26,102,56],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[102,57,102,58],\"els\":[\"0:598\"]},{\"tk\":[102,59,102,64],\"els\":[\"0:598\"]},{\"tk\":[102,66,102,67],\"els\":[\"0:598\"]},{\"tk\":[102,68,102,75],\"els\":[\"0:598\"]},{\"tk\":[103,3,103,5],\"els\":[\"0:577\"]},{\"tk\":[103,7,103,15],\"els\":[\"0:577\"]},{\"tk\":[103,16,103,19],\"els\":[\"0:577\"]},{\"tk\":[103,21,103,23],\"els\":[\"0:577\"]},{\"tk\":[103,24,103,32],\"els\":[\"0:577\"]},{\"tk\":[103,33,103,36],\"els\":[\"0:577\"]},{\"tk\":[104,5,104,8],\"els\":[\"0:577\"]},{\"tk\":[104,9,104,10],\"els\":[\"0:577\"]},{\"tk\":[104,11,104,15],\"els\":[\"0:577\"]},{\"tk\":[106,5,106,8],\"els\":[\"0:577\"]},{\"tk\":[106,9,106,10],\"els\":[\"0:577\"]},{\"tk\":[106,11,106,12],\"els\":[\"0:577\"]},{\"tk\":[106,21,106,25],\"els\":[\"0:577\"]},{\"tk\":[106,26,106,29],\"els\":[\"0:577\"]},{\"tk\":[106,31,106,38],\"els\":[\"0:577\"]},{\"tk\":[109,3,109,26],\"els\":[\"0:583#out:1\"]},{\"tk\":[109,27,109,28],\"els\":[\"0:577\"]},{\"tk\":[109,29,109,32],\"els\":[\"0:577\"]},{\"tk\":[109,33,109,34],\"els\":[\"0:577\"]},{\"tk\":[109,35,109,39],\"els\":[\"0:577\"]},{\"tk\":[109,40,109,41],\"els\":[\"0:577\"]},{\"tk\":[109,42,109,43],\"els\":[\"0:577\"]},{\"tk\":[109,52,109,53],\"els\":[\"0:577\"]},{\"tk\":[109,53,109,54],\"els\":[\"0:577\"]},{\"tk\":[109,62,109,63],\"els\":[\"0:577\"]},{\"tk\":[109,72,109,73],\"els\":[\"0:577\"]},{\"tk\":[109,73,109,76],\"els\":[\"0:577\"]},{\"tk\":[110,5,110,6],\"els\":[\"0:577\"]},{\"tk\":[110,15,110,18],\"els\":[\"0:577\"]},{\"tk\":[118,9,118,10],\"els\":[\"0:606\"]},{\"tk\":[118,10,118,11],\"els\":[\"0:606\"]},{\"tk\":[118,13,118,14],\"els\":[\"0:606\",\"0:584:4\"]},{\"tk\":[118,15,118,16],\"els\":[\"0:584:4\"]},{\"tk\":[118,25,118,48],\"els\":[\"0:583#out:1\"]},{\"tk\":[118,49,118,51],\"els\":[\"0:584:4\"]},{\"tk\":[118,52,118,53],\"els\":[\"0:584:4\"]},{\"tk\":[119,9,119,10],\"els\":[\"0:606\"]},{\"tk\":[119,10,119,11],\"els\":[\"0:606\"]},{\"tk\":[119,13,119,14],\"els\":[\"0:606\",\"0:585:4\"]},{\"tk\":[119,15,119,16],\"els\":[\"0:585:4\"]},{\"tk\":[119,24,119,47],\"els\":[\"0:583#out:1\"]},{\"tk\":[129,3,129,16],\"els\":[\"0:628\"]},{\"tk\":[129,17,129,18],\"els\":[\"0:628\",\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\Encoder_arduino.m:4576-4618,#186\"]},{\"tk\":[129,19,129,29],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\Encoder_arduino.m:4580-4618,#186\",\"0:628\"]},{\"tk\":[129,30,129,33],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\Encoder_arduino.m:4606-4617,#186\",\"0:628\"]},{\"tk\":[138,3,138,6],\"els\":[\"0:577\"]},{\"tk\":[138,7,138,8],\"els\":[\"0:578\"]},{\"tk\":[138,9,138,10],\"els\":[\"0:578\"]},{\"tk\":[138,19,138,24],\"els\":[\"0:578\"]},{\"tk\":[138,26,138,45],\"els\":[\"0:619\"]},{\"tk\":[138,46,138,67],\"els\":[\"0:619\"]},{\"tk\":[138,68,138,69],\"els\":[\"0:619\"]},{\"tk\":[138,70,138,71],\"els\":[\"0:627\"]},{\"tk\":[139,5,139,18],\"els\":[\"0:628\"]},{\"tk\":[139,19,139,20],\"els\":[\"0:620\"]},{\"tk\":[139,21,139,40],\"els\":[\"0:620\"]},{\"tk\":[139,41,139,53],\"els\":[\"0:620\"]},{\"tk\":[139,54,139,55],\"els\":[\"0:599\"]},{\"tk\":[139,56,139,61],\"els\":[\"0:599\"]},{\"tk\":[139,63,139,64],\"els\":[\"0:599\"]},{\"tk\":[139,65,139,72],\"els\":[\"0:599\"]},{\"tk\":[140,3,140,5],\"els\":[\"0:578\"]},{\"tk\":[140,7,140,15],\"els\":[\"0:578\"]},{\"tk\":[140,16,140,19],\"els\":[\"0:577\"]},{\"tk\":[140,21,140,23],\"els\":[\"0:578\"]},{\"tk\":[140,24,140,32],\"els\":[\"0:578\"]},{\"tk\":[140,33,140,36],\"els\":[\"0:577\"]},{\"tk\":[141,5,141,8],\"els\":[\"0:577\"]},{\"tk\":[141,9,141,10],\"els\":[\"0:578\"]},{\"tk\":[141,11,141,15],\"els\":[\"0:578\"]},{\"tk\":[143,5,143,8],\"els\":[\"0:577\"]},{\"tk\":[143,9,143,10],\"els\":[\"0:578\"]},{\"tk\":[143,11,143,12],\"els\":[\"0:578\"]},{\"tk\":[143,21,143,25],\"els\":[\"0:578\"]},{\"tk\":[143,26,143,29],\"els\":[\"0:577\"]},{\"tk\":[143,31,143,38],\"els\":[\"0:578\"]},{\"tk\":[146,3,146,26],\"els\":[\"0:583#out:1\"]},{\"tk\":[146,27,146,28],\"els\":[\"0:578\"]},{\"tk\":[146,29,146,32],\"els\":[\"0:577\"]},{\"tk\":[146,33,146,34],\"els\":[\"0:578\"]},{\"tk\":[146,35,146,39],\"els\":[\"0:578\"]},{\"tk\":[146,40,146,41],\"els\":[\"0:578\"]},{\"tk\":[146,42,146,43],\"els\":[\"0:578\"]},{\"tk\":[146,52,146,53],\"els\":[\"0:578\"]},{\"tk\":[146,53,146,54],\"els\":[\"0:578\"]},{\"tk\":[146,62,146,63],\"els\":[\"0:578\"]},{\"tk\":[146,72,146,73],\"els\":[\"0:578\"]},{\"tk\":[146,73,146,76],\"els\":[\"0:577\"]},{\"tk\":[147,5,147,6],\"els\":[\"0:578\"]},{\"tk\":[147,15,147,18],\"els\":[\"0:577\"]},{\"tk\":[155,9,155,10],\"els\":[\"0:606\"]},{\"tk\":[155,10,155,11],\"els\":[\"0:606\"]},{\"tk\":[155,13,155,14],\"els\":[\"0:606\",\"0:590:4\"]},{\"tk\":[155,15,155,16],\"els\":[\"0:590:4\"]},{\"tk\":[155,25,155,48],\"els\":[\"0:583#out:1\"]},{\"tk\":[155,49,155,51],\"els\":[\"0:590:4\"]},{\"tk\":[155,52,155,53],\"els\":[\"0:590:4\"]},{\"tk\":[156,9,156,10],\"els\":[\"0:606\"]},{\"tk\":[156,10,156,11],\"els\":[\"0:606\"]},{\"tk\":[156,13,156,14],\"els\":[\"0:606\",\"0:591:4\"]},{\"tk\":[156,15,156,16],\"els\":[\"0:591:4\"]},{\"tk\":[156,24,156,47],\"els\":[\"0:583#out:1\"]},{\"tk\":[162,3,162,6],\"els\":[\"0:577\"]},{\"tk\":[162,7,162,8],\"els\":[\"0:579\"]},{\"tk\":[162,9,162,10],\"els\":[\"0:579\"]},{\"tk\":[162,19,162,24],\"els\":[\"0:579\"]},{\"tk\":[162,26,162,49],\"els\":[\"0:616\"]},{\"tk\":[162,50,162,81],\"els\":[\"0:616\"]},{\"tk\":[163,5,163,6],\"els\":[\"0:600\"]},{\"tk\":[163,7,163,12],\"els\":[\"0:600\"]},{\"tk\":[163,14,163,15],\"els\":[\"0:600\"]},{\"tk\":[163,16,163,23],\"els\":[\"0:600\"]},{\"tk\":[164,3,164,5],\"els\":[\"0:579\"]},{\"tk\":[164,7,164,15],\"els\":[\"0:579\"]},{\"tk\":[164,16,164,19],\"els\":[\"0:577\"]},{\"tk\":[164,21,164,23],\"els\":[\"0:579\"]},{\"tk\":[164,24,164,32],\"els\":[\"0:579\"]},{\"tk\":[164,33,164,36],\"els\":[\"0:577\"]},{\"tk\":[165,5,165,8],\"els\":[\"0:577\"]},{\"tk\":[165,9,165,10],\"els\":[\"0:579\"]},{\"tk\":[165,11,165,15],\"els\":[\"0:579\"]},{\"tk\":[167,5,167,8],\"els\":[\"0:577\"]},{\"tk\":[167,9,167,10],\"els\":[\"0:579\"]},{\"tk\":[167,11,167,12],\"els\":[\"0:579\"]},{\"tk\":[167,21,167,25],\"els\":[\"0:579\"]},{\"tk\":[167,26,167,29],\"els\":[\"0:577\"]},{\"tk\":[167,31,167,38],\"els\":[\"0:579\"]},{\"tk\":[170,3,170,26],\"els\":[\"0:583#out:1\"]},{\"tk\":[170,27,170,28],\"els\":[\"0:579\"]},{\"tk\":[170,29,170,32],\"els\":[\"0:577\"]},{\"tk\":[170,33,170,34],\"els\":[\"0:579\"]},{\"tk\":[170,35,170,39],\"els\":[\"0:579\"]},{\"tk\":[170,40,170,41],\"els\":[\"0:579\"]},{\"tk\":[170,42,170,43],\"els\":[\"0:579\"]},{\"tk\":[170,52,170,53],\"els\":[\"0:579\"]},{\"tk\":[170,53,170,54],\"els\":[\"0:579\"]},{\"tk\":[170,62,170,63],\"els\":[\"0:579\"]},{\"tk\":[170,72,170,73],\"els\":[\"0:579\"]},{\"tk\":[170,73,170,76],\"els\":[\"0:577\"]},{\"tk\":[171,5,171,6],\"els\":[\"0:579\"]},{\"tk\":[171,15,171,18],\"els\":[\"0:577\"]},{\"tk\":[183,3,183,5],\"els\":[\"0:606\"]},{\"tk\":[183,7,183,30],\"els\":[\"0:606\"]},{\"tk\":[183,31,183,34],\"els\":[\"0:606\"]},{\"tk\":[183,44,183,46],\"els\":[\"0:606\"]},{\"tk\":[184,7,184,26],\"els\":[\"0:606\"]},{\"tk\":[184,27,184,50],\"els\":[\"0:606\"]},{\"tk\":[185,5,185,28],\"els\":[\"0:606\"]},{\"tk\":[185,29,185,32],\"els\":[\"0:606\"]},{\"tk\":[185,33,185,41],\"els\":[\"0:606\"]},{\"tk\":[185,42,185,43],\"els\":[\"0:606\"]},{\"tk\":[186,7,186,26],\"els\":[\"0:606\"]},{\"tk\":[186,27,186,50],\"els\":[\"0:606\"]},{\"tk\":[189,9,189,10],\"els\":[\"0:606\"]},{\"tk\":[189,10,189,11],\"els\":[\"0:606\"]},{\"tk\":[189,13,189,14],\"els\":[\"0:606\"]},{\"tk\":[189,15,189,34],\"els\":[\"0:576\"]},{\"tk\":[189,35,189,51],\"els\":[\"0:576\"]},{\"tk\":[190,9,190,10],\"els\":[\"0:606\"]},{\"tk\":[190,10,190,11],\"els\":[\"0:606\"]},{\"tk\":[190,13,190,14],\"els\":[\"0:606\"]},{\"tk\":[190,15,190,16],\"els\":[\"0:592:4\"]},{\"tk\":[190,25,190,48],\"els\":[\"0:583#out:1\"]},{\"tk\":[190,49,190,51],\"els\":[\"0:592:4\"]},{\"tk\":[190,52,190,53],\"els\":[\"0:592:4\"]},{\"tk\":[191,9,191,10],\"els\":[\"0:606\"]},{\"tk\":[191,10,191,11],\"els\":[\"0:606\"]},{\"tk\":[191,13,191,14],\"els\":[\"0:606\"]},{\"tk\":[191,15,191,16],\"els\":[\"0:593:4\"]},{\"tk\":[191,24,191,47],\"els\":[\"0:583#out:1\"]},{\"tk\":[192,9,192,10],\"els\":[\"0:606\"]},{\"tk\":[192,10,192,11],\"els\":[\"0:606\"]},{\"tk\":[192,13,192,14],\"els\":[\"0:606\"]},{\"tk\":[192,15,192,19],\"els\":[\"0:606\"]},{\"tk\":[193,9,193,10],\"els\":[\"0:606\"]},{\"tk\":[193,10,193,11],\"els\":[\"0:606\"]},{\"tk\":[193,13,193,14],\"els\":[\"0:606\"]},{\"tk\":[193,15,193,17],\"els\":[\"0:606\"]},{\"tk\":[194,9,194,10],\"els\":[\"0:606\"]},{\"tk\":[194,10,194,11],\"els\":[\"0:606\"]},{\"tk\":[194,13,194,14],\"els\":[\"0:606\"]},{\"tk\":[194,15,194,19],\"els\":[\"0:606\"]},{\"tk\":[195,9,195,10],\"els\":[\"0:606\"]},{\"tk\":[195,10,195,12],\"els\":[\"0:606\"]},{\"tk\":[195,14,195,15],\"els\":[\"0:606\"]},{\"tk\":[195,16,195,18],\"els\":[\"0:606\"]},{\"tk\":[196,9,196,10],\"els\":[\"0:606\"]},{\"tk\":[196,10,196,12],\"els\":[\"0:606\"]},{\"tk\":[196,14,196,15],\"els\":[\"0:606\"]},{\"tk\":[196,16,196,20],\"els\":[\"0:606\"]},{\"tk\":[197,9,197,10],\"els\":[\"0:606\"]},{\"tk\":[197,10,197,12],\"els\":[\"0:606\"]},{\"tk\":[197,14,197,15],\"els\":[\"0:606\"]},{\"tk\":[197,16,197,18],\"els\":[\"0:606\"]},{\"tk\":[198,9,198,10],\"els\":[\"0:606\"]},{\"tk\":[198,10,198,12],\"els\":[\"0:606\"]},{\"tk\":[198,14,198,15],\"els\":[\"0:606\"]},{\"tk\":[198,16,198,20],\"els\":[\"0:588:4\"]},{\"tk\":[199,9,199,10],\"els\":[\"0:606\"]},{\"tk\":[199,10,199,12],\"els\":[\"0:606\"]},{\"tk\":[199,14,199,15],\"els\":[\"0:606\"]},{\"tk\":[199,16,199,18],\"els\":[\"0:589:4\"]},{\"tk\":[200,3,200,18],\"els\":[\"0:606\"]},{\"tk\":[200,19,200,42],\"els\":[\"0:606\"]},{\"tk\":[200,43,200,46],\"els\":[\"0:606\"]},{\"tk\":[200,60,200,61],\"els\":[\"0:606\"]},{\"tk\":[200,61,200,62],\"els\":[\"0:606\"]},{\"tk\":[200,65,200,69],\"els\":[\"0:606\"]},{\"tk\":[201,19,201,42],\"els\":[\"0:606\"]},{\"tk\":[201,43,201,46],\"els\":[\"0:606\"]},{\"tk\":[202,19,202,42],\"els\":[\"0:606\"]},{\"tk\":[202,43,202,46],\"els\":[\"0:606\"]},{\"tk\":[203,19,203,42],\"els\":[\"0:606\"]},{\"tk\":[203,43,203,46],\"els\":[\"0:606\"]},{\"tk\":[204,19,204,42],\"els\":[\"0:606\"]},{\"tk\":[204,43,204,46],\"els\":[\"0:606\"]},{\"tk\":[204,63,204,66],\"els\":[\"0:606\"]},{\"tk\":[204,68,204,74],\"els\":[\"0:606\"]},{\"tk\":[209,3,209,12],\"els\":[\"0:565:3526#out:1\"]},{\"tk\":[209,13,209,14],\"els\":[\"0:565:616\"]},{\"tk\":[209,16,209,46],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[209,47,209,48],\"els\":[\"0:565:617\"]},{\"tk\":[209,49,209,58],\"els\":[\"0:565:3526#out:1\"]},{\"tk\":[209,60,209,61],\"els\":[\"0:565:616\"]},{\"tk\":[210,5,210,24],\"els\":[\"0:565:616\"]},{\"tk\":[210,25,210,41],\"els\":[\"0:565:616\"]},{\"tk\":[215,3,215,19],\"els\":[\"0:565:791#out:1\"]},{\"tk\":[215,20,215,21],\"els\":[\"0:565:791\"]},{\"tk\":[215,22,215,41],\"els\":[\"0:565:791\"]},{\"tk\":[215,42,215,57],\"els\":[\"0:565:791\"]},{\"tk\":[215,58,215,59],\"els\":[\"0:565:791\"]},{\"tk\":[216,5,216,28],\"els\":[\"0:616\"]},{\"tk\":[216,29,216,60],\"els\":[\"0:616\"]},{\"tk\":[222,3,222,33],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[222,34,222,36],\"els\":[\"0:511\"]},{\"tk\":[222,37,222,38],\"els\":[\"0:190\"]},{\"tk\":[222,48,222,49],\"els\":[\"0:190\"]},{\"tk\":[222,58,222,62],\"els\":[\"0:190\"]},{\"tk\":[223,6,223,29],\"els\":[\"0:616\"]},{\"tk\":[223,30,223,61],\"els\":[\"0:616\"]},{\"tk\":[223,63,223,64],\"els\":[\"0:190\"]},{\"tk\":[223,65,223,70],\"els\":[\"0:190\"]},{\"tk\":[233,3,233,19],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:2037-2085,#135\",\"0:629\"]},{\"tk\":[233,21,233,24],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:1831-1834,#135\"]},{\"tk\":[233,24,233,25],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:2037-2085,#135\",\"0:629\"]},{\"tk\":[233,25,233,26],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:2037-2085,#135\",\"0:629\"]},{\"tk\":[243,3,243,18],\"els\":[\"0:630:187\"]},{\"tk\":[243,19,243,20],\"els\":[\"0:630:187\"]},{\"tk\":[243,22,243,23],\"els\":[\"0:630:187\"]},{\"tk\":[243,32,243,62],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[243,63,243,64],\"els\":[\"0:630:185:2\"]},{\"tk\":[244,5,244,24],\"els\":[\"0:630:185:3\"]},{\"tk\":[244,25,244,39],\"els\":[\"0:630:185:3\"]},{\"tk\":[247,7,247,8],\"els\":[\"0:630:188\"]},{\"tk\":[247,10,247,33],\"els\":[\"0:630:188\"]},{\"tk\":[247,34,247,39],\"els\":[\"0:630:188\"]},{\"tk\":[248,8,248,20],\"els\":[\"0:630:188\"]},{\"tk\":[248,21,248,34],\"els\":[\"0:630:188\"]},{\"tk\":[248,35,248,36],\"els\":[\"0:630:188\"]},{\"tk\":[248,37,248,53],\"els\":[\"0:630:188\"]},{\"tk\":[248,54,248,57],\"els\":[\"0:630:188\"]},{\"tk\":[251,3,251,5],\"els\":[\"0:630:189\"]},{\"tk\":[251,7,251,37],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[251,38,251,39],\"els\":[\"0:630:189\"]},{\"tk\":[252,7,252,26],\"els\":[\"0:630:189\"]},{\"tk\":[252,27,252,58],\"els\":[\"0:630:189\"]},{\"tk\":[253,5,253,35],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[253,36,253,37],\"els\":[\"0:630:189\"]},{\"tk\":[254,7,254,26],\"els\":[\"0:630:189\"]},{\"tk\":[254,27,254,58],\"els\":[\"0:630:189\"]},{\"tk\":[255,10,255,12],\"els\":[\"0:630:189\"]},{\"tk\":[255,14,255,44],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[255,45,255,46],\"els\":[\"0:630:189\"]},{\"tk\":[256,14,256,33],\"els\":[\"0:630:189\"]},{\"tk\":[256,34,256,65],\"els\":[\"0:630:189\"]},{\"tk\":[257,5,257,35],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[257,36,257,37],\"els\":[\"0:630:189\"]},{\"tk\":[258,7,258,26],\"els\":[\"0:630:189\"]},{\"tk\":[258,27,258,58],\"els\":[\"0:630:189\"]},{\"tk\":[264,3,264,6],\"els\":[\"0:577\"]},{\"tk\":[264,7,264,8],\"els\":[\"0:630:190\"]},{\"tk\":[264,9,264,10],\"els\":[\"0:630:190\"]},{\"tk\":[264,19,264,24],\"els\":[\"0:630:190\"]},{\"tk\":[264,25,264,44],\"els\":[\"0:630:190\"]},{\"tk\":[264,45,264,76],\"els\":[\"0:630:190\"]},{\"tk\":[264,77,264,78],\"els\":[\"0:630:190\"]},{\"tk\":[265,25,265,55],\"els\":[\"0:630:189#out:1\"]},{\"tk\":[266,3,266,5],\"els\":[\"0:630:190\"]},{\"tk\":[266,7,266,15],\"els\":[\"0:630:190\"]},{\"tk\":[266,16,266,19],\"els\":[\"0:577\"]},{\"tk\":[266,21,266,23],\"els\":[\"0:630:190\"]},{\"tk\":[266,24,266,32],\"els\":[\"0:630:190\"]},{\"tk\":[266,33,266,36],\"els\":[\"0:577\"]},{\"tk\":[267,5,267,8],\"els\":[\"0:577\"]},{\"tk\":[267,9,267,10],\"els\":[\"0:630:190\"]},{\"tk\":[267,11,267,15],\"els\":[\"0:630:190\"]},{\"tk\":[269,5,269,8],\"els\":[\"0:577\"]},{\"tk\":[269,9,269,10],\"els\":[\"0:630:190\"]},{\"tk\":[269,11,269,12],\"els\":[\"0:630:190\"]},{\"tk\":[269,21,269,25],\"els\":[\"0:630:190\"]},{\"tk\":[269,26,269,29],\"els\":[\"0:577\"]},{\"tk\":[269,31,269,36],\"els\":[\"0:630:190\"]},{\"tk\":[275,3,275,22],\"els\":[\"0:630:188\"]},{\"tk\":[275,23,275,46],\"els\":[\"0:630:188\"]},{\"tk\":[275,47,275,52],\"els\":[\"0:630:188\"]},{\"tk\":[276,23,276,24],\"els\":[\"0:630:188\"]},{\"tk\":[276,32,276,35],\"els\":[\"0:577\"]},{\"tk\":[276,36,276,37],\"els\":[\"0:630:190\"]},{\"tk\":[276,38,276,42],\"els\":[\"0:630:190\"]},{\"tk\":[276,43,276,44],\"els\":[\"0:630:190\"]},{\"tk\":[276,54,276,55],\"els\":[\"0:630:190\"]},{\"tk\":[276,63,276,64],\"els\":[\"0:630:190\"]},{\"tk\":[276,64,276,65],\"els\":[\"0:630:190\"]},{\"tk\":[276,72,276,73],\"els\":[\"0:630:190\"]},{\"tk\":[277,5,277,6],\"els\":[\"0:630:190\"]},{\"tk\":[277,6,277,9],\"els\":[\"0:577\"]},{\"tk\":[277,21,277,22],\"els\":[\"0:630:190\"]},{\"tk\":[277,30,277,33],\"els\":[\"0:577\"]},{\"tk\":[286,3,286,26],\"els\":[\"0:616\"]},{\"tk\":[286,27,286,58],\"els\":[\"0:616\"]},{\"tk\":[286,59,286,61],\"els\":[\"0:616\"]},{\"tk\":[286,63,286,64],\"els\":[\"0:626\"]},{\"tk\":[286,73,286,76],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:1831-1834,#135\"]},{\"tk\":[286,76,286,77],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:2219-2222,#135\",\"0:629\"]},{\"tk\":[286,77,286,78],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:2219-2222,#135\",\"0:629\"]},{\"tk\":[286,80,286,81],\"els\":[\"0:617\"]},{\"tk\":[287,5,287,24],\"els\":[\"0:617\",\"0:621\"]},{\"tk\":[287,25,287,34],\"els\":[\"0:617\",\"0:621\"]},{\"tk\":[287,36,287,37],\"els\":[\"0:618\"]},{\"tk\":[288,5,288,24],\"els\":[\"0:618\"]},{\"tk\":[288,25,288,49],\"els\":[\"0:618\"]},{\"tk\":[288,50,288,51],\"els\":[\"0:616\"]},{\"tk\":[289,5,289,24],\"els\":[\"0:616\"]},{\"tk\":[289,25,289,56],\"els\":[\"0:616\"]},{\"tk\":[294,3,294,26],\"els\":[\"0:565:843\"]},{\"tk\":[294,27,294,44],\"els\":[\"0:565:843\"]},{\"tk\":[294,45,294,47],\"els\":[\"0:565:843\"]},{\"tk\":[294,49,294,58],\"els\":[\"0:565:3526#out:1\"]},{\"tk\":[294,59,294,60],\"els\":[\"0:565:618\"]},{\"tk\":[294,61,294,77],\"els\":[\"0:565:791#out:1\"]},{\"tk\":[294,79,294,80],\"els\":[\"0:565:843\"]},{\"tk\":[295,5,295,24],\"els\":[\"0:565:843\"]},{\"tk\":[295,25,295,43],\"els\":[\"0:565:843\"]},{\"tk\":[298,3,298,26],\"els\":[\"0:565:737\"]},{\"tk\":[298,27,298,40],\"els\":[\"0:565:737\"]},{\"tk\":[298,41,298,43],\"els\":[\"0:565:737\"]},{\"tk\":[298,44,298,63],\"els\":[\"0:565:737\"]},{\"tk\":[298,64,298,78],\"els\":[\"0:565:737\"]},{\"tk\":[298,79,298,80],\"els\":[\"0:565:737\"]},{\"tk\":[299,5,299,26],\"els\":[\"0:565:882#out:1\"]},{\"tk\":[334,5,334,28],\"els\":[\"0:628\"]},{\"tk\":[334,29,334,34],\"els\":[\"0:628\"]},{\"tk\":[334,35,334,57],\"els\":[\"0:628\"]},{\"tk\":[334,58,334,59],\"els\":[\"0:628\"]},{\"tk\":[334,60,334,65],\"els\":[\"0:628\"]},{\"tk\":[364,5,364,28],\"els\":[\"0:628\"]},{\"tk\":[364,29,364,34],\"els\":[\"0:628\"]},{\"tk\":[364,35,364,48],\"els\":[\"0:628\"]},{\"tk\":[364,49,364,50],\"els\":[\"0:628\"]},{\"tk\":[364,51,364,53],\"els\":[\"0:628\"]},{\"tk\":[374,5,374,13],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\Encoder_arduino.m:4089-4145,#163\",\"0:628\"]},{\"tk\":[374,14,374,17],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\Encoder_arduino.m:4113-4124,#163\",\"0:628\"]},{\"tk\":[374,19,374,23],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\Encoder_arduino.m:4126-4134,#163\",\"0:628\"]},{\"tk\":[374,25,374,29],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\Encoder_arduino.m:4136-4144,#163\",\"0:628\"]},{\"tk\":[381,5,381,28],\"els\":[\"0:628\"]},{\"tk\":[381,29,381,34],\"els\":[\"0:628\"]},{\"tk\":[381,35,381,50],\"els\":[\"0:628\"]},{\"tk\":[381,51,381,52],\"els\":[\"0:628\"]},{\"tk\":[381,53,381,57],\"els\":[\"0:628\"]},{\"tk\":[384,5,384,28],\"els\":[\"0:606\"]},{\"tk\":[384,29,384,32],\"els\":[\"0:606\"]},{\"tk\":[384,33,384,55],\"els\":[\"0:606\"]},{\"tk\":[384,56,384,57],\"els\":[\"0:606\"]},{\"tk\":[384,58,384,63],\"els\":[\"0:606\"]},{\"tk\":[385,5,385,28],\"els\":[\"0:606\"]},{\"tk\":[385,29,385,32],\"els\":[\"0:606\"]},{\"tk\":[385,33,385,41],\"els\":[\"0:606\"]},{\"tk\":[385,42,385,43],\"els\":[\"0:606\"]},{\"tk\":[386,7,386,26],\"els\":[\"0:606\"]},{\"tk\":[386,27,386,50],\"els\":[\"0:606\"]},{\"tk\":[387,5,387,28],\"els\":[\"0:606\"]},{\"tk\":[387,29,387,32],\"els\":[\"0:606\"]},{\"tk\":[387,33,387,46],\"els\":[\"0:606\"]},{\"tk\":[387,47,387,48],\"els\":[\"0:606\"]},{\"tk\":[387,49,387,51],\"els\":[\"0:606\"]},{\"tk\":[388,5,388,28],\"els\":[\"0:606\"]},{\"tk\":[388,29,388,32],\"els\":[\"0:606\"]},{\"tk\":[388,33,388,37],\"els\":[\"0:606\"]},{\"tk\":[388,38,388,39],\"els\":[\"0:606\"]},{\"tk\":[388,40,388,43],\"els\":[\"0:606\"]},{\"tk\":[389,5,389,28],\"els\":[\"0:606\"]},{\"tk\":[389,29,389,32],\"els\":[\"0:606\"]},{\"tk\":[389,33,389,48],\"els\":[\"0:606\"]},{\"tk\":[389,49,389,50],\"els\":[\"0:606\"]},{\"tk\":[389,51,389,54],\"els\":[\"0:606\"]},{\"tk\":[390,5,390,28],\"els\":[\"0:606\"]},{\"tk\":[390,29,390,32],\"els\":[\"0:606\"]},{\"tk\":[390,33,390,41],\"els\":[\"0:606\"]},{\"tk\":[390,42,390,43],\"els\":[\"0:606\"]},{\"tk\":[390,44,390,47],\"els\":[\"0:606\"]},{\"tk\":[391,5,391,28],\"els\":[\"0:606\"]},{\"tk\":[391,29,391,32],\"els\":[\"0:606\"]},{\"tk\":[391,33,391,45],\"els\":[\"0:606\"]},{\"tk\":[391,46,391,47],\"els\":[\"0:606\"]},{\"tk\":[391,48,391,51],\"els\":[\"0:606\"]},{\"tk\":[392,5,392,28],\"els\":[\"0:606\"]},{\"tk\":[392,29,392,32],\"els\":[\"0:606\"]},{\"tk\":[392,33,392,47],\"els\":[\"0:606\"]},{\"tk\":[392,48,392,49],\"els\":[\"0:606\"]},{\"tk\":[392,50,392,53],\"els\":[\"0:606\"]},{\"tk\":[393,9,393,10],\"els\":[\"0:606\"]},{\"tk\":[393,11,393,24],\"els\":[\"0:606\"]},{\"tk\":[393,24,393,25],\"els\":[\"0:606\"]},{\"tk\":[393,25,393,48],\"els\":[\"0:606\"]},{\"tk\":[393,48,393,49],\"els\":[\"0:606\"]},{\"tk\":[393,49,393,52],\"els\":[\"0:606\"]},{\"tk\":[393,52,393,53],\"els\":[\"0:606\"]},{\"tk\":[393,53,393,57],\"els\":[\"0:606\"]},{\"tk\":[393,57,393,58],\"els\":[\"0:606\"]},{\"tk\":[394,5,394,7],\"els\":[\"0:606\"]},{\"tk\":[394,13,394,14],\"els\":[\"0:606\"]},{\"tk\":[394,15,394,20],\"els\":[\"0:606\"]},{\"tk\":[395,7,395,9],\"els\":[\"0:606\"]},{\"tk\":[395,15,395,17],\"els\":[\"0:606\"]},{\"tk\":[395,18,395,21],\"els\":[\"0:606\"]},{\"tk\":[396,15,396,16],\"els\":[\"0:606\"]},{\"tk\":[396,17,396,18],\"els\":[\"0:606\"]},{\"tk\":[398,15,398,16],\"els\":[\"0:606\"]},{\"tk\":[398,17,398,19],\"els\":[\"0:606\"]},{\"tk\":[401,13,401,14],\"els\":[\"0:606\"]},{\"tk\":[401,15,401,26],\"els\":[\"0:606\"]},{\"tk\":[404,5,404,16],\"els\":[\"0:606\"]},{\"tk\":[405,5,405,28],\"els\":[\"0:606\"]},{\"tk\":[405,29,405,32],\"els\":[\"0:606\"]},{\"tk\":[405,33,405,48],\"els\":[\"0:606\"]},{\"tk\":[405,49,405,50],\"els\":[\"0:606\"]},{\"tk\":[405,51,405,55],\"els\":[\"0:606\"]},{\"tk\":[416,5,416,28],\"els\":[\"0:629\"]},{\"tk\":[416,29,416,35],\"els\":[\"0:629\"]},{\"tk\":[416,36,416,58],\"els\":[\"0:629\"]},{\"tk\":[416,59,416,60],\"els\":[\"0:629\"]},{\"tk\":[416,61,416,66],\"els\":[\"0:629\"]},{\"tk\":[426,5,426,28],\"els\":[\"0:629\"]},{\"tk\":[426,29,426,35],\"els\":[\"0:629\"]},{\"tk\":[426,36,426,49],\"els\":[\"0:629\"]},{\"tk\":[426,50,426,51],\"els\":[\"0:629\"]},{\"tk\":[426,52,426,54],\"els\":[\"0:629\"]},{\"tk\":[434,5,434,21],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:1559-1604,#111\",\"0:629\"]},{\"tk\":[434,22,434,25],\"els\":[\"0:\\\\Users\\\\oscar\\\\AppData\\\\Roaming\\\\MathWorks\\\\MATLAB Add-Ons\\\\Collections\\\\Rensselaer Arduino Support Package Library (RASPLib)\\\\RASPlib\\\\blocks\\\\soMPU6050Gyro.m:1591-1603,#111\",\"0:629\"]},{\"tk\":[435,5,435,28],\"els\":[\"0:629\"]},{\"tk\":[435,29,435,35],\"els\":[\"0:629\"]},{\"tk\":[435,36,435,51],\"els\":[\"0:629\"]},{\"tk\":[435,52,435,53],\"els\":[\"0:629\"]},{\"tk\":[435,54,435,58],\"els\":[\"0:629\"]},{\"tk\":[438,5,438,28],\"els\":[\"0:630:187\"]},{\"tk\":[438,29,438,34],\"els\":[\"0:630:187\"]},{\"tk\":[438,35,438,57],\"els\":[\"0:630:187\"]},{\"tk\":[438,58,438,59],\"els\":[\"0:630:187\"]},{\"tk\":[438,60,438,65],\"els\":[\"0:630:187\"]},{\"tk\":[439,5,439,28],\"els\":[\"0:630:187\"]},{\"tk\":[439,29,439,34],\"els\":[\"0:630:187\"]},{\"tk\":[439,35,439,48],\"els\":[\"0:630:187\"]},{\"tk\":[439,49,439,50],\"els\":[\"0:630:187\"]},{\"tk\":[439,51,439,53],\"els\":[\"0:630:187\"]},{\"tk\":[440,5,440,19],\"els\":[\"0:630:187\"]},{\"tk\":[440,20,440,21],\"els\":[\"0:630:187\"]},{\"tk\":[440,23,440,24],\"els\":[\"0:630:187\"]},{\"tk\":[441,5,441,28],\"els\":[\"0:630:187\"]},{\"tk\":[441,29,441,34],\"els\":[\"0:630:187\"]},{\"tk\":[441,35,441,50],\"els\":[\"0:630:187\"]},{\"tk\":[441,51,441,52],\"els\":[\"0:630:187\"]},{\"tk\":[441,53,441,57],\"els\":[\"0:630:187\"]},{\"tk\":[444,5,444,28],\"els\":[\"0:630:188\"]},{\"tk\":[444,29,444,34],\"els\":[\"0:630:188\"]},{\"tk\":[444,35,444,57],\"els\":[\"0:630:188\"]},{\"tk\":[444,58,444,59],\"els\":[\"0:630:188\"]},{\"tk\":[444,60,444,65],\"els\":[\"0:630:188\"]},{\"tk\":[445,9,445,10],\"els\":[\"0:630:188\"]},{\"tk\":[445,12,445,35],\"els\":[\"0:630:188\"]},{\"tk\":[445,36,445,41],\"els\":[\"0:630:188\"]},{\"tk\":[446,5,446,28],\"els\":[\"0:630:188\"]},{\"tk\":[446,29,446,34],\"els\":[\"0:630:188\"]},{\"tk\":[446,35,446,48],\"els\":[\"0:630:188\"]},{\"tk\":[446,49,446,50],\"els\":[\"0:630:188\"]},{\"tk\":[446,51,446,53],\"els\":[\"0:630:188\"]},{\"tk\":[447,10,447,22],\"els\":[\"0:630:188\"]},{\"tk\":[447,23,447,36],\"els\":[\"0:630:188\"]},{\"tk\":[447,37,447,38],\"els\":[\"0:630:188\"]},{\"tk\":[447,39,447,50],\"els\":[\"0:630:188\"]},{\"tk\":[447,51,447,54],\"els\":[\"0:630:188\"]},{\"tk\":[447,56,447,59],\"els\":[\"0:630:188\"]},{\"tk\":[447,61,447,64],\"els\":[\"0:630:188\"]},{\"tk\":[448,5,448,28],\"els\":[\"0:630:188\"]},{\"tk\":[448,29,448,34],\"els\":[\"0:630:188\"]},{\"tk\":[448,35,448,50],\"els\":[\"0:630:188\"]},{\"tk\":[448,51,448,52],\"els\":[\"0:630:188\"]},{\"tk\":[448,53,448,57],\"els\":[\"0:630:188\"]},{\"tk\":[451,5,451,28],\"els\":[\"0:616\"]},{\"tk\":[451,29,451,60],\"els\":[\"0:616\"]},{\"tk\":[451,61,451,62],\"els\":[\"0:616\"]},{\"tk\":[452,7,452,26],\"els\":[\"0:616\"]},{\"tk\":[452,27,452,58],\"els\":[\"0:616\"]},{\"tk\":[455,5,455,28],\"els\":[\"0:565:843\"]},{\"tk\":[455,29,455,46],\"els\":[\"0:565:843\"]},{\"tk\":[455,47,455,48],\"els\":[\"0:565:843\"]},{\"tk\":[456,7,456,26],\"els\":[\"0:565:843\"]},{\"tk\":[456,27,456,58],\"els\":[\"0:565:843\"]},{\"tk\":[459,5,459,28],\"els\":[\"0:565:737\"]},{\"tk\":[459,29,459,42],\"els\":[\"0:565:737\"]},{\"tk\":[459,43,459,44],\"els\":[\"0:565:737\"]},{\"tk\":[460,7,460,26],\"els\":[\"0:565:737\"]},{\"tk\":[460,27,460,58],\"els\":[\"0:565:737\"]},{\"tk\":[470,3,470,5],\"els\":[\"0:628\"]},{\"tk\":[470,7,470,8],\"els\":[\"0:628\"]},{\"tk\":[470,8,470,31],\"els\":[\"0:628\"]},{\"tk\":[470,32,470,37],\"els\":[\"0:628\"]},{\"tk\":[471,5,471,28],\"els\":[\"0:628\"]},{\"tk\":[471,29,471,34],\"els\":[\"0:628\"]},{\"tk\":[471,35,471,57],\"els\":[\"0:628\"]},{\"tk\":[471,58,471,59],\"els\":[\"0:628\"]},{\"tk\":[471,60,471,64],\"els\":[\"0:628\"]},{\"tk\":[477,3,477,5],\"els\":[\"0:606\"]},{\"tk\":[477,7,477,8],\"els\":[\"0:606\"]},{\"tk\":[477,8,477,31],\"els\":[\"0:606\"]},{\"tk\":[477,32,477,35],\"els\":[\"0:606\"]},{\"tk\":[478,5,478,28],\"els\":[\"0:606\"]},{\"tk\":[478,29,478,32],\"els\":[\"0:606\"]},{\"tk\":[478,33,478,55],\"els\":[\"0:606\"]},{\"tk\":[478,56,478,57],\"els\":[\"0:606\"]},{\"tk\":[478,58,478,62],\"els\":[\"0:606\"]},{\"tk\":[484,3,484,5],\"els\":[\"0:629\"]},{\"tk\":[484,7,484,8],\"els\":[\"0:629\"]},{\"tk\":[484,8,484,31],\"els\":[\"0:629\"]},{\"tk\":[484,32,484,38],\"els\":[\"0:629\"]},{\"tk\":[485,5,485,28],\"els\":[\"0:629\"]},{\"tk\":[485,29,485,35],\"els\":[\"0:629\"]},{\"tk\":[485,36,485,58],\"els\":[\"0:629\"]},{\"tk\":[485,59,485,60],\"els\":[\"0:629\"]},{\"tk\":[485,61,485,65],\"els\":[\"0:629\"]},{\"tk\":[491,3,491,5],\"els\":[\"0:630:187\"]},{\"tk\":[491,7,491,8],\"els\":[\"0:630:187\"]},{\"tk\":[491,8,491,31],\"els\":[\"0:630:187\"]},{\"tk\":[491,32,491,37],\"els\":[\"0:630:187\"]},{\"tk\":[492,5,492,28],\"els\":[\"0:630:187\"]},{\"tk\":[492,29,492,34],\"els\":[\"0:630:187\"]},{\"tk\":[492,35,492,57],\"els\":[\"0:630:187\"]},{\"tk\":[492,58,492,59],\"els\":[\"0:630:187\"]},{\"tk\":[492,60,492,64],\"els\":[\"0:630:187\"]},{\"tk\":[498,3,498,6],\"els\":[\"0:630:188\"]},{\"tk\":[498,7,498,8],\"els\":[\"0:630:188\"]},{\"tk\":[498,10,498,33],\"els\":[\"0:630:188\"]},{\"tk\":[498,34,498,39],\"els\":[\"0:630:188\"]},{\"tk\":[499,3,499,5],\"els\":[\"0:630:188\"]},{\"tk\":[499,7,499,8],\"els\":[\"0:630:188\"]},{\"tk\":[499,8,499,31],\"els\":[\"0:630:188\"]},{\"tk\":[499,32,499,37],\"els\":[\"0:630:188\"]},{\"tk\":[500,5,500,28],\"els\":[\"0:630:188\"]},{\"tk\":[500,29,500,34],\"els\":[\"0:630:188\"]},{\"tk\":[500,35,500,57],\"els\":[\"0:630:188\"]},{\"tk\":[500,58,500,59],\"els\":[\"0:630:188\"]},{\"tk\":[500,60,500,64],\"els\":[\"0:630:188\"]},{\"tk\":[501,5,501,7],\"els\":[\"0:630:188\"]},{\"tk\":[501,10,501,33],\"els\":[\"0:630:188\"]},{\"tk\":[501,34,501,39],\"els\":[\"0:630:188\"]},{\"tk\":[501,54,501,56],\"els\":[\"0:630:188\"]},{\"tk\":[501,57,501,59],\"els\":[\"0:630:188\"]},{\"tk\":[501,61,501,63],\"els\":[\"0:630:188\"]},{\"tk\":[502,9,502,32],\"els\":[\"0:630:188\"]},{\"tk\":[502,33,502,38],\"els\":[\"0:630:188\"]},{\"tk\":[503,7,503,10],\"els\":[\"0:630:188\"]},{\"tk\":[503,12,503,24],\"els\":[\"0:630:188\"]},{\"tk\":[503,25,503,38],\"els\":[\"0:630:188\"]},{\"tk\":[503,39,503,40],\"els\":[\"0:630:188\"]},{\"tk\":[503,41,503,57],\"els\":[\"0:630:188\"]},{\"tk\":[503,58,503,61],\"els\":[\"0:630:188\"]},{\"tk\":[504,7,504,26],\"els\":[\"0:630:188\"]},{\"tk\":[505,10,505,33],\"els\":[\"0:630:188\"]},{\"tk\":[505,34,505,39],\"els\":[\"0:630:188\"]},{\"tk\":[505,68,505,71],\"els\":[\"0:630:188\"]},{\"tk\":[506,7,506,10],\"els\":[\"0:630:188\"]},{\"tk\":[506,12,506,24],\"els\":[\"0:630:188\"]},{\"tk\":[506,25,506,38],\"els\":[\"0:630:188\"]},{\"tk\":[506,39,506,40],\"els\":[\"0:630:188\"]},{\"tk\":[506,41,506,57],\"els\":[\"0:630:188\"]},{\"tk\":[506,58,506,61],\"els\":[\"0:630:188\"]},{\"tk\":[507,7,507,19],\"els\":[\"0:630:188\"]},{\"tk\":[507,20,507,43],\"els\":[\"0:630:188\"]},{\"tk\":[507,44,507,49],\"els\":[\"0:630:188\"]}]}}}","blocks":[{"RTWName":"<S1>/measured x_w","SIDString":"LabB_PIDOverRobot:297"},{"RTWName":"<S1>/measured theta_b\n","SIDString":"LabB_PIDOverRobot:291"},{"RTWName":"<S4>/u","SIDString":"LabB_PIDOverRobot:565:606"},{"RTWName":"<S6>/preSat","SIDString":"LabB_PIDOverRobot:565:608"},{"RTWName":"<S6>/postSat","SIDString":"LabB_PIDOverRobot:565:609"},{"RTWName":"<S6>/P","SIDString":"LabB_PIDOverRobot:565:610"},{"RTWName":"<S6>/preInt","SIDString":"LabB_PIDOverRobot:565:611"},{"RTWName":"<S6>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3848"},{"RTWName":"<S6>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3849"},{"RTWName":"<S30>/preSat","SIDString":"LabB_PIDOverRobot:565:613"},{"RTWName":"<S30>/postSat","SIDString":"LabB_PIDOverRobot:565:614"},{"RTWName":"<S30>/preInt","SIDString":"LabB_PIDOverRobot:565:615"},{"RTWName":"<S30>/P","SIDString":"LabB_PIDOverRobot:565:3234"},{"RTWName":"<S30>/Kb","SIDString":"LabB_PIDOverRobot:565:616"},{"RTWName":"<S30>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3237"},{"RTWName":"<S30>/SumI2","SIDString":"LabB_PIDOverRobot:565:617"},{"RTWName":"<S30>/SumI4","SIDString":"LabB_PIDOverRobot:565:618"},{"RTWName":"<S30>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3241"},{"RTWName":"<S30>/Out1","SIDString":"LabB_PIDOverRobot:565:619"},{"RTWName":"<S4294967295>/preSat","SIDString":"LabB_PIDOverRobot:565:621"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:622"},{"RTWName":"<S4294967295>/preInt","SIDString":"LabB_PIDOverRobot:565:623"},{"RTWName":"<S4294967295>/postSat","SIDString":"LabB_PIDOverRobot:565:3281"},{"RTWName":"<S4294967295>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3925"},{"RTWName":"<S4294967295>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3926"},{"RTWName":"<S4294967295>/AND1","SIDString":"LabB_PIDOverRobot:565:624"},{"RTWName":"<S4294967295>/AND2","SIDString":"LabB_PIDOverRobot:565:625"},{"RTWName":"<S4294967295>/AND3","SIDString":"LabB_PIDOverRobot:565:626"},{"RTWName":"<S4294967295>/Constant","SIDString":"LabB_PIDOverRobot:565:627"},{"RTWName":"<S4294967295>/Constant1","SIDString":"LabB_PIDOverRobot:565:628"},{"RTWName":"<S4294967295>/DataTypeConv1","SIDString":"LabB_PIDOverRobot:565:629"},{"RTWName":"<S4294967295>/DataTypeConv2","SIDString":"LabB_PIDOverRobot:565:630"},{"RTWName":"<S4294967295>/DataTypeConv4","SIDString":"LabB_PIDOverRobot:565:632"},{"RTWName":"<S37>/preSat","SIDString":"LabB_PIDOverRobot:565:3928"},{"RTWName":"<S37>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3929"},{"RTWName":"<S37>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3930"},{"RTWName":"<S38>/preSat","SIDString":"LabB_PIDOverRobot:565:3933"},{"RTWName":"<S38>/DeadZone","SIDString":"LabB_PIDOverRobot:565:3934"},{"RTWName":"<S38>/DZ out","SIDString":"LabB_PIDOverRobot:565:3935"},{"RTWName":"<S39>/preSat","SIDString":"LabB_PIDOverRobot:565:3937"},{"RTWName":"<S39>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3938"},{"RTWName":"<S39>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3939"},{"RTWName":"<S39>/Dead Zone\nDynamic","SIDString":"LabB_PIDOverRobot:565:3940"},{"RTWName":"<S39>/DZ out","SIDString":"LabB_PIDOverRobot:565:3941"},{"RTWName":"<S37>/DZ out","SIDString":"LabB_PIDOverRobot:565:3942"},{"RTWName":"<S4294967295>/Equal1","SIDString":"LabB_PIDOverRobot:565:634"},{"RTWName":"<S4294967295>/Equal2","SIDString":"LabB_PIDOverRobot:565:635"},{"RTWName":"<S4294967295>/Memory","SIDString":"LabB_PIDOverRobot:565:636"},{"RTWName":"<S4294967295>/NOT1","SIDString":"LabB_PIDOverRobot:565:637"},{"RTWName":"<S4294967295>/NOT2","SIDString":"LabB_PIDOverRobot:565:638"},{"RTWName":"<S4294967295>/NotEqual","SIDString":"LabB_PIDOverRobot:565:639"},{"RTWName":"<S4294967295>/OR1","SIDString":"LabB_PIDOverRobot:565:640"},{"RTWName":"<S4294967295>/SignP","SIDString":"LabB_PIDOverRobot:565:641"},{"RTWName":"<S4294967295>/SignPreIntegrator","SIDString":"LabB_PIDOverRobot:565:642"},{"RTWName":"<S4294967295>/SignPreSat","SIDString":"LabB_PIDOverRobot:565:643"},{"RTWName":"<S4294967295>/Switch","SIDString":"LabB_PIDOverRobot:565:644"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3288"},{"RTWName":"<S4294967295>/ZeroGain","SIDString":"LabB_PIDOverRobot:565:645"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:646"},{"RTWName":"<S4294967295>/preSat","SIDString":"LabB_PIDOverRobot:565:1399"},{"RTWName":"<S4294967295>/preInt","SIDString":"LabB_PIDOverRobot:565:1400"},{"RTWName":"<S4294967295>/postSat","SIDString":"LabB_PIDOverRobot:565:3269"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:3270"},{"RTWName":"<S4294967295>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3907"},{"RTWName":"<S4294967295>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3908"},{"RTWName":"<S4294967295>/AND3","SIDString":"LabB_PIDOverRobot:565:1401"},{"RTWName":"<S4294967295>/Constant1","SIDString":"LabB_PIDOverRobot:565:1402"},{"RTWName":"<S4294967295>/DataTypeConv1","SIDString":"LabB_PIDOverRobot:565:1403"},{"RTWName":"<S4294967295>/DataTypeConv2","SIDString":"LabB_PIDOverRobot:565:1404"},{"RTWName":"<S40>/preSat","SIDString":"LabB_PIDOverRobot:565:3910"},{"RTWName":"<S40>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3911"},{"RTWName":"<S40>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3912"},{"RTWName":"<S41>/preSat","SIDString":"LabB_PIDOverRobot:565:3915"},{"RTWName":"<S41>/DeadZone","SIDString":"LabB_PIDOverRobot:565:3916"},{"RTWName":"<S41>/DZ out","SIDString":"LabB_PIDOverRobot:565:3917"},{"RTWName":"<S42>/preSat","SIDString":"LabB_PIDOverRobot:565:3919"},{"RTWName":"<S42>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3920"},{"RTWName":"<S42>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3921"},{"RTWName":"<S42>/Dead Zone\nDynamic","SIDString":"LabB_PIDOverRobot:565:3922"},{"RTWName":"<S42>/DZ out","SIDString":"LabB_PIDOverRobot:565:3923"},{"RTWName":"<S40>/DZ out","SIDString":"LabB_PIDOverRobot:565:3924"},{"RTWName":"<S4294967295>/Equal1","SIDString":"LabB_PIDOverRobot:565:1406"},{"RTWName":"<S4294967295>/Memory","SIDString":"LabB_PIDOverRobot:565:1415"},{"RTWName":"<S4294967295>/NotEqual","SIDString":"LabB_PIDOverRobot:565:1408"},{"RTWName":"<S4294967295>/SignPreIntegrator","SIDString":"LabB_PIDOverRobot:565:1410"},{"RTWName":"<S4294967295>/SignPreSat","SIDString":"LabB_PIDOverRobot:565:1411"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3273"},{"RTWName":"<S4294967295>/Switch","SIDString":"LabB_PIDOverRobot:565:1412"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3276"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3277"},{"RTWName":"<S4294967295>/ZeroGain","SIDString":"LabB_PIDOverRobot:565:1413"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:1414"},{"RTWName":"<S4294967295>/preInt","SIDString":"LabB_PIDOverRobot:565:3219"},{"RTWName":"<S4294967295>/preSat","SIDString":"LabB_PIDOverRobot:565:3220"},{"RTWName":"<S4294967295>/postSat","SIDString":"LabB_PIDOverRobot:565:3221"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:3222"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3411"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3225"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3226"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3227"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3228"},{"RTWName":"<S4294967295>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3230"},{"RTWName":"<S4294967295>/preSat","SIDString":"LabB_PIDOverRobot:565:1373"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:1374"},{"RTWName":"<S4294967295>/preInt","SIDString":"LabB_PIDOverRobot:565:1375"},{"RTWName":"<S4294967295>/postSat","SIDString":"LabB_PIDOverRobot:565:3257"},{"RTWName":"<S4294967295>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3899"},{"RTWName":"<S4294967295>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3900"},{"RTWName":"<S4294967295>/AND1","SIDString":"LabB_PIDOverRobot:565:1376"},{"RTWName":"<S4294967295>/AND2","SIDString":"LabB_PIDOverRobot:565:1377"},{"RTWName":"<S4294967295>/AND3","SIDString":"LabB_PIDOverRobot:565:1378"},{"RTWName":"<S4294967295>/Clamping_zero","SIDString":"LabB_PIDOverRobot:565:4033"},{"RTWName":"<S4294967295>/Constant1","SIDString":"LabB_PIDOverRobot:565:1380"},{"RTWName":"<S4294967295>/Constant4","SIDString":"LabB_PIDOverRobot:565:3954"},{"RTWName":"<S4294967295>/Constant5","SIDString":"LabB_PIDOverRobot:565:3955"},{"RTWName":"<S4294967295>/Constant6","SIDString":"LabB_PIDOverRobot:565:3957"},{"RTWName":"<S4294967295>/Constant7","SIDString":"LabB_PIDOverRobot:565:3958"},{"RTWName":"<S43>/preSat","SIDString":"LabB_PIDOverRobot:565:3884"},{"RTWName":"<S43>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3885"},{"RTWName":"<S43>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3886"},{"RTWName":"<S44>/preSat","SIDString":"LabB_PIDOverRobot:565:3889"},{"RTWName":"<S44>/DeadZone","SIDString":"LabB_PIDOverRobot:565:3890"},{"RTWName":"<S44>/DZ out","SIDString":"LabB_PIDOverRobot:565:3891"},{"RTWName":"<S45>/preSat","SIDString":"LabB_PIDOverRobot:565:3893"},{"RTWName":"<S45>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3894"},{"RTWName":"<S45>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3895"},{"RTWName":"<S45>/Dead Zone\nDynamic","SIDString":"LabB_PIDOverRobot:565:3896"},{"RTWName":"<S45>/DZ out","SIDString":"LabB_PIDOverRobot:565:3897"},{"RTWName":"<S43>/DZ out","SIDString":"LabB_PIDOverRobot:565:3898"},{"RTWName":"<S4294967295>/Equal1","SIDString":"LabB_PIDOverRobot:565:1385"},{"RTWName":"<S4294967295>/NOT1","SIDString":"LabB_PIDOverRobot:565:1387"},{"RTWName":"<S4294967295>/NOT2","SIDString":"LabB_PIDOverRobot:565:1388"},{"RTWName":"<S4294967295>/OR1","SIDString":"LabB_PIDOverRobot:565:1390"},{"RTWName":"<S4294967295>/Relational\nOperator","SIDString":"LabB_PIDOverRobot:565:4034"},{"RTWName":"<S4294967295>/Relational\nOperator1","SIDString":"LabB_PIDOverRobot:565:4036"},{"RTWName":"<S4294967295>/Switch","SIDString":"LabB_PIDOverRobot:565:1394"},{"RTWName":"<S4294967295>/Switch2","SIDString":"LabB_PIDOverRobot:565:3956"},{"RTWName":"<S4294967295>/Switch3","SIDString":"LabB_PIDOverRobot:565:3959"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3264"},{"RTWName":"<S4294967295>/fix for DT propagation issue","SIDString":"LabB_PIDOverRobot:565:4035"},{"RTWName":"<S4294967295>/fix for DT propagation issue1","SIDString":"LabB_PIDOverRobot:565:4038"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:1396"},{"RTWName":"<S4294967295>/preSat","SIDString":"LabB_PIDOverRobot:565:648"},{"RTWName":"<S4294967295>/preInt","SIDString":"LabB_PIDOverRobot:565:650"},{"RTWName":"<S4294967295>/postSat","SIDString":"LabB_PIDOverRobot:565:3245"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:3246"},{"RTWName":"<S4294967295>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3865"},{"RTWName":"<S4294967295>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3866"},{"RTWName":"<S4294967295>/AND3","SIDString":"LabB_PIDOverRobot:565:653"},{"RTWName":"<S4294967295>/Clamping_zero","SIDString":"LabB_PIDOverRobot:565:4030"},{"RTWName":"<S4294967295>/Constant","SIDString":"LabB_PIDOverRobot:565:3944"},{"RTWName":"<S4294967295>/Constant1","SIDString":"LabB_PIDOverRobot:565:655"},{"RTWName":"<S4294967295>/Constant2","SIDString":"LabB_PIDOverRobot:565:3945"},{"RTWName":"<S4294967295>/Constant3","SIDString":"LabB_PIDOverRobot:565:3947"},{"RTWName":"<S4294967295>/Constant4","SIDString":"LabB_PIDOverRobot:565:3948"},{"RTWName":"<S46>/preSat","SIDString":"LabB_PIDOverRobot:565:3851"},{"RTWName":"<S46>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3860"},{"RTWName":"<S46>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3861"},{"RTWName":"<S47>/preSat","SIDString":"LabB_PIDOverRobot:565:3853"},{"RTWName":"<S47>/DeadZone","SIDString":"LabB_PIDOverRobot:565:660"},{"RTWName":"<S47>/DZ out","SIDString":"LabB_PIDOverRobot:565:3854"},{"RTWName":"<S48>/preSat","SIDString":"LabB_PIDOverRobot:565:3856"},{"RTWName":"<S48>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3862"},{"RTWName":"<S48>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3863"},{"RTWName":"<S48>/Dead Zone\nDynamic","SIDString":"LabB_PIDOverRobot:565:3864"},{"RTWName":"<S48>/DZ out","SIDString":"LabB_PIDOverRobot:565:3857"},{"RTWName":"<S46>/DZ out","SIDString":"LabB_PIDOverRobot:565:3858"},{"RTWName":"<S4294967295>/Equal1","SIDString":"LabB_PIDOverRobot:565:661"},{"RTWName":"<S4294967295>/Relational\nOperator","SIDString":"LabB_PIDOverRobot:565:4031"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3249"},{"RTWName":"<S4294967295>/Switch","SIDString":"LabB_PIDOverRobot:565:670"},{"RTWName":"<S4294967295>/Switch1","SIDString":"LabB_PIDOverRobot:565:3943"},{"RTWName":"<S4294967295>/Switch2","SIDString":"LabB_PIDOverRobot:565:3949"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3252"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3253"},{"RTWName":"<S4294967295>/fix for DT propagation issue","SIDString":"LabB_PIDOverRobot:565:4032"},{"RTWName":"<S4294967295>/fix for DT propagation issue1","SIDString":"LabB_PIDOverRobot:565:4037"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:672"},{"RTWName":"<S4294967295>/preInt","SIDString":"LabB_PIDOverRobot:565:674"},{"RTWName":"<S4294967295>/preSat","SIDString":"LabB_PIDOverRobot:565:3216"},{"RTWName":"<S4294967295>/postSat","SIDString":"LabB_PIDOverRobot:565:3217"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:3218"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3214"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3211"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3213"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3215"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:675"},{"RTWName":"<S6>/Out1","SIDString":"LabB_PIDOverRobot:565:676"},{"RTWName":"<S7>/err","SIDString":"LabB_PIDOverRobot:565:678"},{"RTWName":"<S7>/D Gain","SIDString":"LabB_PIDOverRobot:565:679"},{"RTWName":"<S4294967295>/D Gain","SIDString":"LabB_PIDOverRobot:565:3185"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3186"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3187"},{"RTWName":"<S4294967295>/err","SIDString":"LabB_PIDOverRobot:565:682"},{"RTWName":"<S4294967295>/D Gain","SIDString":"LabB_PIDOverRobot:565:683"},{"RTWName":"<S4294967295>/DProd Out","SIDString":"LabB_PIDOverRobot:565:684"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:685"},{"RTWName":"<S31>/err","SIDString":"LabB_PIDOverRobot:565:687"},{"RTWName":"<S31>/D Gain","SIDString":"LabB_PIDOverRobot:565:3188"},{"RTWName":"<S31>/Derivative Gain","SIDString":"LabB_PIDOverRobot:565:688"},{"RTWName":"<S31>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3189"},{"RTWName":"<S31>/Terminator","SIDString":"LabB_PIDOverRobot:565:3190"},{"RTWName":"<S31>/Out1","SIDString":"LabB_PIDOverRobot:565:689"},{"RTWName":"<S7>/Out1","SIDString":"LabB_PIDOverRobot:565:690"},{"RTWName":"<S8>/Reset","SIDString":"LabB_PIDOverRobot:565:693"},{"RTWName":"<S8>/U","SIDString":"LabB_PIDOverRobot:565:694"},{"RTWName":"<S8>/N","SIDString":"LabB_PIDOverRobot:565:695"},{"RTWName":"<S8>/D0in","SIDString":"LabB_PIDOverRobot:565:696"},{"RTWName":"<S8>/Nout","SIDString":"LabB_PIDOverRobot:565:697"},{"RTWName":"<S8>/Ts","SIDString":"LabB_PIDOverRobot:565:3669"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:699"},{"RTWName":"<S4294967295>/Nout","SIDString":"LabB_PIDOverRobot:565:700"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:701"},{"RTWName":"<S4294967295>/D0in","SIDString":"LabB_PIDOverRobot:565:702"},{"RTWName":"<S4294967295>/N","SIDString":"LabB_PIDOverRobot:565:3334"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3689"},{"RTWName":"<S4294967295>/Filter","SIDString":"LabB_PIDOverRobot:565:703"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3335"},{"RTWName":"<S4294967295>/SumD","SIDString":"LabB_PIDOverRobot:565:704"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:2723"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3474"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3336"},{"RTWName":"<S4294967295>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3690"},{"RTWName":"<S4294967295>/Y","SIDString":"LabB_PIDOverRobot:565:705"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:707"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:708"},{"RTWName":"<S4294967295>/D0in","SIDString":"LabB_PIDOverRobot:565:709"},{"RTWName":"<S4294967295>/Nout","SIDString":"LabB_PIDOverRobot:565:3328"},{"RTWName":"<S4294967295>/N","SIDString":"LabB_PIDOverRobot:565:3331"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3688"},{"RTWName":"<S4294967295>/DTDup","SIDString":"LabB_PIDOverRobot:565:710"},{"RTWName":"<S4294967295>/Diff","SIDString":"LabB_PIDOverRobot:565:711"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3332"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:2722"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3333"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3330"},{"RTWName":"<S4294967295>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3480"},{"RTWName":"<S58>/U","SIDString":"LabB_PIDOverRobot:565:3671"},{"RTWName":"<S58>/Ts","SIDString":"LabB_PIDOverRobot:565:3672"},{"RTWName":"<S59>/U","SIDString":"LabB_PIDOverRobot:565:3674"},{"RTWName":"<S59>/Ts","SIDString":"LabB_PIDOverRobot:565:3675"},{"RTWName":"<S59>/Udiff*Ts Prod Out","SIDString":"LabB_PIDOverRobot:565:3676"},{"RTWName":"<S59>/Out1","SIDString":"LabB_PIDOverRobot:565:3677"},{"RTWName":"<S60>/U","SIDString":"LabB_PIDOverRobot:565:3679"},{"RTWName":"<S60>/Ts","SIDString":"LabB_PIDOverRobot:565:3680"},{"RTWName":"<S60>/Terminator","SIDString":"LabB_PIDOverRobot:565:3681"},{"RTWName":"<S60>/Tsamp","SIDString":"LabB_PIDOverRobot:565:3682"},{"RTWName":"<S60>/Out1","SIDString":"LabB_PIDOverRobot:565:3683"},{"RTWName":"<S58>/Out1","SIDString":"LabB_PIDOverRobot:565:3684"},{"RTWName":"<S4294967295>/UD","SIDString":"LabB_PIDOverRobot:565:713"},{"RTWName":"<S4294967295>/Y","SIDString":"LabB_PIDOverRobot:565:714"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:3315"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:3316"},{"RTWName":"<S4294967295>/N","SIDString":"LabB_PIDOverRobot:565:3317"},{"RTWName":"<S4294967295>/D0in","SIDString":"LabB_PIDOverRobot:565:3318"},{"RTWName":"<S4294967295>/Nout","SIDString":"LabB_PIDOverRobot:565:3319"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3686"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3320"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3432"},{"RTWName":"<S4294967295>/Signal Specification3","SIDString":"LabB_PIDOverRobot:565:3313"},{"RTWName":"<S4294967295>/Signal Specification4","SIDString":"LabB_PIDOverRobot:565:3324"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3321"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3323"},{"RTWName":"<S4294967295>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3314"},{"RTWName":"<S4294967295>/Terminator4","SIDString":"LabB_PIDOverRobot:565:3325"},{"RTWName":"<S4294967295>/Terminator5","SIDString":"LabB_PIDOverRobot:565:3327"},{"RTWName":"<S4294967295>/Terminator6","SIDString":"LabB_PIDOverRobot:565:3687"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:717"},{"RTWName":"<S4294967295>/N","SIDString":"LabB_PIDOverRobot:565:718"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:719"},{"RTWName":"<S4294967295>/D0in","SIDString":"LabB_PIDOverRobot:565:720"},{"RTWName":"<S4294967295>/Nout","SIDString":"LabB_PIDOverRobot:565:3340"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3693"},{"RTWName":"<S4294967295>/DenCoefOut","SIDString":"LabB_PIDOverRobot:565:722"},{"RTWName":"<S4294967295>/Filter Den Constant","SIDString":"LabB_PIDOverRobot:565:721"},{"RTWName":"<S4294967295>/Filter Differentiator TF","SIDString":"LabB_PIDOverRobot:565:723"},{"RTWName":"<S4294967295>/Mux","SIDString":"LabB_PIDOverRobot:565:724"},{"RTWName":"<S4294967295>/Passthrough for tuning","SIDString":"LabB_PIDOverRobot:565:725"},{"RTWName":"<S4294967295>/Reciprocal","SIDString":"LabB_PIDOverRobot:565:726"},{"RTWName":"<S4294967295>/SumDen","SIDString":"LabB_PIDOverRobot:565:727"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:2725"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3482"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3342"},{"RTWName":"<S61>/N","SIDString":"LabB_PIDOverRobot:565:3695"},{"RTWName":"<S61>/Ts","SIDString":"LabB_PIDOverRobot:565:3696"},{"RTWName":"<S62>/N","SIDString":"LabB_PIDOverRobot:565:3698"},{"RTWName":"<S62>/Ts","SIDString":"LabB_PIDOverRobot:565:3699"},{"RTWName":"<S62>/N*Ts Prod Out","SIDString":"LabB_PIDOverRobot:565:3700"},{"RTWName":"<S62>/Out1","SIDString":"LabB_PIDOverRobot:565:3701"},{"RTWName":"<S63>/N","SIDString":"LabB_PIDOverRobot:565:3703"},{"RTWName":"<S63>/Ts","SIDString":"LabB_PIDOverRobot:565:3704"},{"RTWName":"<S63>/Terminator","SIDString":"LabB_PIDOverRobot:565:3705"},{"RTWName":"<S63>/Tsamp","SIDString":"LabB_PIDOverRobot:565:3706"},{"RTWName":"<S63>/Out1","SIDString":"LabB_PIDOverRobot:565:3707"},{"RTWName":"<S61>/Out1","SIDString":"LabB_PIDOverRobot:565:3708"},{"RTWName":"<S4294967295>/Unary Minus","SIDString":"LabB_PIDOverRobot:565:729"},{"RTWName":"<S4294967295>/Y","SIDString":"LabB_PIDOverRobot:565:730"},{"RTWName":"<S32>/U","SIDString":"LabB_PIDOverRobot:565:733"},{"RTWName":"<S32>/Nout","SIDString":"LabB_PIDOverRobot:565:734"},{"RTWName":"<S32>/Reset","SIDString":"LabB_PIDOverRobot:565:735"},{"RTWName":"<S32>/D0in","SIDString":"LabB_PIDOverRobot:565:736"},{"RTWName":"<S32>/N","SIDString":"LabB_PIDOverRobot:565:3337"},{"RTWName":"<S32>/Ts","SIDString":"LabB_PIDOverRobot:565:3691"},{"RTWName":"<S32>/Filter","SIDString":"LabB_PIDOverRobot:565:737"},{"RTWName":"<S32>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3338"},{"RTWName":"<S32>/SumD","SIDString":"LabB_PIDOverRobot:565:738"},{"RTWName":"<S32>/Terminator","SIDString":"LabB_PIDOverRobot:565:2724"},{"RTWName":"<S32>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3481"},{"RTWName":"<S32>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3339"},{"RTWName":"<S32>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3692"},{"RTWName":"<S32>/Y","SIDString":"LabB_PIDOverRobot:565:739"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:741"},{"RTWName":"<S4294967295>/N","SIDString":"LabB_PIDOverRobot:565:742"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:743"},{"RTWName":"<S4294967295>/D0in","SIDString":"LabB_PIDOverRobot:565:744"},{"RTWName":"<S4294967295>/Nout","SIDString":"LabB_PIDOverRobot:565:3343"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3724"},{"RTWName":"<S4294967295>/DenCoefOut","SIDString":"LabB_PIDOverRobot:565:746"},{"RTWName":"<S4294967295>/Divide","SIDString":"LabB_PIDOverRobot:565:747"},{"RTWName":"<S4294967295>/Filter Den Constant","SIDString":"LabB_PIDOverRobot:565:745"},{"RTWName":"<S4294967295>/Filter Differentiator TF","SIDString":"LabB_PIDOverRobot:565:748"},{"RTWName":"<S4294967295>/Mux","SIDString":"LabB_PIDOverRobot:565:749"},{"RTWName":"<S4294967295>/Passthrough for tuning","SIDString":"LabB_PIDOverRobot:565:750"},{"RTWName":"<S4294967295>/Reciprocal","SIDString":"LabB_PIDOverRobot:565:751"},{"RTWName":"<S4294967295>/SumDen","SIDString":"LabB_PIDOverRobot:565:752"},{"RTWName":"<S4294967295>/SumNum","SIDString":"LabB_PIDOverRobot:565:753"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:2726"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3483"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3345"},{"RTWName":"<S64>/N","SIDString":"LabB_PIDOverRobot:565:3710"},{"RTWName":"<S64>/Ts","SIDString":"LabB_PIDOverRobot:565:3711"},{"RTWName":"<S65>/N","SIDString":"LabB_PIDOverRobot:565:3713"},{"RTWName":"<S65>/Ts","SIDString":"LabB_PIDOverRobot:565:3714"},{"RTWName":"<S65>/Gain","SIDString":"LabB_PIDOverRobot:565:3778"},{"RTWName":"<S65>/N*Ts Prod Out","SIDString":"LabB_PIDOverRobot:565:3715"},{"RTWName":"<S65>/Out1","SIDString":"LabB_PIDOverRobot:565:3716"},{"RTWName":"<S66>/N","SIDString":"LabB_PIDOverRobot:565:3718"},{"RTWName":"<S66>/Ts","SIDString":"LabB_PIDOverRobot:565:3719"},{"RTWName":"<S66>/Terminator","SIDString":"LabB_PIDOverRobot:565:3720"},{"RTWName":"<S66>/Tsamp","SIDString":"LabB_PIDOverRobot:565:3721"},{"RTWName":"<S66>/Out1","SIDString":"LabB_PIDOverRobot:565:3722"},{"RTWName":"<S64>/Out1","SIDString":"LabB_PIDOverRobot:565:3723"},{"RTWName":"<S4294967295>/Y","SIDString":"LabB_PIDOverRobot:565:755"},{"RTWName":"<S8>/Y","SIDString":"LabB_PIDOverRobot:565:757"},{"RTWName":"<S9>/D0","SIDString":"LabB_PIDOverRobot:565:759"},{"RTWName":"<S4294967295>/D0","SIDString":"LabB_PIDOverRobot:565:3197"},{"RTWName":"<S4294967295>/Ground","SIDString":"LabB_PIDOverRobot:565:3396"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3198"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3397"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3199"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3398"},{"RTWName":"<S4294967295>/D0","SIDString":"LabB_PIDOverRobot:565:762"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:763"},{"RTWName":"<S4294967295>/D0","SIDString":"LabB_PIDOverRobot:565:3203"},{"RTWName":"<S4294967295>/Ground","SIDString":"LabB_PIDOverRobot:565:3402"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3204"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3403"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3205"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3404"},{"RTWName":"<S33>/D0","SIDString":"LabB_PIDOverRobot:565:3200"},{"RTWName":"<S33>/Ground","SIDString":"LabB_PIDOverRobot:565:3399"},{"RTWName":"<S33>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3201"},{"RTWName":"<S33>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3400"},{"RTWName":"<S33>/Terminator","SIDString":"LabB_PIDOverRobot:565:3202"},{"RTWName":"<S33>/Out1","SIDString":"LabB_PIDOverRobot:565:3401"},{"RTWName":"<S9>/Out1","SIDString":"LabB_PIDOverRobot:565:770"},{"RTWName":"<S4>/Ground_D","SIDString":"LabB_PIDOverRobot:565:4006"},{"RTWName":"<S4>/Ground_D0","SIDString":"LabB_PIDOverRobot:565:3767"},{"RTWName":"<S4>/Ground_I","SIDString":"LabB_PIDOverRobot:565:4005"},{"RTWName":"<S4>/Ground_I0","SIDString":"LabB_PIDOverRobot:565:3766"},{"RTWName":"<S4>/Ground_LowerLimit","SIDString":"LabB_PIDOverRobot:565:3881"},{"RTWName":"<S4>/Ground_N","SIDString":"LabB_PIDOverRobot:565:4007"},{"RTWName":"<S4>/Ground_P","SIDString":"LabB_PIDOverRobot:565:4004"},{"RTWName":"<S4>/Ground_Reset","SIDString":"LabB_PIDOverRobot:565:3478"},{"RTWName":"<S4>/Ground_TR","SIDString":"LabB_PIDOverRobot:565:2278"},{"RTWName":"<S4>/Ground_UpperLimit","SIDString":"LabB_PIDOverRobot:565:3880"},{"RTWName":"<S4>/Ground_extTs","SIDString":"LabB_PIDOverRobot:565:4013"},{"RTWName":"<S10>/err","SIDString":"LabB_PIDOverRobot:565:781"},{"RTWName":"<S10>/I Gain","SIDString":"LabB_PIDOverRobot:565:782"},{"RTWName":"<S4294967295>/I Gain","SIDString":"LabB_PIDOverRobot:565:3170"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3171"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3172"},{"RTWName":"<S4294967295>/err","SIDString":"LabB_PIDOverRobot:565:785"},{"RTWName":"<S4294967295>/I Gain","SIDString":"LabB_PIDOverRobot:565:786"},{"RTWName":"<S4294967295>/IProd Out","SIDString":"LabB_PIDOverRobot:565:787"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:788"},{"RTWName":"<S34>/err","SIDString":"LabB_PIDOverRobot:565:790"},{"RTWName":"<S34>/I Gain","SIDString":"LabB_PIDOverRobot:565:3173"},{"RTWName":"<S34>/Integral Gain","SIDString":"LabB_PIDOverRobot:565:791"},{"RTWName":"<S34>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3174"},{"RTWName":"<S34>/Terminator","SIDString":"LabB_PIDOverRobot:565:3175"},{"RTWName":"<S34>/Out1","SIDString":"LabB_PIDOverRobot:565:792"},{"RTWName":"<S10>/Out1","SIDString":"LabB_PIDOverRobot:565:793"},{"RTWName":"<S11>/In1","SIDString":"LabB_PIDOverRobot:565:796"},{"RTWName":"<S11>/P Gain","SIDString":"LabB_PIDOverRobot:565:797"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:799"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:800"},{"RTWName":"<S4294967295>/PProd Out","SIDString":"LabB_PIDOverRobot:565:801"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:802"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:804"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:3368"},{"RTWName":"<S4294967295>/Proportional Gain","SIDString":"LabB_PIDOverRobot:565:805"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3369"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3370"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:806"},{"RTWName":"<S35>/In1","SIDString":"LabB_PIDOverRobot:565:808"},{"RTWName":"<S35>/P Gain","SIDString":"LabB_PIDOverRobot:565:3365"},{"RTWName":"<S35>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3367"},{"RTWName":"<S35>/Out1","SIDString":"LabB_PIDOverRobot:565:809"},{"RTWName":"<S11>/Out1","SIDString":"LabB_PIDOverRobot:565:810"},{"RTWName":"<S12>/In1","SIDString":"LabB_PIDOverRobot:565:812"},{"RTWName":"<S12>/P Gain","SIDString":"LabB_PIDOverRobot:565:813"},{"RTWName":"<S36>/In1","SIDString":"LabB_PIDOverRobot:565:3420"},{"RTWName":"<S36>/P Gain","SIDString":"LabB_PIDOverRobot:565:3421"},{"RTWName":"<S36>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3464"},{"RTWName":"<S36>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3422"},{"RTWName":"<S36>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3424"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:815"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:816"},{"RTWName":"<S4294967295>/PProd Out","SIDString":"LabB_PIDOverRobot:565:817"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:818"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:820"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:3362"},{"RTWName":"<S4294967295>/Proportional Gain","SIDString":"LabB_PIDOverRobot:565:821"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3363"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3364"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:822"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:824"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:3359"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3361"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:825"},{"RTWName":"<S12>/Out1","SIDString":"LabB_PIDOverRobot:565:826"},{"RTWName":"<S13>/U","SIDString":"LabB_PIDOverRobot:565:828"},{"RTWName":"<S13>/I0in","SIDString":"LabB_PIDOverRobot:565:829"},{"RTWName":"<S13>/Reset","SIDString":"LabB_PIDOverRobot:565:830"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:832"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:833"},{"RTWName":"<S4294967295>/I0in","SIDString":"LabB_PIDOverRobot:565:834"},{"RTWName":"<S4294967295>/Ground","SIDString":"LabB_PIDOverRobot:565:3433"},{"RTWName":"<S4294967295>/Integrator","SIDString":"LabB_PIDOverRobot:565:835"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3434"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:2708"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3473"},{"RTWName":"<S4294967295>/state","SIDString":"LabB_PIDOverRobot:565:3435"},{"RTWName":"<S4294967295>/out","SIDString":"LabB_PIDOverRobot:565:836"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:3412"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:3406"},{"RTWName":"<S4294967295>/I0in","SIDString":"LabB_PIDOverRobot:565:3405"},{"RTWName":"<S4294967295>/Ground","SIDString":"LabB_PIDOverRobot:565:3491"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3413"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3490"},{"RTWName":"<S4294967295>/Signal Specification4","SIDString":"LabB_PIDOverRobot:565:3408"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3409"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3410"},{"RTWName":"<S4294967295>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3414"},{"RTWName":"<S4294967295>/out","SIDString":"LabB_PIDOverRobot:565:3492"},{"RTWName":"<S37>/U","SIDString":"LabB_PIDOverRobot:565:839"},{"RTWName":"<S37>/Reset","SIDString":"LabB_PIDOverRobot:565:840"},{"RTWName":"<S37>/I0in","SIDString":"LabB_PIDOverRobot:565:841"},{"RTWName":"<S37>/Ground_Integrator","SIDString":"LabB_PIDOverRobot:565:2704"},{"RTWName":"<S37>/Integrator","SIDString":"LabB_PIDOverRobot:565:843"},{"RTWName":"<S37>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3472"},{"RTWName":"<S37>/Terminator","SIDString":"LabB_PIDOverRobot:565:844"},{"RTWName":"<S37>/Terminator1","SIDString":"LabB_PIDOverRobot:565:2709"},{"RTWName":"<S37>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3479"},{"RTWName":"<S37>/out","SIDString":"LabB_PIDOverRobot:565:845"},{"RTWName":"<S37>/state","SIDString":"LabB_PIDOverRobot:565:846"},{"RTWName":"<S13>/state","SIDString":"LabB_PIDOverRobot:565:847"},{"RTWName":"<S13>/out","SIDString":"LabB_PIDOverRobot:565:848"},{"RTWName":"<S14>/I0","SIDString":"LabB_PIDOverRobot:565:850"},{"RTWName":"<S4294967295>/I0","SIDString":"LabB_PIDOverRobot:565:3176"},{"RTWName":"<S4294967295>/Ground","SIDString":"LabB_PIDOverRobot:565:3386"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3177"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3385"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3178"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3384"},{"RTWName":"<S4294967295>/I0","SIDString":"LabB_PIDOverRobot:565:853"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:854"},{"RTWName":"<S38>/I0","SIDString":"LabB_PIDOverRobot:565:3179"},{"RTWName":"<S38>/Ground","SIDString":"LabB_PIDOverRobot:565:3387"},{"RTWName":"<S38>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3180"},{"RTWName":"<S38>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3388"},{"RTWName":"<S38>/Terminator","SIDString":"LabB_PIDOverRobot:565:3181"},{"RTWName":"<S38>/Out1","SIDString":"LabB_PIDOverRobot:565:3389"},{"RTWName":"<S14>/Out1","SIDString":"LabB_PIDOverRobot:565:858"},{"RTWName":"<S15>/N Gain","SIDString":"LabB_PIDOverRobot:565:861"},{"RTWName":"<S39>/N Gain","SIDString":"LabB_PIDOverRobot:565:3485"},{"RTWName":"<S39>/Terminator","SIDString":"LabB_PIDOverRobot:565:3487"},{"RTWName":"<S4294967295>/N Gain","SIDString":"LabB_PIDOverRobot:565:3191"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3416"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3193"},{"RTWName":"<S4294967295>/N Gain","SIDString":"LabB_PIDOverRobot:565:865"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:866"},{"RTWName":"<S4294967295>/N Gain","SIDString":"LabB_PIDOverRobot:565:3194"},{"RTWName":"<S4294967295>/N Copy","SIDString":"LabB_PIDOverRobot:565:868"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3195"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3196"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:869"},{"RTWName":"<S15>/Out1","SIDString":"LabB_PIDOverRobot:565:870"},{"RTWName":"<S16>/U","SIDString":"LabB_PIDOverRobot:565:872"},{"RTWName":"<S16>/N Gain","SIDString":"LabB_PIDOverRobot:565:873"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:3349"},{"RTWName":"<S4294967295>/N Gain","SIDString":"LabB_PIDOverRobot:565:3350"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3351"},{"RTWName":"<S4294967295>/Signal Specification2","SIDString":"LabB_PIDOverRobot:565:3347"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3352"},{"RTWName":"<S4294967295>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3348"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:876"},{"RTWName":"<S4294967295>/N Gain","SIDString":"LabB_PIDOverRobot:565:877"},{"RTWName":"<S4294967295>/NProd Out","SIDString":"LabB_PIDOverRobot:565:878"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:879"},{"RTWName":"<S40>/U","SIDString":"LabB_PIDOverRobot:565:881"},{"RTWName":"<S40>/N Gain","SIDString":"LabB_PIDOverRobot:565:3356"},{"RTWName":"<S40>/Filter Coefficient","SIDString":"LabB_PIDOverRobot:565:882"},{"RTWName":"<S40>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3357"},{"RTWName":"<S40>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3358"},{"RTWName":"<S40>/Out1","SIDString":"LabB_PIDOverRobot:565:883"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:885"},{"RTWName":"<S4294967295>/N Gain","SIDString":"LabB_PIDOverRobot:565:3353"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3355"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:886"},{"RTWName":"<S16>/Out1","SIDString":"LabB_PIDOverRobot:565:887"},{"RTWName":"<S17>/P Gain","SIDString":"LabB_PIDOverRobot:565:889"},{"RTWName":"<S41>/P Gain","SIDString":"LabB_PIDOverRobot:565:3291"},{"RTWName":"<S41>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3302"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:892"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:893"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:3303"},{"RTWName":"<S4294967295>/P Copy","SIDString":"LabB_PIDOverRobot:565:895"},{"RTWName":"<S4294967295>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3305"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:896"},{"RTWName":"<S17>/Out1","SIDString":"LabB_PIDOverRobot:565:900"},{"RTWName":"<S18>/err","SIDString":"LabB_PIDOverRobot:565:903"},{"RTWName":"<S18>/P Gain","SIDString":"LabB_PIDOverRobot:565:904"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:3161"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3162"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3163"},{"RTWName":"<S4294967295>/err","SIDString":"LabB_PIDOverRobot:565:907"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:908"},{"RTWName":"<S4294967295>/PProd Out","SIDString":"LabB_PIDOverRobot:565:909"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:910"},{"RTWName":"<S42>/err","SIDString":"LabB_PIDOverRobot:565:912"},{"RTWName":"<S42>/P Gain","SIDString":"LabB_PIDOverRobot:565:3167"},{"RTWName":"<S42>/Proportional Gain","SIDString":"LabB_PIDOverRobot:565:913"},{"RTWName":"<S42>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3168"},{"RTWName":"<S42>/Terminator","SIDString":"LabB_PIDOverRobot:565:3169"},{"RTWName":"<S42>/Out1","SIDString":"LabB_PIDOverRobot:565:914"},{"RTWName":"<S4294967295>/err","SIDString":"LabB_PIDOverRobot:565:916"},{"RTWName":"<S4294967295>/P Gain","SIDString":"LabB_PIDOverRobot:565:3164"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3166"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:917"},{"RTWName":"<S18>/Out1","SIDString":"LabB_PIDOverRobot:565:918"},{"RTWName":"<S19>/Reset","SIDString":"LabB_PIDOverRobot:565:1418"},{"RTWName":"<S43>/Reset","SIDString":"LabB_PIDOverRobot:565:3182"},{"RTWName":"<S43>/Ground","SIDString":"LabB_PIDOverRobot:565:3393"},{"RTWName":"<S43>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3183"},{"RTWName":"<S43>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3394"},{"RTWName":"<S43>/Terminator","SIDString":"LabB_PIDOverRobot:565:3184"},{"RTWName":"<S43>/Out1","SIDString":"LabB_PIDOverRobot:565:3395"},{"RTWName":"<S4294967295>/Reset","SIDString":"LabB_PIDOverRobot:565:1421"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:1422"},{"RTWName":"<S19>/Out1","SIDString":"LabB_PIDOverRobot:565:1426"},{"RTWName":"<S20>/In1","SIDString":"LabB_PIDOverRobot:565:920"},{"RTWName":"<S20>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3794"},{"RTWName":"<S20>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3795"},{"RTWName":"<S44>/In1","SIDString":"LabB_PIDOverRobot:565:922"},{"RTWName":"<S44>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3802"},{"RTWName":"<S44>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3803"},{"RTWName":"<S44>/Saturation","SIDString":"LabB_PIDOverRobot:565:923"},{"RTWName":"<S44>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3804"},{"RTWName":"<S44>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3805"},{"RTWName":"<S44>/Terminator","SIDString":"LabB_PIDOverRobot:565:3806"},{"RTWName":"<S44>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3807"},{"RTWName":"<S44>/Out1","SIDString":"LabB_PIDOverRobot:565:924"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:3780"},{"RTWName":"<S4294967295>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3783"},{"RTWName":"<S4294967295>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3784"},{"RTWName":"<S107>/up","SIDString":"LabB_PIDOverRobot:565:3846:1"},{"RTWName":"<S107>/u","SIDString":"LabB_PIDOverRobot:565:3846:2"},{"RTWName":"<S107>/lo","SIDString":"LabB_PIDOverRobot:565:3846:3"},{"RTWName":"<S107>/Data Type\nDuplicate","SIDString":"LabB_PIDOverRobot:565:3846:4"},{"RTWName":"<S107>/Data Type\nPropagation","SIDString":"LabB_PIDOverRobot:565:3846:5"},{"RTWName":"<S107>/LowerRelop1","SIDString":"LabB_PIDOverRobot:565:3846:6"},{"RTWName":"<S107>/Switch","SIDString":"LabB_PIDOverRobot:565:3846:7"},{"RTWName":"<S107>/Switch2","SIDString":"LabB_PIDOverRobot:565:3846:8"},{"RTWName":"<S107>/UpperRelop","SIDString":"LabB_PIDOverRobot:565:3846:9"},{"RTWName":"<S107>/y","SIDString":"LabB_PIDOverRobot:565:3846:10"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3782"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:926"},{"RTWName":"<S4294967295>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3798"},{"RTWName":"<S4294967295>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3799"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3796"},{"RTWName":"<S4294967295>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3800"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3797"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3801"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:927"},{"RTWName":"<S20>/Out1","SIDString":"LabB_PIDOverRobot:565:928"},{"RTWName":"<S21>/In1","SIDString":"LabB_PIDOverRobot:565:930"},{"RTWName":"<S21>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3808"},{"RTWName":"<S21>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3809"},{"RTWName":"<S45>/In1","SIDString":"LabB_PIDOverRobot:565:3428"},{"RTWName":"<S45>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3430"},{"RTWName":"<S45>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3431"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:932"},{"RTWName":"<S4294967295>/Saturation","SIDString":"LabB_PIDOverRobot:565:933"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:934"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:3787"},{"RTWName":"<S4294967295>/Upper Limit","SIDString":"LabB_PIDOverRobot:565:3788"},{"RTWName":"<S4294967295>/Lower Limit","SIDString":"LabB_PIDOverRobot:565:3789"},{"RTWName":"<S112>/up","SIDString":"LabB_PIDOverRobot:565:3847:1"},{"RTWName":"<S112>/u","SIDString":"LabB_PIDOverRobot:565:3847:2"},{"RTWName":"<S112>/lo","SIDString":"LabB_PIDOverRobot:565:3847:3"},{"RTWName":"<S112>/Data Type\nDuplicate","SIDString":"LabB_PIDOverRobot:565:3847:4"},{"RTWName":"<S112>/Data Type\nPropagation","SIDString":"LabB_PIDOverRobot:565:3847:5"},{"RTWName":"<S112>/LowerRelop1","SIDString":"LabB_PIDOverRobot:565:3847:6"},{"RTWName":"<S112>/Switch","SIDString":"LabB_PIDOverRobot:565:3847:7"},{"RTWName":"<S112>/Switch2","SIDString":"LabB_PIDOverRobot:565:3847:8"},{"RTWName":"<S112>/UpperRelop","SIDString":"LabB_PIDOverRobot:565:3847:9"},{"RTWName":"<S112>/y","SIDString":"LabB_PIDOverRobot:565:3847:10"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3791"},{"RTWName":"<S4294967295>/In1","SIDString":"LabB_PIDOverRobot:565:936"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:937"},{"RTWName":"<S21>/Out1","SIDString":"LabB_PIDOverRobot:565:938"},{"RTWName":"<S22>/P","SIDString":"LabB_PIDOverRobot:565:3494"},{"RTWName":"<S22>/I","SIDString":"LabB_PIDOverRobot:565:3503"},{"RTWName":"<S22>/D","SIDString":"LabB_PIDOverRobot:565:3504"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:4039"},{"RTWName":"<S4294967295>/I","SIDString":"LabB_PIDOverRobot:565:3499"},{"RTWName":"<S4294967295>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:4041"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:4040"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3500"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:3496"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3497"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:3519"},{"RTWName":"<S4294967295>/D","SIDString":"LabB_PIDOverRobot:565:3521"},{"RTWName":"<S4294967295>/Sum","SIDString":"LabB_PIDOverRobot:565:3522"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3511"},{"RTWName":"<S4294967295>/P","SIDString":"LabB_PIDOverRobot:565:3515"},{"RTWName":"<S4294967295>/I","SIDString":"LabB_PIDOverRobot:565:3516"},{"RTWName":"<S4294967295>/Sum","SIDString":"LabB_PIDOverRobot:565:3518"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3508"},{"RTWName":"<S46>/P","SIDString":"LabB_PIDOverRobot:565:3523"},{"RTWName":"<S46>/I","SIDString":"LabB_PIDOverRobot:565:3524"},{"RTWName":"<S46>/D","SIDString":"LabB_PIDOverRobot:565:3525"},{"RTWName":"<S46>/Sum","SIDString":"LabB_PIDOverRobot:565:3526"},{"RTWName":"<S46>/Out1","SIDString":"LabB_PIDOverRobot:565:3514"},{"RTWName":"<S22>/Out1","SIDString":"LabB_PIDOverRobot:565:3501"},{"RTWName":"<S23>/fromP","SIDString":"LabB_PIDOverRobot:565:3443"},{"RTWName":"<S23>/fromState","SIDString":"LabB_PIDOverRobot:565:3455"},{"RTWName":"<S23>/fromD","SIDString":"LabB_PIDOverRobot:565:3456"},{"RTWName":"<S47>/fromP","SIDString":"LabB_PIDOverRobot:565:3461"},{"RTWName":"<S47>/fromState","SIDString":"LabB_PIDOverRobot:565:3462"},{"RTWName":"<S47>/fromD","SIDString":"LabB_PIDOverRobot:565:3463"},{"RTWName":"<S47>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3488"},{"RTWName":"<S47>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3468"},{"RTWName":"<S47>/Terminator2","SIDString":"LabB_PIDOverRobot:565:3469"},{"RTWName":"<S47>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3470"},{"RTWName":"<S4294967295>/fromP","SIDString":"LabB_PIDOverRobot:565:3457"},{"RTWName":"<S4294967295>/fromState","SIDString":"LabB_PIDOverRobot:565:3458"},{"RTWName":"<S4294967295>/fromD","SIDString":"LabB_PIDOverRobot:565:3459"},{"RTWName":"<S4294967295>/Sum Fdbk","SIDString":"LabB_PIDOverRobot:565:3471"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3454"},{"RTWName":"<S4294967295>/fromState","SIDString":"LabB_PIDOverRobot:565:3460"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3449"},{"RTWName":"<S23>/Out1","SIDString":"LabB_PIDOverRobot:565:3450"},{"RTWName":"<S24>/uout","SIDString":"LabB_PIDOverRobot:565:943"},{"RTWName":"<S24>/TR","SIDString":"LabB_PIDOverRobot:565:944"},{"RTWName":"<S48>/uout","SIDString":"LabB_PIDOverRobot:565:3306"},{"RTWName":"<S48>/TR","SIDString":"LabB_PIDOverRobot:565:3309"},{"RTWName":"<S48>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3310"},{"RTWName":"<S48>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3311"},{"RTWName":"<S48>/Terminator3","SIDString":"LabB_PIDOverRobot:565:3308"},{"RTWName":"<S4294967295>/uout","SIDString":"LabB_PIDOverRobot:565:947"},{"RTWName":"<S4294967295>/TR","SIDString":"LabB_PIDOverRobot:565:948"},{"RTWName":"<S4294967295>/Kt","SIDString":"LabB_PIDOverRobot:565:949"},{"RTWName":"<S4294967295>/SumI3","SIDString":"LabB_PIDOverRobot:565:950"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:951"},{"RTWName":"<S24>/Out1","SIDString":"LabB_PIDOverRobot:565:952"},{"RTWName":"<S25>/fromIgain","SIDString":"LabB_PIDOverRobot:565:3132"},{"RTWName":"<S25>/fromTR","SIDString":"LabB_PIDOverRobot:565:3141"},{"RTWName":"<S49>/fromIgain","SIDString":"LabB_PIDOverRobot:565:3134"},{"RTWName":"<S49>/fromTR","SIDString":"LabB_PIDOverRobot:565:3206"},{"RTWName":"<S49>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3207"},{"RTWName":"<S49>/Terminator","SIDString":"LabB_PIDOverRobot:565:3208"},{"RTWName":"<S49>/Out1","SIDString":"LabB_PIDOverRobot:565:3135"},{"RTWName":"<S4294967295>/fromIgain","SIDString":"LabB_PIDOverRobot:565:3137"},{"RTWName":"<S4294967295>/fromTR","SIDString":"LabB_PIDOverRobot:565:3142"},{"RTWName":"<S4294967295>/SumI1","SIDString":"LabB_PIDOverRobot:565:941"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3138"},{"RTWName":"<S25>/Out1","SIDString":"LabB_PIDOverRobot:565:3139"},{"RTWName":"<S26>/U","SIDString":"LabB_PIDOverRobot:565:3589"},{"RTWName":"<S26>/Ts","SIDString":"LabB_PIDOverRobot:565:3590"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:3592"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3593"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3594"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3595"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:3603"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3604"},{"RTWName":"<S4294967295>/Uintegral*Ts Prod Out","SIDString":"LabB_PIDOverRobot:565:3605"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3606"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:3664"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3665"},{"RTWName":"<S4294967295>/Terminator","SIDString":"LabB_PIDOverRobot:565:3666"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3667"},{"RTWName":"<S50>/U","SIDString":"LabB_PIDOverRobot:565:3597"},{"RTWName":"<S50>/Ts","SIDString":"LabB_PIDOverRobot:565:3598"},{"RTWName":"<S50>/Signal Specification","SIDString":"LabB_PIDOverRobot:565:3599"},{"RTWName":"<S50>/Terminator","SIDString":"LabB_PIDOverRobot:565:3600"},{"RTWName":"<S50>/Out1","SIDString":"LabB_PIDOverRobot:565:3601"},{"RTWName":"<S26>/Out1","SIDString":"LabB_PIDOverRobot:565:3607"},{"RTWName":"<S27>/U","SIDString":"LabB_PIDOverRobot:565:3625"},{"RTWName":"<S27>/Ts","SIDString":"LabB_PIDOverRobot:565:3626"},{"RTWName":"<S4294967295>/U","SIDString":"LabB_PIDOverRobot:565:3628"},{"RTWName":"<S4294967295>/Ts","SIDString":"LabB_PIDOverRobot:565:3629"},{"RTWName":"<S4294967295>/Ungain*Ts Prod Out","SIDString":"LabB_PIDOverRobot:565:3630"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:3631"},{"RTWName":"<S51>/U","SIDString":"LabB_PIDOverRobot:565:3633"},{"RTWName":"<S51>/Ts","SIDString":"LabB_PIDOverRobot:565:3634"},{"RTWName":"<S51>/Terminator","SIDString":"LabB_PIDOverRobot:565:3635"},{"RTWName":"<S51>/Out1","SIDString":"LabB_PIDOverRobot:565:3637"},{"RTWName":"<S27>/Out1","SIDString":"LabB_PIDOverRobot:565:3638"},{"RTWName":"<S28>/feedback","SIDString":"LabB_PIDOverRobot:565:954"},{"RTWName":"<S28>/forward","SIDString":"LabB_PIDOverRobot:565:955"},{"RTWName":"<S4294967295>/feedback","SIDString":"LabB_PIDOverRobot:565:957"},{"RTWName":"<S4294967295>/forward","SIDString":"LabB_PIDOverRobot:565:3380"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3382"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:958"},{"RTWName":"<S52>/feedback","SIDString":"LabB_PIDOverRobot:565:3377"},{"RTWName":"<S52>/forward","SIDString":"LabB_PIDOverRobot:565:960"},{"RTWName":"<S52>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3438"},{"RTWName":"<S52>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3379"},{"RTWName":"<S52>/Out1","SIDString":"LabB_PIDOverRobot:565:961"},{"RTWName":"<S28>/Out1","SIDString":"LabB_PIDOverRobot:565:962"},{"RTWName":"<S29>/feedback","SIDString":"LabB_PIDOverRobot:565:964"},{"RTWName":"<S29>/forward","SIDString":"LabB_PIDOverRobot:565:965"},{"RTWName":"<S4294967295>/feedback","SIDString":"LabB_PIDOverRobot:565:967"},{"RTWName":"<S4294967295>/forward","SIDString":"LabB_PIDOverRobot:565:3371"},{"RTWName":"<S4294967295>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3373"},{"RTWName":"<S4294967295>/Out1","SIDString":"LabB_PIDOverRobot:565:968"},{"RTWName":"<S53>/feedback","SIDString":"LabB_PIDOverRobot:565:3374"},{"RTWName":"<S53>/forward","SIDString":"LabB_PIDOverRobot:565:970"},{"RTWName":"<S53>/Signal Specification1","SIDString":"LabB_PIDOverRobot:565:3437"},{"RTWName":"<S53>/Terminator1","SIDString":"LabB_PIDOverRobot:565:3376"},{"RTWName":"<S53>/Out1","SIDString":"LabB_PIDOverRobot:565:971"},{"RTWName":"<S29>/Out1","SIDString":"LabB_PIDOverRobot:565:972"},{"RTWName":"<S4>/y","SIDString":"LabB_PIDOverRobot:565:973"},{"RTWName":"<S1>/Product1","SIDString":"LabB_PIDOverRobot:511"},{"RTWName":"<S5>/signal 1","SIDString":"LabB_PIDOverRobot:569"},{"RTWName":"<S5>/signal 2","SIDString":"LabB_PIDOverRobot:570"},{"RTWName":"<S5>/signal 3","SIDString":"LabB_PIDOverRobot:571"},{"RTWName":"<S5>/signal 4","SIDString":"LabB_PIDOverRobot:572"},{"RTWName":"<S5>/signal 5","SIDString":"LabB_PIDOverRobot:573"},{"RTWName":"<S5>/signal 6","SIDString":"LabB_PIDOverRobot:574"},{"RTWName":"<S5>/signal 7","SIDString":"LabB_PIDOverRobot:575"},{"RTWName":"<S5>/Constant","SIDString":"LabB_PIDOverRobot:576"},{"RTWName":"<S5>/Data Type Conversion","SIDString":"LabB_PIDOverRobot:577"},{"RTWName":"<S5>/Data Type Conversion1","SIDString":"LabB_PIDOverRobot:578"},{"RTWName":"<S5>/Data Type Conversion2","SIDString":"LabB_PIDOverRobot:579"},{"RTWName":"<S5>/Data Type Conversion3","SIDString":"LabB_PIDOverRobot:580"},{"RTWName":"<S5>/Data Type Conversion4","SIDString":"LabB_PIDOverRobot:581"},{"RTWName":"<S5>/Data Type Conversion5","SIDString":"LabB_PIDOverRobot:582"},{"RTWName":"<S5>/Data Type Conversion6","SIDString":"LabB_PIDOverRobot:583"},{"RTWName":"<S54>/u","SIDString":"LabB_PIDOverRobot:584:1"},{"RTWName":"<S54>/DTProp1","SIDString":"LabB_PIDOverRobot:584:2"},{"RTWName":"<S54>/DTProp2","SIDString":"LabB_PIDOverRobot:584:3"},{"RTWName":"<S54>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:584:4"},{"RTWName":"<S54>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:584:5"},{"RTWName":"<S54>/y","SIDString":"LabB_PIDOverRobot:584:6"},{"RTWName":"<S55>/u","SIDString":"LabB_PIDOverRobot:585:1"},{"RTWName":"<S55>/DTProp1","SIDString":"LabB_PIDOverRobot:585:2"},{"RTWName":"<S55>/DTProp2","SIDString":"LabB_PIDOverRobot:585:3"},{"RTWName":"<S55>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:585:4"},{"RTWName":"<S55>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:585:5"},{"RTWName":"<S55>/y","SIDString":"LabB_PIDOverRobot:585:6"},{"RTWName":"<S56>/u","SIDString":"LabB_PIDOverRobot:586:1"},{"RTWName":"<S56>/DTProp1","SIDString":"LabB_PIDOverRobot:586:2"},{"RTWName":"<S56>/DTProp2","SIDString":"LabB_PIDOverRobot:586:3"},{"RTWName":"<S56>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:586:4"},{"RTWName":"<S56>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:586:5"},{"RTWName":"<S56>/y","SIDString":"LabB_PIDOverRobot:586:6"},{"RTWName":"<S57>/u","SIDString":"LabB_PIDOverRobot:587:1"},{"RTWName":"<S57>/DTProp1","SIDString":"LabB_PIDOverRobot:587:2"},{"RTWName":"<S57>/DTProp2","SIDString":"LabB_PIDOverRobot:587:3"},{"RTWName":"<S57>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:587:4"},{"RTWName":"<S57>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:587:5"},{"RTWName":"<S57>/y","SIDString":"LabB_PIDOverRobot:587:6"},{"RTWName":"<S58>/u","SIDString":"LabB_PIDOverRobot:588:1"},{"RTWName":"<S58>/DTProp1","SIDString":"LabB_PIDOverRobot:588:2"},{"RTWName":"<S58>/DTProp2","SIDString":"LabB_PIDOverRobot:588:3"},{"RTWName":"<S58>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:588:4"},{"RTWName":"<S58>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:588:5"},{"RTWName":"<S58>/y","SIDString":"LabB_PIDOverRobot:588:6"},{"RTWName":"<S59>/u","SIDString":"LabB_PIDOverRobot:589:1"},{"RTWName":"<S59>/DTProp1","SIDString":"LabB_PIDOverRobot:589:2"},{"RTWName":"<S59>/DTProp2","SIDString":"LabB_PIDOverRobot:589:3"},{"RTWName":"<S59>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:589:4"},{"RTWName":"<S59>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:589:5"},{"RTWName":"<S59>/y","SIDString":"LabB_PIDOverRobot:589:6"},{"RTWName":"<S60>/u","SIDString":"LabB_PIDOverRobot:590:1"},{"RTWName":"<S60>/DTProp1","SIDString":"LabB_PIDOverRobot:590:2"},{"RTWName":"<S60>/DTProp2","SIDString":"LabB_PIDOverRobot:590:3"},{"RTWName":"<S60>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:590:4"},{"RTWName":"<S60>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:590:5"},{"RTWName":"<S60>/y","SIDString":"LabB_PIDOverRobot:590:6"},{"RTWName":"<S61>/u","SIDString":"LabB_PIDOverRobot:591:1"},{"RTWName":"<S61>/DTProp1","SIDString":"LabB_PIDOverRobot:591:2"},{"RTWName":"<S61>/DTProp2","SIDString":"LabB_PIDOverRobot:591:3"},{"RTWName":"<S61>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:591:4"},{"RTWName":"<S61>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:591:5"},{"RTWName":"<S61>/y","SIDString":"LabB_PIDOverRobot:591:6"},{"RTWName":"<S62>/u","SIDString":"LabB_PIDOverRobot:592:1"},{"RTWName":"<S62>/DTProp1","SIDString":"LabB_PIDOverRobot:592:2"},{"RTWName":"<S62>/DTProp2","SIDString":"LabB_PIDOverRobot:592:3"},{"RTWName":"<S62>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:592:4"},{"RTWName":"<S62>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:592:5"},{"RTWName":"<S62>/y","SIDString":"LabB_PIDOverRobot:592:6"},{"RTWName":"<S63>/u","SIDString":"LabB_PIDOverRobot:593:1"},{"RTWName":"<S63>/DTProp1","SIDString":"LabB_PIDOverRobot:593:2"},{"RTWName":"<S63>/DTProp2","SIDString":"LabB_PIDOverRobot:593:3"},{"RTWName":"<S63>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:593:4"},{"RTWName":"<S63>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:593:5"},{"RTWName":"<S63>/y","SIDString":"LabB_PIDOverRobot:593:6"},{"RTWName":"<S64>/u","SIDString":"LabB_PIDOverRobot:594:1"},{"RTWName":"<S64>/DTProp1","SIDString":"LabB_PIDOverRobot:594:2"},{"RTWName":"<S64>/DTProp2","SIDString":"LabB_PIDOverRobot:594:3"},{"RTWName":"<S64>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:594:4"},{"RTWName":"<S64>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:594:5"},{"RTWName":"<S64>/y","SIDString":"LabB_PIDOverRobot:594:6"},{"RTWName":"<S65>/u","SIDString":"LabB_PIDOverRobot:595:1"},{"RTWName":"<S65>/DTProp1","SIDString":"LabB_PIDOverRobot:595:2"},{"RTWName":"<S65>/DTProp2","SIDString":"LabB_PIDOverRobot:595:3"},{"RTWName":"<S65>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:595:4"},{"RTWName":"<S65>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:595:5"},{"RTWName":"<S65>/y","SIDString":"LabB_PIDOverRobot:595:6"},{"RTWName":"<S66>/u","SIDString":"LabB_PIDOverRobot:596:1"},{"RTWName":"<S66>/DTProp1","SIDString":"LabB_PIDOverRobot:596:2"},{"RTWName":"<S66>/DTProp2","SIDString":"LabB_PIDOverRobot:596:3"},{"RTWName":"<S66>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:596:4"},{"RTWName":"<S66>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:596:5"},{"RTWName":"<S66>/y","SIDString":"LabB_PIDOverRobot:596:6"},{"RTWName":"<S67>/u","SIDString":"LabB_PIDOverRobot:597:1"},{"RTWName":"<S67>/DTProp1","SIDString":"LabB_PIDOverRobot:597:2"},{"RTWName":"<S67>/DTProp2","SIDString":"LabB_PIDOverRobot:597:3"},{"RTWName":"<S67>/Extract Desired Bits","SIDString":"LabB_PIDOverRobot:597:4"},{"RTWName":"<S67>/Modify Scaling Only","SIDString":"LabB_PIDOverRobot:597:5"},{"RTWName":"<S67>/y","SIDString":"LabB_PIDOverRobot:597:6"},{"RTWName":"<S5>/Fcn","SIDString":"LabB_PIDOverRobot:598"},{"RTWName":"<S5>/Fcn1","SIDString":"LabB_PIDOverRobot:599"},{"RTWName":"<S5>/Fcn2","SIDString":"LabB_PIDOverRobot:600"},{"RTWName":"<S5>/Fcn3","SIDString":"LabB_PIDOverRobot:601"},{"RTWName":"<S5>/Fcn4","SIDString":"LabB_PIDOverRobot:602"},{"RTWName":"<S5>/Fcn5","SIDString":"LabB_PIDOverRobot:603"},{"RTWName":"<S5>/Fcn6","SIDString":"LabB_PIDOverRobot:604"},{"RTWName":"<S5>/Mux","SIDString":"LabB_PIDOverRobot:605"},{"RTWName":"<S5>/Serial Transmit","SIDString":"LabB_PIDOverRobot:606"},{"RTWName":"<S1>/turn off the motor if the measured angle\nis greater than X degrees","SIDString":"LabB_PIDOverRobot:190"},{"RTWName":"<S1>/volts","SIDString":"LabB_PIDOverRobot:607"},{"RTWName":"<S2>/encoder","SIDString":"LabB_PIDOverRobot:614"},{"RTWName":"<S2>/gyro","SIDString":"LabB_PIDOverRobot:615"},{"RTWName":"<S2>/Discrete-Time\n Integrator\n(convert from theta_b_dot\nto theta_b)","SIDString":"LabB_PIDOverRobot:616"},{"RTWName":"<S2>/Sum","SIDString":"LabB_PIDOverRobot:617"},{"RTWName":"<S2>/convert to\nradians/sec","SIDString":"LabB_PIDOverRobot:618"},{"RTWName":"<S2>/convert to \nradians","SIDString":"LabB_PIDOverRobot:619"},{"RTWName":"<S2>/convert to meters","SIDString":"LabB_PIDOverRobot:620"},{"RTWName":"<S2>/gyro bias","SIDString":"LabB_PIDOverRobot:621"},{"RTWName":"<S2>/measured_x_w","SIDString":"LabB_PIDOverRobot:622"},{"RTWName":"<S2>/measured_theta_b","SIDString":"LabB_PIDOverRobot:623"},{"RTWName":"<S3>/volts","SIDString":"LabB_PIDOverRobot:625"},{"RTWName":"<S3>/Data Type\n Conversion1","SIDString":"LabB_PIDOverRobot:626"},{"RTWName":"<S3>/Data Type\n Conversion2","SIDString":"LabB_PIDOverRobot:627"},{"RTWName":"<S3>/Encoder","SIDString":"LabB_PIDOverRobot:628"},{"RTWName":"<S3>/Gyroscope","SIDString":"LabB_PIDOverRobot:629"},{"RTWName":"<S68>/Volts","SIDString":"LabB_PIDOverRobot:630:183"},{"RTWName":"<S69>/u","SIDString":"LabB_PIDOverRobot:630:185:1"},{"RTWName":"<S69>/Compare","SIDString":"LabB_PIDOverRobot:630:185:2"},{"RTWName":"<S69>/Constant","SIDString":"LabB_PIDOverRobot:630:185:3"},{"RTWName":"<S69>/y","SIDString":"LabB_PIDOverRobot:630:185:5"},{"RTWName":"<S68>/Digital Output1","SIDString":"LabB_PIDOverRobot:630:187"},{"RTWName":"<S68>/PWM","SIDString":"LabB_PIDOverRobot:630:188"},{"RTWName":"<S68>/Saturation\n-Vsupply to\nVsupply","SIDString":"LabB_PIDOverRobot:630:189"},{"RTWName":"<S68>/conversion to dutycycle\n(convert to uint8, overflow will provide\nreverse polairty magnitued)","SIDString":"LabB_PIDOverRobot:630:190"},{"RTWName":"<S3>/Terminator1","SIDString":"LabB_PIDOverRobot:631"},{"RTWName":"<S3>/Terminator2","SIDString":"LabB_PIDOverRobot:632"},{"RTWName":"<S3>/encoder","SIDString":"LabB_PIDOverRobot:633"},{"RTWName":"<S3>/gyro","SIDString":"LabB_PIDOverRobot:634"},{"RTWName":"<Root>/controller","SIDString":"LabB_PIDOverRobot:271"},{"RTWName":"<S1>/PID Controller","SIDString":"LabB_PIDOverRobot:565"},{"RTWName":"<S4>/Anti-windup","SIDString":"LabB_PIDOverRobot:565:607"},{"RTWName":"<S6>/Back Calculation","SIDString":"LabB_PIDOverRobot:565:612"},{"RTWName":"<S6>/Cont. Clamping Ideal","SIDString":"LabB_PIDOverRobot:565:620"},{"RTWName":"<S4294967295>/Dead Zone","SIDString":"LabB_PIDOverRobot:565:3927"},{"RTWName":"<S37>/Disabled","SIDString":"LabB_PIDOverRobot:565:3931"},{"RTWName":"<S37>/Enabled","SIDString":"LabB_PIDOverRobot:565:3932"},{"RTWName":"<S37>/External","SIDString":"LabB_PIDOverRobot:565:3936"},{"RTWName":"<S6>/Cont. Clamping Parallel","SIDString":"LabB_PIDOverRobot:565:1398"},{"RTWName":"<S4294967295>/Dead Zone","SIDString":"LabB_PIDOverRobot:565:3909"},{"RTWName":"<S40>/Disabled","SIDString":"LabB_PIDOverRobot:565:3913"},{"RTWName":"<S40>/Enabled","SIDString":"LabB_PIDOverRobot:565:3914"},{"RTWName":"<S40>/External","SIDString":"LabB_PIDOverRobot:565:3918"},{"RTWName":"<S6>/Disabled","SIDString":"LabB_PIDOverRobot:565:2304"},{"RTWName":"<S6>/Disc. Clamping Ideal","SIDString":"LabB_PIDOverRobot:565:1372"},{"RTWName":"<S4294967295>/Dead Zone","SIDString":"LabB_PIDOverRobot:565:3883"},{"RTWName":"<S43>/Disabled","SIDString":"LabB_PIDOverRobot:565:3887"},{"RTWName":"<S43>/Enabled","SIDString":"LabB_PIDOverRobot:565:3888"},{"RTWName":"<S43>/External","SIDString":"LabB_PIDOverRobot:565:3892"},{"RTWName":"<S6>/Disc. Clamping Parallel","SIDString":"LabB_PIDOverRobot:565:647"},{"RTWName":"<S4294967295>/Dead Zone","SIDString":"LabB_PIDOverRobot:565:3850"},{"RTWName":"<S46>/Disabled","SIDString":"LabB_PIDOverRobot:565:3874"},{"RTWName":"<S46>/Enabled","SIDString":"LabB_PIDOverRobot:565:3852"},{"RTWName":"<S46>/External","SIDString":"LabB_PIDOverRobot:565:3855"},{"RTWName":"<S6>/Passthrough","SIDString":"LabB_PIDOverRobot:565:673"},{"RTWName":"<S4>/D Gain","SIDString":"LabB_PIDOverRobot:565:677"},{"RTWName":"<S7>/Disabled","SIDString":"LabB_PIDOverRobot:565:680"},{"RTWName":"<S7>/External Parameters","SIDString":"LabB_PIDOverRobot:565:681"},{"RTWName":"<S7>/Internal Parameters","SIDString":"LabB_PIDOverRobot:565:686"},{"RTWName":"<S4>/Filter","SIDString":"LabB_PIDOverRobot:565:692"},{"RTWName":"<S8>/Cont. Filter","SIDString":"LabB_PIDOverRobot:565:698"},{"RTWName":"<S8>/Differentiator","SIDString":"LabB_PIDOverRobot:565:706"},{"RTWName":"<S4294967295>/Tsamp","SIDString":"LabB_PIDOverRobot:565:3670"},{"RTWName":"<S58>/External Ts","SIDString":"LabB_PIDOverRobot:565:3673"},{"RTWName":"<S58>/Internal Ts","SIDString":"LabB_PIDOverRobot:565:3678"},{"RTWName":"<S8>/Disabled","SIDString":"LabB_PIDOverRobot:565:715"},{"RTWName":"<S8>/Disc. Backward Euler Filter","SIDString":"LabB_PIDOverRobot:565:716"},{"RTWName":"<S4294967295>/Tsamp","SIDString":"LabB_PIDOverRobot:565:3694"},{"RTWName":"<S61>/External Ts","SIDString":"LabB_PIDOverRobot:565:3697"},{"RTWName":"<S61>/Internal Ts","SIDString":"LabB_PIDOverRobot:565:3702"},{"RTWName":"<S8>/Disc. Forward Euler Filter","SIDString":"LabB_PIDOverRobot:565:732"},{"RTWName":"<S8>/Disc. Trapezoidal Filter","SIDString":"LabB_PIDOverRobot:565:740"},{"RTWName":"<S4294967295>/Tsamp","SIDString":"LabB_PIDOverRobot:565:3709"},{"RTWName":"<S64>/External Ts","SIDString":"LabB_PIDOverRobot:565:3712"},{"RTWName":"<S64>/Internal Ts","SIDString":"LabB_PIDOverRobot:565:3717"},{"RTWName":"<S4>/Filter ICs","SIDString":"LabB_PIDOverRobot:565:758"},{"RTWName":"<S9>/Disabled","SIDString":"LabB_PIDOverRobot:565:760"},{"RTWName":"<S9>/External IC","SIDString":"LabB_PIDOverRobot:565:761"},{"RTWName":"<S9>/Internal IC - Differentiator","SIDString":"LabB_PIDOverRobot:565:764"},{"RTWName":"<S9>/Internal IC - Filter","SIDString":"LabB_PIDOverRobot:565:767"},{"RTWName":"<S4>/I Gain","SIDString":"LabB_PIDOverRobot:565:780"},{"RTWName":"<S10>/Disabled","SIDString":"LabB_PIDOverRobot:565:783"},{"RTWName":"<S10>/External Parameters","SIDString":"LabB_PIDOverRobot:565:784"},{"RTWName":"<S10>/Internal Parameters","SIDString":"LabB_PIDOverRobot:565:789"},{"RTWName":"<S4>/Ideal P Gain","SIDString":"LabB_PIDOverRobot:565:795"},{"RTWName":"<S11>/External Parameters","SIDString":"LabB_PIDOverRobot:565:798"},{"RTWName":"<S11>/Internal Parameters","SIDString":"LabB_PIDOverRobot:565:803"},{"RTWName":"<S11>/Passthrough","SIDString":"LabB_PIDOverRobot:565:807"},{"RTWName":"<S4>/Ideal P Gain Fdbk","SIDString":"LabB_PIDOverRobot:565:811"},{"RTWName":"<S12>/Disabled","SIDString":"LabB_PIDOverRobot:565:3417"},{"RTWName":"<S12>/External Parameters","SIDString":"LabB_PIDOverRobot:565:814"},{"RTWName":"<S12>/Internal Parameters","SIDString":"LabB_PIDOverRobot:565:819"},{"RTWName":"<S12>/Passthrough","SIDString":"LabB_PIDOverRobot:565:823"},{"RTWName":"<S4>/Integrator","SIDString":"LabB_PIDOverRobot:565:827"},{"RTWName":"<S13>/Continuous","SIDString":"LabB_PIDOverRobot:565:831"},{"RTWName":"<S13>/Disabled","SIDString":"LabB_PIDOverRobot:565:837"},{"RTWName":"<S13>/Discrete","SIDString":"LabB_PIDOverRobot:565:838"},{"RTWName":"<S4>/Integrator ICs","SIDString":"LabB_PIDOverRobot:565:849"},{"RTWName":"<S14>/Disabled","SIDString":"LabB_PIDOverRobot:565:851"},{"RTWName":"<S14>/External IC","SIDString":"LabB_PIDOverRobot:565:852"},{"RTWName":"<S14>/Internal IC","SIDString":"LabB_PIDOverRobot:565:855"},{"RTWName":"<S4>/N Copy","SIDString":"LabB_PIDOverRobot:565:860"},{"RTWName":"<S15>/Disabled","SIDString":"LabB_PIDOverRobot:565:3484"},{"RTWName":"<S15>/Disabled wSignal Specification","SIDString":"LabB_PIDOverRobot:565:862"},{"RTWName":"<S15>/External Parameters","SIDString":"LabB_PIDOverRobot:565:864"},{"RTWName":"<S15>/Internal Parameters","SIDString":"LabB_PIDOverRobot:565:867"},{"RTWName":"<S4>/N Gain","SIDString":"LabB_PIDOverRobot:565:871"},{"RTWName":"<S16>/Disabled","SIDString":"LabB_PIDOverRobot:565:874"},{"RTWName":"<S16>/External Parameters","SIDString":"LabB_PIDOverRobot:565:875"},{"RTWName":"<S16>/Internal Parameters","SIDString":"LabB_PIDOverRobot:565:880"},{"RTWName":"<S16>/Passthrough","SIDString":"LabB_PIDOverRobot:565:884"},{"RTWName":"<S4>/P Copy","SIDString":"LabB_PIDOverRobot:565:888"},{"RTWName":"<S17>/Disabled","SIDString":"LabB_PIDOverRobot:565:890"},{"RTWName":"<S17>/External Parameters Ideal","SIDString":"LabB_PIDOverRobot:565:891"},{"RTWName":"<S17>/Internal Parameters Ideal","SIDString":"LabB_PIDOverRobot:565:894"},{"RTWName":"<S4>/PID Compensator Formula","SIDString":"LabB_PIDOverRobot:565:901"},{"RTWName":"<S4>/Parallel P Gain","SIDString":"LabB_PIDOverRobot:565:902"},{"RTWName":"<S18>/Disabled","SIDString":"LabB_PIDOverRobot:565:905"},{"RTWName":"<S18>/External Parameters","SIDString":"LabB_PIDOverRobot:565:906"},{"RTWName":"<S18>/Internal Parameters","SIDString":"LabB_PIDOverRobot:565:911"},{"RTWName":"<S18>/Passthrough","SIDString":"LabB_PIDOverRobot:565:915"},{"RTWName":"<S4>/Reset Signal","SIDString":"LabB_PIDOverRobot:565:1417"},{"RTWName":"<S19>/Disabled","SIDString":"LabB_PIDOverRobot:565:1419"},{"RTWName":"<S19>/External Reset","SIDString":"LabB_PIDOverRobot:565:1420"},{"RTWName":"<S4>/Saturation","SIDString":"LabB_PIDOverRobot:565:919"},{"RTWName":"<S20>/Enabled","SIDString":"LabB_PIDOverRobot:565:921"},{"RTWName":"<S20>/External","SIDString":"LabB_PIDOverRobot:565:3779"},{"RTWName":"<S4294967295>/Saturation\nDynamic","SIDString":"LabB_PIDOverRobot:565:3846"},{"RTWName":"<S20>/Passthrough","SIDString":"LabB_PIDOverRobot:565:925"},{"RTWName":"<S4>/Saturation Fdbk","SIDString":"LabB_PIDOverRobot:565:929"},{"RTWName":"<S21>/Disabled","SIDString":"LabB_PIDOverRobot:565:3427"},{"RTWName":"<S21>/Enabled","SIDString":"LabB_PIDOverRobot:565:931"},{"RTWName":"<S21>/External","SIDString":"LabB_PIDOverRobot:565:3786"},{"RTWName":"<S4294967295>/Saturation\nDynamic","SIDString":"LabB_PIDOverRobot:565:3847"},{"RTWName":"<S21>/Passthrough","SIDString":"LabB_PIDOverRobot:565:935"},{"RTWName":"<S4>/Sum","SIDString":"LabB_PIDOverRobot:565:3493"},{"RTWName":"<S22>/Passthrough_I","SIDString":"LabB_PIDOverRobot:565:3498"},{"RTWName":"<S22>/Passthrough_P","SIDString":"LabB_PIDOverRobot:565:3495"},{"RTWName":"<S22>/Sum_PD","SIDString":"LabB_PIDOverRobot:565:3509"},{"RTWName":"<S22>/Sum_PI","SIDString":"LabB_PIDOverRobot:565:3506"},{"RTWName":"<S22>/Sum_PID","SIDString":"LabB_PIDOverRobot:565:3512"},{"RTWName":"<S4>/Sum Fdbk","SIDString":"LabB_PIDOverRobot:565:3442"},{"RTWName":"<S23>/Disabled","SIDString":"LabB_PIDOverRobot:565:3444"},{"RTWName":"<S23>/Enabled","SIDString":"LabB_PIDOverRobot:565:3452"},{"RTWName":"<S23>/Passthrough","SIDString":"LabB_PIDOverRobot:565:3447"},{"RTWName":"<S4>/Tracking Mode","SIDString":"LabB_PIDOverRobot:565:942"},{"RTWName":"<S24>/Disabled","SIDString":"LabB_PIDOverRobot:565:945"},{"RTWName":"<S24>/Enabled","SIDString":"LabB_PIDOverRobot:565:946"},{"RTWName":"<S4>/Tracking Mode Sum","SIDString":"LabB_PIDOverRobot:565:3131"},{"RTWName":"<S25>/Passthrough","SIDString":"LabB_PIDOverRobot:565:3133"},{"RTWName":"<S25>/Tracking Mode","SIDString":"LabB_PIDOverRobot:565:3136"},{"RTWName":"<S4>/Tsamp - Integral","SIDString":"LabB_PIDOverRobot:565:3588"},{"RTWName":"<S26>/Disabled","SIDString":"LabB_PIDOverRobot:565:3591"},{"RTWName":"<S26>/External Ts","SIDString":"LabB_PIDOverRobot:565:3602"},{"RTWName":"<S26>/Passthrough","SIDString":"LabB_PIDOverRobot:565:3663"},{"RTWName":"<S26>/TsSignalSpecification","SIDString":"LabB_PIDOverRobot:565:3596"},{"RTWName":"<S4>/Tsamp - Ngain","SIDString":"LabB_PIDOverRobot:565:3624"},{"RTWName":"<S27>/External Ts","SIDString":"LabB_PIDOverRobot:565:3627"},{"RTWName":"<S27>/Passthrough","SIDString":"LabB_PIDOverRobot:565:3632"},{"RTWName":"<S4>/postSat Signal","SIDString":"LabB_PIDOverRobot:565:953"},{"RTWName":"<S28>/Feedback_Path","SIDString":"LabB_PIDOverRobot:565:956"},{"RTWName":"<S28>/Forward_Path","SIDString":"LabB_PIDOverRobot:565:959"},{"RTWName":"<S4>/preSat Signal","SIDString":"LabB_PIDOverRobot:565:963"},{"RTWName":"<S29>/Feedback_Path","SIDString":"LabB_PIDOverRobot:565:966"},{"RTWName":"<S29>/Forward_Path","SIDString":"LabB_PIDOverRobot:565:969"},{"RTWName":"<S1>/send through the serial port","SIDString":"LabB_PIDOverRobot:568"},{"RTWName":"<S5>/Extract Bits","SIDString":"LabB_PIDOverRobot:584"},{"RTWName":"<S5>/Extract Bits1","SIDString":"LabB_PIDOverRobot:585"},{"RTWName":"<S5>/Extract Bits10","SIDString":"LabB_PIDOverRobot:586"},{"RTWName":"<S5>/Extract Bits11","SIDString":"LabB_PIDOverRobot:587"},{"RTWName":"<S5>/Extract Bits12","SIDString":"LabB_PIDOverRobot:588"},{"RTWName":"<S5>/Extract Bits13","SIDString":"LabB_PIDOverRobot:589"},{"RTWName":"<S5>/Extract Bits2","SIDString":"LabB_PIDOverRobot:590"},{"RTWName":"<S5>/Extract Bits3","SIDString":"LabB_PIDOverRobot:591"},{"RTWName":"<S5>/Extract Bits4","SIDString":"LabB_PIDOverRobot:592"},{"RTWName":"<S5>/Extract Bits5","SIDString":"LabB_PIDOverRobot:593"},{"RTWName":"<S5>/Extract Bits6","SIDString":"LabB_PIDOverRobot:594"},{"RTWName":"<S5>/Extract Bits7","SIDString":"LabB_PIDOverRobot:595"},{"RTWName":"<S5>/Extract Bits8","SIDString":"LabB_PIDOverRobot:596"},{"RTWName":"<S5>/Extract Bits9","SIDString":"LabB_PIDOverRobot:597"},{"RTWName":"<Root>/measurement\nfilter","SIDString":"LabB_PIDOverRobot:613"},{"RTWName":"<Root>/plant","SIDString":"LabB_PIDOverRobot:624"},{"RTWName":"<S3>/M1V4 Left Motor Driver\nPWM6, D8 FST","SIDString":"LabB_PIDOverRobot:630"},{"RTWName":"<S68>/Compare\nTo Zero","SIDString":"LabB_PIDOverRobot:630:185"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};